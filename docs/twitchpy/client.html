<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>twitchpy.client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>twitchpy.client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import math
import os

import requests

import twitchpy.errors
from twitchpy.badge import Badge
from twitchpy.channel import Channel
from twitchpy.charity_campaign import CharityCampaign
from twitchpy.charity_campaign_donation import CharityCampaignDonation
from twitchpy.clip import Clip
from twitchpy.emote import Emote
from twitchpy.eventsub_subscription import EventSubSubscription
from twitchpy.extension import Extension
from twitchpy.game import Game
from twitchpy.guest_star_session import GuestStarSession
from twitchpy.hypetrain_event import HypeTrainEvent
from twitchpy.poll import Poll
from twitchpy.prediction import Prediction
from twitchpy.redemption import Redemption
from twitchpy.reward import Reward
from twitchpy.stream import Stream
from twitchpy.stream_schedule import StreamSchedule
from twitchpy.tag import Tag
from twitchpy.team import Team
from twitchpy.user import User
from twitchpy.video import Video

CONTENT_TYPE_APPLICATION_JSON = &#34;application/json&#34;
ENDPOINT_CUSTOM_REWARDS = &#34;https://api.twitch.tv/helix/channel_points/custom_rewards&#34;
ENDPOINT_EVENTSUB_SUBSCRIPTION = &#34;https://api.twitch.tv/helix/eventsub/subscriptions&#34;
ENDPOINT_MODERATION_BLOCKED_TERMS = (
    &#34;https://api.twitch.tv/helix/moderation/blocked_terms&#34;
)
ENDPOINT_POLLS = &#34;https://api.twitch.tv/helix/polls&#34;
ENDPOINT_PREDICTIONS = &#34;https://api.twitch.tv/helix/predictions&#34;
ENDPOINT_SCHEDULE_SEGMENT = &#34;https://api.twitch.tv/helix/schedule/segment&#34;
ENDPOINT_USER_BLOCKS = &#34;https://api.twitch.tv/helix/users/blocks&#34;
ENDPOINT_VIPS = &#34;https://api.twitch.tv/helix/channels/vips&#34;
ENDPOINT_GUEST_STAR_SESSION = &#34;https://api.twitch.tv/helix/guest_star/session&#34;
ENDPOINT_GUEST_STAR_INVITES = &#34;https://api.twitch.tv/helix/guest_star/invites&#34;
ENDPOINT_GUEST_STAR_SLOT = &#34;https://api.twitch.tv/helix/guest_star/slot&#34;
URL_OAUTH2_TOKEN = &#34;https://id.twitch.tv/oauth2/token&#34;
ENDPOINT_MODERATORS = &#34;https://api.twitch.tv/helix/moderation/moderators&#34;


class Client:
    &#34;&#34;&#34;
    Represents a client connection to the Twitch API
    &#34;&#34;&#34;

    def __init__(
        self,
        oauth_token,
        client_id,
        client_secret,
        redirect_uri,
        tokens_path,
        code=&#34;&#34;,
        jwt_token=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Args:
            oauth_token (str): OAuth Token
            client_id (str): Client ID
            client_secret (str): Client secret
            redirect_uri (str): Redirect URI
            tokens_path (str): Path of tokens file (file included)
            code (str, optional): Authorization code for getting an user token
            jwt_token (str, optional): JWT Token
        &#34;&#34;&#34;

        self.oauth_token = oauth_token
        self.client_id = client_id
        self.client_secret = client_secret
        self.redirect_uri = redirect_uri
        self.tokens_path = tokens_path
        self.__app_token = self.__get_app_token()

        if code != &#34;&#34;:
            self.__user_token = self.__get_user_token(code)

        else:
            self.__user_token = &#34;&#34;

        self.__jwt_token = jwt_token

    def __get_app_token(self):
        url = URL_OAUTH2_TOKEN
        payload = {
            &#34;client_id&#34;: self.client_id,
            &#34;client_secret&#34;: self.client_secret,
            &#34;grant_type&#34;: &#34;client_credentials&#34;,
        }

        response = requests.post(url, json=payload)

        if response.ok:
            return response.json()[&#34;access_token&#34;]

        else:
            raise twitchpy.errors.AppTokenError(&#34;Error obtaining app token&#34;)

    def __is_last_code_used(self, code):
        try:
            tokens_file = open(self.tokens_path)
            tokens = tokens_file.readlines()
            tokens_file.close()

        except Exception:
            return False

        for token in tokens:
            token = token.replace(&#34; &#34;, &#34;&#34;).replace(&#34;\n&#34;, &#34;&#34;)
            token = token.split(&#34;=&#34;)

            if token[0] == &#34;CODE&#34; and token[1] == code:
                return True

        return False

    def __read_user_tokens_from_file(self, file):
        try:
            secret_file = open(file, &#34;rt&#34;)
            data = secret_file.readlines()
            secret_file.close()

        except Exception as error:
            logging.exception(&#34;Error reading tokens&#34;)
            raise error

        user_token = &#34;&#34;
        refresh_user_token = &#34;&#34;

        for i in range(len(data)):
            secret = data[i].split(&#34;=&#34;)

            if &#34;USER_TOKEN&#34; == secret[0]:
                user_token = secret[1].replace(&#34;\n&#34;, &#34;&#34;)

            if &#34;REFRESH_USER_TOKEN&#34; == secret[0]:
                refresh_user_token = secret[1].replace(&#34;\n&#34;, &#34;&#34;)

        return user_token, refresh_user_token

    def __save_user_tokens_in_file(self, file, user_token, user_refresh_token, code):
        data = f&#34;USER_TOKEN={user_token}\nREFRESH_USER_TOKEN={user_refresh_token}\nCODE={code}&#34;

        secret_file = open(file, &#34;wt&#34;)
        secret_file.write(data)
        secret_file.close()

    def __generate_user_tokens(self, code, file):
        url = URL_OAUTH2_TOKEN
        payload = {
            &#34;client_id&#34;: self.client_id,
            &#34;client_secret&#34;: self.client_secret,
            &#34;code&#34;: code,
            &#34;grant_type&#34;: &#34;authorization_code&#34;,
            &#34;redirect_uri&#34;: self.redirect_uri,
        }

        response = requests.post(url, payload)

        if response.ok:
            response = response.json()
            self.__save_user_tokens_in_file(
                file, response[&#34;access_token&#34;], response[&#34;refresh_token&#34;], code
            )

            return response[&#34;access_token&#34;], response[&#34;refresh_token&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def __refresh_user_tokens(self, refresh_user_token):
        url = URL_OAUTH2_TOKEN
        payload = {
            &#34;grant_type&#34;: &#34;refresh_token&#34;,
            &#34;refresh_token&#34;: refresh_user_token,
            &#34;client_id&#34;: self.client_id,
            &#34;client_secret&#34;: self.client_secret,
        }

        response = requests.post(url, json=payload)

        if response.ok:
            response = response.json()
            return response[&#34;access_token&#34;], response[&#34;refresh_token&#34;]

        else:
            raise twitchpy.errors.UserTokenError(&#34;Error obtaining user token&#34;)

    def __get_user_token(self, code):
        if self.__is_last_code_used(code) or (
            not self.__is_last_code_used(code) and os.path.isfile(self.tokens_path)
        ):
            user_token, refresh_user_token = self.__read_user_tokens_from_file(
                self.tokens_path
            )
            user_token, refresh_user_token = self.__refresh_user_tokens(
                refresh_user_token
            )
            self.__save_user_tokens_in_file(
                self.tokens_path, user_token, refresh_user_token, code
            )

        else:
            user_token, refresh_user_token = self.__generate_user_tokens(
                code, self.tokens_path
            )

        return user_token

    def start_commercial(self, broadcaster_id, length):
        &#34;&#34;&#34;
        Starts a commercial on a specified channel

        Args:
            broadcaster_id (int): ID of the channel requesting a commercial
            length (int): Desired length of the commercial in seconds
                          Valid options are 30, 60, 90, 120, 150 and 180

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels/commercial&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;length&#34;: length}

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            response = response.json()
            return response[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_ad_schedule(self, broadcaster_id: str) -&gt; dict:
        &#34;&#34;&#34;
        Returns ad schedule related information, including snooze, when the last ad was run, when the next ad is scheduled, and if the channel is currently in pre-roll free time

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels/ads&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def snooze_next_ad(self, broadcaster_id) -&gt; dict:
        &#34;&#34;&#34;
        If available, pushes back the timestamp of the upcoming automatic mid-roll ad by 5 minutes

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels/ads/schedule/snooze&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_extension_analytics(
        self, ended_at=&#34;&#34;, extension_id=&#34;&#34;, first=20, started_at=&#34;&#34;, type=&#34;&#34;
    ):
        &#34;&#34;&#34;
        Gets a URL that Extension developers can use to download analytics reports for their Extensions
        The URL is valid for 5 minutes

        Args:
            ended_at (str, optional): Ending date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
                                      If this is provided, started_at also must be specified
            extension_id (str, optional): Client ID value assigned to the extension when it is created
            first (int, optional): Maximum number of objects to return
                                   Default: 20
            started_at (str, optional): Starting date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
                                        This must be on or after January 31, 2018
                                        If this is provided, ended_at also must be specified
            type (str, optional): Type of analytics report that is returned
                                  Valid values: &#34;overview_v2&#34;

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/analytics/extensions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if ended_at != &#34;&#34;:
            params[&#34;ended_at&#34;] = ended_at

        if extension_id != &#34;&#34;:
            params[&#34;extension_id&#34;] = extension_id

        if started_at != &#34;&#34;:
            params[&#34;started_at&#34;] = started_at

        if type != &#34;&#34;:
            params[&#34;type&#34;] = type

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        extension_analytics = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                extension_analytics.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return extension_analytics

    def get_game_analytics(
        self, ended_at=&#34;&#34;, first=20, game_id=&#34;&#34;, started_at=&#34;&#34;, type=&#34;&#34;
    ):
        &#34;&#34;&#34;
        Gets a URL that game developers can use to download analytics reports for their games
        The URL is valid for 5 minutes

        Args:
            ended_at (str, optional): Ending date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
                                      If this is provided, started_at also must be specified
            first (int, optional): Maximum number of objects to return
                                   Default: 20
            game_id (str, optional): Game ID
            started_at (str, optional): Starting date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
                                        If this is provided, ended_at also must be specified
            type (str, optional): Type of analytics report that is returned
                                  Valid values: &#34;overview_v2&#34;

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/analytics/games&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if ended_at != &#34;&#34;:
            params[&#34;ended_at&#34;] = ended_at

        if game_id != &#34;&#34;:
            params[&#34;game_id&#34;] = game_id

        if started_at != &#34;&#34;:
            params[&#34;started_at&#34;] = started_at

        if type != &#34;&#34;:
            params[&#34;type&#34;] = type

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        game_analytics = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                game_analytics.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return game_analytics

    def get_bits_leaderboard(self, count=10, period=&#34;all&#34;, started_at=&#34;&#34;, user_id=&#34;&#34;):
        &#34;&#34;&#34;
        Gets a ranked list of Bits leaderboard information for a broadcaster

        Args:
            count (int, optional): Number of results to be returned
                                   Maximum: 100
                                   Default: 10
            period (str, optional): Time period over which data is aggregated (PST time zone)
                                    This parameter interacts with started_at
                                    Default: &#34;all&#34;
                                    Valid values: &#34;day&#34;, &#34;week&#34;, &#34;month&#34;, &#34;year&#34;, &#34;all&#34;
            started_at (str, optional): Timestamp for the period over which the returned data is aggregated
                                        Must be in RFC 3339 format
                                        This value is ignored if period is &#34;all&#34;
            user_id (str, optional): ID of the user whose results are returned
                                     As long as count is greater than 1, the returned data includes additional users, with Bits amounts above and below the user specified

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/bits/leaderboard&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if count != 10:
            params[&#34;count&#34;] = count

        if period != &#34;all&#34;:
            params[&#34;period&#34;] = period

        if started_at != &#34;&#34;:
            params[&#34;started_at&#34;] = started_at

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_cheermotes(self, broadcaster_id=&#34;&#34;):
        &#34;&#34;&#34;
        Retrieves the list of available Cheermotes
        Cheermotes returned are available throughout Twitch, in all Bits-enabled channels

        Args:
            broadcaster_id (str, optional): ID for the broadcaster who might own specialized Cheermotes

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/bits/cheermotes&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if broadcaster_id != &#34;&#34;:
            params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_extension_transactions(self, extension_id, id=[], first=20):
        &#34;&#34;&#34;
        Allows extension back-end servers to fetch a list of transactions that have occurred for their extension across all of Twitch
        A transaction is a record of a user exchanging Bits for an in-Extension digital good

        Args:
            extension_id (str): ID of the extension to list transactions for
            id (list, optional): Transaction IDs to look up
                                 Maximum: 100
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/transactions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;extension_id&#34;: extension_id}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if first != 20:
            params[&#34;first&#34;] = first

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        extension_transactions = []

        for call in range(calls):
            if first - (100 * call) &gt; 100:
                params[&#34;first&#34;] = 100

            else:
                params[&#34;first&#34;] = first - (100 * call)

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                extension_transactions.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return extension_transactions

    def get_channel(self, broadcaster_id: str | list[str]) -&gt; Channel:
        &#34;&#34;&#34;
        Gets one or more channels

        Args:
            broadcaster_id (str | list[str]): The ID of the broadcaster whose channel you want to get
                Maximum: 100

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Channel
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token if self.__user_token != &#39;&#39; else self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            channel = response.json()[&#34;data&#34;][0]
            channel = Channel(
                channel[&#34;broadcaster_id&#34;],
                channel[&#34;broadcaster_login&#34;],
                channel[&#34;broadcaster_name&#34;],
                channel[&#34;broadcaster_language&#34;],
                channel[&#34;game_name&#34;],
                channel[&#34;game_id&#34;],
                channel[&#34;title&#34;],
                channel[&#34;delay&#34;],
                channel[&#34;tags&#34;],
                channel[&#34;content_classification_labels&#34;],
                channel[&#34;is_branded_content&#34;],
            )

            return channel

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def modify_channel_information(
        self,
        broadcaster_id: str,
        game_id: str = None,
        broadcaster_language: str = None,
        title: str = None,
        delay: int = None,
        tags: list[str] = [],
        content_classification_labels: list[dict] = [],
        is_branded_content: bool = None,
    ):
        &#34;&#34;&#34;
        Updates a channel’s properties

        Args:
            broadcaster_id (str): The ID of the broadcaster whose channel you want to update
                ID must match the user ID in the user access token
            game_id (str): The ID of the game that the user plays
            broadcaster_language (str): The user’s preferred language
                Set the value to an ISO 639-1 two-letter language code
                Set to “other” if the user’s preferred language is not a Twitch supported language
            title (str): The title of the user’s stream
            delay (int): The number of seconds you want your broadcast buffered before streaming it live
                Only users with Partner status may set this field
                Maximum: 900 seconds
            tags (list[str]): A list of channel-defined tags to apply to the channel
                Maximum: 10
            content_classification_labels (list[dict]): List of labels that should be set as the Channel’s CCLs
            is_branded_content (bool): Boolean flag indicating if the channel has branded content
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id}

        if game_id is not None:
            data[&#34;game_id&#34;] = game_id

        if broadcaster_language is not None:
            data[&#34;broadcaster_language&#34;] = broadcaster_language

        if title is not None:
            data[&#34;title&#34;] = title

        if delay is not None:
            data[&#34;delay&#34;] = delay

        if len(tags) &gt; 0:
            data[&#34;tags&#34;] = tags

        if len(content_classification_labels) &gt; 0:
            data[&#34;content_classification_labels&#34;] = content_classification_labels

        if is_branded_content is not None:
            data[&#34;is_branded_content&#34;] = is_branded_content

        requests.patch(url, headers=headers, data=data)

    def get_channel_editors(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets a list of users who have editor permissions for a specific channel

        Args:
            broadcaster_id (str): Broadcaster’s user ID associated with the channel

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels/editors&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            ids = []

            for user in response.json()[&#34;data&#34;]:
                ids.append(user[&#34;user_id&#34;])

            users = self.get_users(id=ids)

            return users

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_followed_channels(
        self, user_id: str, broadcaster_id: str = &#34;&#34;, first: int = 20
    ) -&gt; list[Channel]:
        &#34;&#34;&#34;
        Gets a list of broadcasters that the specified user follows

        Args:
            user_id (str): A user’s ID
                Returns the list of broadcasters that this user follows
                This ID must match the user ID in the user OAuth token
            broadcaster_id (str): A broadcaster’s ID
                Use this parameter to see whether the user follows this broadcaster
            first (int): The maximum number of items to return
                Default: 20
                Minimum: 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Channel]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels/followed&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;user_id&#34;: user_id}

        if broadcaster_id != &#34;&#34;:
            params[&#34;broadcaster_id&#34;] = broadcaster_id

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        channels = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                channels.append(
                    self.get_channel(
                        [channel[&#34;broadcaster_id&#34;] for channel in response[&#34;data&#34;]]
                    )
                )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return channels

    def get_channel_followers(
        self, broadcaster_id: str, user_id: str = &#34;&#34;, first: int = 20
    ) -&gt; list[Channel]:
        &#34;&#34;&#34;
        The function `get_channel_followers` retrieves a list of channels that are following a specific
        broadcaster on Twitch.

        Args:
            broadcaster_id (str): The broadcaster’s ID
                Returns the list of users that follow this broadcaster
            user_id (str): A user’s ID
                Use this parameter to see whether the user follows this broadcaster
            first (int): The maximum number of items to return
                Default: 20
                Minimum: 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Channel]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels/followers&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        channels = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                channels.append(
                    self.get_channel(
                        [channel[&#34;user_id&#34;] for channel in response[&#34;data&#34;]]
                    )
                )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return channels

    def create_custom_reward(
        self,
        broadcaster_id,
        title,
        cost,
        prompt=&#34;&#34;,
        is_enabled=True,
        background_color=&#34;&#34;,
        is_user_input_required=False,
        is_max_per_stream_enabled=False,
        max_per_stream=None,
        is_max_per_user_per_stream_enabled=False,
        max_per_user_per_stream=None,
        is_global_cooldown_enabled=False,
        global_cooldown_seconds=None,
        should_redemptions_skip_request_queue=False,
    ):
        &#34;&#34;&#34;
        Creates a Custom Reward on a channel

        Args:
            broadcaster_id (str): ID of the channel creating a reward
            title (str): The title of the reward
            cost (int): The cost of the reward
            prompt (str, optional): The prompt for the viewer when they are redeeming the reward
            is_enabled (bool, optional): Is the reward currently enabled, if false the reward won’t show up to viewers
                                         Default: true
            background_color (str, optional): Custom background color for the reward
                                              Format: Hex with # prefix
            is_user_input_required (bool, optional): Does the user need to enter information when redeeming the reward
                                                     Default: false
            is_max_per_stream_enabled (bool, optional): Whether a maximum per stream is enabled
                                                        Default: false
            max_per_stream (int, optional): The maximum number per stream if enabled
                                            Required when any value of is_max_per_stream_enabled is included
            is_max_per_user_per_stream_enabled (bool, optional): Whether a maximum per user per stream is enabled
                                                                 Default: false
            max_per_user_per_stream (int, optional): The maximum number per user per stream if enabled
                                                     Required when any value of is_max_per_user_per_stream_enabled is included
            is_global_cooldown_enabled (bool, optional): Whether a cooldown is enabled
                                                         Default: false
            global_cooldown_seconds (int, optional): The cooldown in seconds if enabled
                                                     Required when any value of is_global_cooldown_enabled is included
            should_redemptions_skip_request_queue (bool, optional): Should redemptions be set to FULFILLED status immediately when redeemed and skip the request queue instead of the normal UNFULFILLED status
                                                                    Default: false

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Reward
        &#34;&#34;&#34;

        url = ENDPOINT_CUSTOM_REWARDS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;title&#34;: title, &#34;cost&#34;: cost}

        if prompt != &#34;&#34;:
            params[&#34;prompt&#34;] = prompt

        if is_enabled is not True:
            params[&#34;is_enabled&#34;] = is_enabled

        if background_color != &#34;&#34;:
            params[&#34;background_color&#34;] = background_color

        if is_user_input_required is not False:
            params[&#34;is_user_input_required&#34;] = is_user_input_required

        if is_max_per_stream_enabled is not False:
            params[&#34;is_max_per_stream_enabled&#34;] = is_max_per_stream_enabled

        if max_per_stream is not None:
            params[&#34;max_per_stream&#34;] = max_per_stream

        if is_max_per_user_per_stream_enabled is not False:
            params[
                &#34;is_max_per_user_per_stream_enabled&#34;
            ] = is_max_per_user_per_stream_enabled

        if max_per_user_per_stream is not None:
            params[&#34;max_per_user_per_stream&#34;] = max_per_user_per_stream

        if is_global_cooldown_enabled is not False:
            params[&#34;is_global_cooldown_enabled&#34;] = is_global_cooldown_enabled

        if global_cooldown_seconds is not None:
            params[&#34;global_cooldown_seconds&#34;] = global_cooldown_seconds

        if should_redemptions_skip_request_queue is not False:
            params[
                &#34;should_redemptions_skip_request_queue&#34;
            ] = should_redemptions_skip_request_queue

        response = requests.post(url, headers=headers, params=params)

        if response.ok:
            reward = response.json()[&#34;data&#34;][0]
            reward = Reward(
                reward[&#34;broadcaster_name&#34;],
                reward[&#34;broadcaster_id&#34;],
                reward[&#34;id&#34;],
                image=reward[&#34;image&#34;],
                background_color=reward[&#34;background_color&#34;],
                is_enabled=reward[&#34;is_enabled&#34;],
                cost=reward[&#34;cost&#34;],
                title=reward[&#34;title&#34;],
                prompt=reward[&#34;prompt&#34;],
                is_user_input_required=reward[&#34;is_user_input_required&#34;],
                max_per_stream_setting=reward[&#34;max_per_stream_setting&#34;],
                max_per_user_per_stream_setting=reward[
                    &#34;max_per_user_per_stream_setting&#34;
                ],
                global_cooldown_setting=reward[&#34;global_cooldown_setting&#34;],
                is_paused=reward[&#34;is_paused&#34;],
                is_in_stock=reward[&#34;is_in_stock&#34;],
                default_image=reward[&#34;default_image&#34;],
                should_redemptions_skip_request_queue=reward[
                    &#34;should_redemptions_skip_request_queue&#34;
                ],
                redemptions_redeemed_current_stream=reward[
                    &#34;redemptions_redeemed_current_stream&#34;
                ],
                cooldown_expires_at=reward[&#34;cooldown_expires_at&#34;],
            )

            return reward

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def delete_custom_reward(self, broadcaster_id, id):
        &#34;&#34;&#34;
        Deletes a Custom Reward on a channel
        The Custom Reward specified by id must have been created by the client_id attached to the OAuth token in order to be deleted
        Any UNFULFILLED Custom Reward Redemptions of the deleted Custom Reward will be updated to the FULFILLED status

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
            id (str): ID of the Custom Reward to delete
                      Must match a Custom Reward on broadcaster_id’s channel
        &#34;&#34;&#34;

        url = ENDPOINT_CUSTOM_REWARDS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id}

        requests.delete(url, headers=headers, data=data)

    def get_custom_reward(self, broadcaster_id, id=[], only_manageable_rewards=False):
        &#34;&#34;&#34;
        Returns a list of Custom Reward objects for the Custom Rewards on a channel

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
            id (list, optional): This parameter filters the results and only returns reward objects for the Custom Rewards with matching ID
                                Maximum: 50
            only_manageable_rewards (bool, optional): When set to true, only returns custom rewards that the calling broadcaster can manage
                                                      Default: false

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channel_points/custom_rewards&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if only_manageable_rewards is not False:
            params[&#34;only_manageable_rewards&#34;] = only_manageable_rewards

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            rewards = []

            for reward in response.json()[&#34;data&#34;]:
                rewards.append(
                    Reward(
                        reward[&#34;broadcaster_name&#34;],
                        reward[&#34;broadcaster_id&#34;],
                        reward[&#34;id&#34;],
                        image=reward[&#34;image&#34;],
                        background_color=reward[&#34;background_color&#34;],
                        is_enabled=reward[&#34;is_enabled&#34;],
                        cost=reward[&#34;cost&#34;],
                        title=reward[&#34;title&#34;],
                        prompt=reward[&#34;prompt&#34;],
                        is_user_input_required=reward[&#34;is_user_input_required&#34;],
                        max_per_stream_setting=reward[&#34;max_per_stream_setting&#34;],
                        max_per_user_per_stream_setting=reward[
                            &#34;max_per_user_per_stream_setting&#34;
                        ],
                        global_cooldown_setting=reward[&#34;global_cooldown_setting&#34;],
                        is_paused=reward[&#34;is_paused&#34;],
                        is_in_stock=reward[&#34;is_in_stock&#34;],
                        default_image=reward[&#34;default_image&#34;],
                        should_redemptions_skip_request_queue=reward[
                            &#34;should_redemptions_skip_request_queue&#34;
                        ],
                        redemptions_redeemed_current_stream=reward[
                            &#34;redemptions_redeemed_current_stream&#34;
                        ],
                        cooldown_expires_at=reward[&#34;cooldown_expires_at&#34;],
                    )
                )

            return rewards

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_custom_reward_redemption(
        self, broadcaster_id, reward_id, id=[], status=&#34;&#34;, sort=&#34;OLDEST&#34;, first=20
    ):
        &#34;&#34;&#34;
        Returns Custom Reward Redemption objects for a Custom Reward on a channel that was created by the same client_id
        Developers only have access to get and update redemptions for the rewards created programmatically by the same client_id

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
            reward_id (str): When ID is not provided, this parameter returns Custom Reward Redemption objects for redemptions of the Custom Reward with ID reward_id
            id (list, optional): When id is not provided, this param filters the results and only returns Custom Reward Redemption objects for the redemptions with matching ID
                                Maximum: 50
            status (str, optional): This param filters the Custom Reward Redemption objects for redemptions with the matching status
                                    Can be one of UNFULFILLED, FULFILLED or CANCELED
            sort (str, optional): Sort order of redemptions returned when getting the Custom Reward Redemption objects for a reward
                                  One of: OLDEST, NEWEST
                                  Default: OLDEST
            first (int, optional): Number of results to be returned when getting the Custom Reward Redemption objects for a reward
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channel_points/custom_rewards/redemptions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;reward_id&#34;: reward_id}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if status != &#34;&#34;:
            params[&#34;status&#34;] = status

        if sort != &#34;OLDEST&#34;:
            params[&#34;sort&#34;] = sort

        after = &#34;&#34;
        calls = math.ceil(first / 50)
        redemptions = []

        for call in range(calls):
            params[&#34;first&#34;] = min(50, first - (50 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                for redemption in response.json()[&#34;data&#34;]:
                    reward = Reward(
                        redemption[&#34;broadcaster_name&#34;],
                        redemption[&#34;broadcaster_id&#34;],
                        redemption[&#34;reward&#34;][&#34;id&#34;],
                        cost=redemption[&#34;reward&#34;][&#34;cost&#34;],
                        title=redemption[&#34;reward&#34;][&#34;title&#34;],
                        prompt=redemption[&#34;reward&#34;][&#34;prompt&#34;],
                    )
                    redemptions.append(
                        Redemption(
                            redemption[&#34;broadcaster_name&#34;],
                            redemption[&#34;broadcaster_id&#34;],
                            redemption[&#34;id&#34;],
                            redemption[&#34;user_id&#34;],
                            redemption[&#34;user_name&#34;],
                            redemption[&#34;user_input&#34;],
                            redemption[&#34;status&#34;],
                            redemption[&#34;redeemed_at&#34;],
                            reward,
                        )
                    )

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return redemptions

    def update_custom_reward(
        self,
        broadcaster_id,
        id,
        title=&#34;&#34;,
        prompt=&#34;&#34;,
        cost=None,
        background_color=&#34;&#34;,
        is_enabled=None,
        is_user_input_required=None,
        is_max_per_stream_enabled=None,
        max_per_stream=None,
        is_max_per_user_per_stream_enabled=None,
        max_per_user_per_stream=None,
        is_global_cooldown_enabled=None,
        global_cooldown_seconds=None,
        is_paused=None,
        should_redemptions_skip_request_queue=None,
    ):
        &#34;&#34;&#34;
        Updates a Custom Reward created on a channel
        The Custom Reward specified by id must have been created by the client_id attached to the user OAuth token

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
            id (str): ID of the Custom Reward to update
                      Must match a Custom Reward on the channel of the broadcaster_id
            title (str, optional): The title of the reward
            prompt (str, optional): The prompt for the viewer when they are redeeming the reward
            cost (int, optional): The cost of the reward
            background_color (str, optional): Custom background color for the reward as a hexadecimal value
            is_enabled (bool, optional): Is the reward currently enabled, if false the reward won’t show up to viewers
            is_user_input_required (bool, optional): Does the user need to enter information when redeeming the reward
            is_max_per_stream_enabled (bool, optional): Whether a maximum per stream is enabled
                                                        Required when any value of max_per_stream is included
            max_per_stream (int, optional): The maximum number per stream if enabled
                                            Required when any value of is_max_per_stream_enabled is included
            is_max_per_user_per_stream_enabled (bool, optional): Whether a maximum per user per stream is enabled
                                                                 Required when any value of max_per_user_per_stream is included
            max_per_user_per_stream (int, optional): The maximum number per user per stream if enabled
                                                     Required when any value of is_max_per_user_per_stream_enabled is included
            is_global_cooldown_enabled (bool, optional): Whether a cooldown is enabled
                                                         Required when any value of global_cooldown_seconds is included
            global_cooldown_seconds (int, optional): The cooldown in seconds if enabled
                                                     Required when any value of is_global_cooldown_enabled is included
            is_paused (bool, optional): Is the reward currently paused, if true viewers cannot redeem
            should_redemptions_skip_request_queue (bool, optional): Should redemptions be set to FULFILLED status immediately when redeemed and skip the request queue instead of the normal UNFULFILLED status

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Reward
        &#34;&#34;&#34;

        url = ENDPOINT_CUSTOM_REWARDS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id}

        if title != &#34;&#34;:
            data[&#34;title&#34;] = title

        if prompt != &#34;&#34;:
            data[&#34;prompt&#34;] = prompt

        if cost is not None:
            data[&#34;cost&#34;] = cost

        if background_color != &#34;&#34;:
            data[&#34;background_color&#34;] = background_color

        if is_enabled is not None:
            data[&#34;is_enabled&#34;] = is_enabled

        if is_user_input_required is not None:
            data[&#34;is_user_input_required&#34;] = is_user_input_required

        if is_max_per_stream_enabled is not None:
            data[&#34;is_max_per_stream_enabled&#34;] = is_max_per_stream_enabled

        if max_per_stream is not None:
            data[&#34;max_per_stream&#34;] = max_per_stream

        if is_max_per_user_per_stream_enabled is not None:
            data[
                &#34;is_max_per_user_per_stream_enabled&#34;
            ] = is_max_per_user_per_stream_enabled

        if max_per_user_per_stream is not None:
            data[&#34;max_per_user_per_stream&#34;] = max_per_user_per_stream

        if is_global_cooldown_enabled is not None:
            data[&#34;is_global_cooldown_enabled&#34;] = is_global_cooldown_enabled

        if global_cooldown_seconds is not None:
            data[&#34;global_cooldown_seconds&#34;] = global_cooldown_seconds

        if is_paused is not None:
            data[&#34;is_paused&#34;] = is_paused

        if should_redemptions_skip_request_queue is not None:
            data[
                &#34;should_redemptions_skip_request_queue&#34;
            ] = should_redemptions_skip_request_queue

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            reward = response.json()[&#34;data&#34;]
            reward = Reward(
                reward[&#34;broadcaster_name&#34;],
                reward[&#34;broadcaster_id&#34;],
                reward[&#34;id&#34;],
                image=reward[&#34;image&#34;],
                background_color=reward[&#34;background_color&#34;],
                is_enabled=reward[&#34;is_enabled&#34;],
                cost=reward[&#34;cost&#34;],
                title=reward[&#34;title&#34;],
                prompt=reward[&#34;prompt&#34;],
                is_user_input_required=reward[&#34;is_user_input_required&#34;],
                max_per_stream_setting=reward[&#34;max_per_stream_setting&#34;],
                max_per_user_per_stream_setting=reward[
                    &#34;max_per_user_per_stream_setting&#34;
                ],
                global_cooldown_setting=reward[&#34;global_cooldown_setting&#34;],
                is_paused=reward[&#34;is_paused&#34;],
                is_in_stock=reward[&#34;is_in_stock&#34;],
                default_image=reward[&#34;default_image&#34;],
                should_redemptions_skip_request_queue=reward[
                    &#34;should_redemptions_skip_request_queue&#34;
                ],
                redemptions_redeemed_current_stream=reward[
                    &#34;redemptions_redeemed_current_stream&#34;
                ],
                cooldown_expires_at=reward[&#34;cooldown_expires_at&#34;],
            )

            return reward

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_redemption_status(self, id, broadcaster_id, reward_id, status=&#34;&#34;):
        &#34;&#34;&#34;
        Updates the status of Custom Reward Redemption objects on a channel that are in the UNFULFILLED status
        The Custom Reward Redemption specified by id must be for a Custom Reward created by the client_id attached to the user OAuth token

        Args:
            id (list): ID of the Custom Reward Redemption to update
                      Must match a Custom Reward Redemption on broadcaster_id’s channel
                      Maximum: 50
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
            reward_id (str): ID of the Custom Reward the redemptions to be updated are for
            status (str, optional): The new status to set redemptions to
                                    Can be either FULFILLED or CANCELED
                                    Updating to CANCELED will refund the user their Channel Points

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Redemption
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channel_points/custom_rewards/redemptions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;id&#34;: id, &#34;broadcaster_id&#34;: broadcaster_id, &#34;reward_id&#34;: reward_id}

        if status != &#34;&#34;:
            data[&#34;status&#34;] = status

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            redemption = response.json()[&#34;data&#34;][0]
            reward = Reward(
                redemption[&#34;broadcaster_name&#34;],
                redemption[&#34;broadcaster_id&#34;],
                redemption[&#34;reward&#34;][&#34;id&#34;],
                cost=redemption[&#34;reward&#34;][&#34;cost&#34;],
                title=redemption[&#34;reward&#34;][&#34;title&#34;],
                prompt=redemption[&#34;reward&#34;][&#34;prompt&#34;],
            )
            redemption = Redemption(
                redemption[&#34;broadcaster_name&#34;],
                redemption[&#34;broadcaster_id&#34;],
                redemption[&#34;id&#34;],
                redemption[&#34;user_id&#34;],
                redemption[&#34;user_name&#34;],
                redemption[&#34;user_input&#34;],
                redemption[&#34;status&#34;],
                redemption[&#34;redeemed_at&#34;],
                reward,
            )

            return redemption

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_charity_campaign(self, broadcaster_id: str) -&gt; CharityCampaign:
        &#34;&#34;&#34;
        Gets information about the charity campaign that a broadcaster is running

        Args:
            broadcaster_id (str): The ID of the broadcaster that’s currently running a charity campaign
                This ID must match the user ID in the access token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            CharityCampaign
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/charity/campaigns&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return CharityCampaign(
                response.json()[&#34;data&#34;][0][&#34;id&#34;],
                response.json()[&#34;data&#34;][0][&#34;broadcaster_id&#34;],
                response.json()[&#34;data&#34;][0][&#34;broadcaster_name&#34;],
                response.json()[&#34;data&#34;][0][&#34;broadcaster_login&#34;],
                response.json()[&#34;data&#34;][0][&#34;charity_name&#34;],
                response.json()[&#34;data&#34;][0][&#34;charity_description&#34;],
                response.json()[&#34;data&#34;][0][&#34;charity_logo&#34;],
                response.json()[&#34;data&#34;][0][&#34;charity_website&#34;],
                response.json()[&#34;data&#34;][0][&#34;current_amount&#34;],
                response.json()[&#34;data&#34;][0][&#34;target_amount&#34;],
            )

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_charity_campaign_donations(
        self, broadcaster_id: str, first: int = 20
    ) -&gt; list[CharityCampaignDonation]:
        &#34;&#34;&#34;
        Gets the list of donations that users have made to the broadcaster’s active charity campaign

        Args:
            broadcaster_id (str): The ID of the broadcaster that’s currently running a charity campaign
                This ID must match the user ID in the access token
            first (int): The maximum number of items to return
                Default: 20
                Minimum: 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[CharityCampaignDonation]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/charity/donations&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        after = &#34;&#34;
        calls = math.ceil(first / 20)
        donations = []

        for call in range(calls):
            params[&#34;first&#34;] = min(20, first - (20 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for donation in response[&#34;data&#34;]:
                    donations.append(
                        CharityCampaignDonation(
                            donation[&#34;id&#34;],
                            donation[&#34;campaign_id&#34;],
                            donation[&#34;user_id&#34;],
                            donation[&#34;user_login&#34;],
                            donation[&#34;user_name&#34;],
                            donation[&#34;amount&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return donations

    def get_chatters(
        self, broadcaster_id: str, moderator_id: str, first: int = 100
    ) -&gt; list[User]:
        &#34;&#34;&#34;
        Gets the list of users that are connected to the broadcaster’s chat session

        Args:
            broadcaster_id (str): The ID of the broadcaster whose list of chatters you want to get
            moderator_id (str): The ID of the broadcaster or one of the broadcaster’s moderators
                This ID must match the user ID in the user access token
            first (int): The maximum number of items to return
                Default: 100
                Minimum: 1
                Maximum: 1000

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[User]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/chatters&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        users = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                users.extend(
                    self.get_users([user[&#34;user_id&#34;] for user in response[&#34;data&#34;]])
                )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return users

    def get_channel_emotes(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets all custom emotes for a specific Twitch channel including subscriber emotes, Bits tier emotes, and follower emotes
        Custom channel emotes are custom emoticons that viewers may use in Twitch chat once they are subscribed to, cheered in, or followed the channel that owns the emotes

        Args:
            broadcaster_id (str): The broadcaster whose emotes are being requested

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/emotes&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            emotes = []

            for emote in response.json()[&#34;data&#34;]:
                emotes.append(
                    Emote(
                        emote[&#34;id&#34;],
                        emote[&#34;name&#34;],
                        emote[&#34;images&#34;],
                        emote[&#34;format&#34;],
                        emote[&#34;scale&#34;],
                        emote[&#34;theme_mode&#34;],
                        emote[&#34;tier&#34;],
                        emote[&#34;emote_type&#34;],
                        emote[&#34;emote_set_id&#34;],
                    )
                )

            return emotes

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_global_emotes(self):
        &#34;&#34;&#34;
        Gets all global emotes
        Global emotes are Twitch-specific emoticons that every user can use in Twitch chat

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/emotes/global&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }

        response = requests.get(url, headers=headers)

        if response.ok:
            emotes = []

            for emote in response.json()[&#34;data&#34;]:
                emotes.append(
                    Emote(
                        emote[&#34;id&#34;],
                        emote[&#34;name&#34;],
                        emote[&#34;images&#34;],
                        emote[&#34;format&#34;],
                        emote[&#34;scale&#34;],
                        emote[&#34;theme_mode&#34;],
                    )
                )

            return emotes

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_emote_sets(self, emote_set_id):
        &#34;&#34;&#34;
        Gets all Twitch emotes for one or more specific emote sets

        Args:
            emote_set_id (list): ID(s) of the emote set
                                 Maximum: 25

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/emotes/set&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;emote_set_id&#34;: emote_set_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            emotes = []

            for emote in response.json()[&#34;data&#34;]:
                emotes.append(
                    Emote(
                        emote[&#34;id&#34;],
                        emote[&#34;name&#34;],
                        emote[&#34;images&#34;],
                        emote[&#34;format&#34;],
                        emote[&#34;scale&#34;],
                        emote[&#34;theme_mode&#34;],
                        emote_type=emote[&#34;emote_type&#34;],
                        emote_set_id=emote[&#34;emote_set_id&#34;],
                    )
                )

            return emotes

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_channel_chat_badges(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets a list of custom chat badges that can be used in chat for the specified channel
        This includes subscriber badges and Bit badges

        Args:
            broadcaster_id (str): The broadcaster whose chat badges are being requested
                                  Provided broadcaster_id must match the user_id in the user OAuth token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/badges&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            badges = []

            for badge in response.json()[&#34;data&#34;]:
                badges.append(Badge(badge[&#34;set_id&#34;], badge[&#34;versions&#34;]))

            return badges

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_global_chat_badges(self):
        &#34;&#34;&#34;
        Gets a list of chat badges that can be used in chat for any channel

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/badges/global&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }

        response = requests.get(url, headers=headers)

        if response.ok:
            badges = []

            for badge in response.json()[&#34;data&#34;]:
                badges.append(Badge(badge[&#34;set_id&#34;], badge[&#34;versions&#34;]))

            return badges

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_chat_settings(self, broadcaster_id, moderator_id=&#34;&#34;):
        &#34;&#34;&#34;
        Gets the broadcaster’s chat settings

        Args:
            broadcaster_id (str): The ID of the broadcaster whose chat settings you want to get
            moderator_id (str, optional): Required only to access the non_moderator_chat_delay or non_moderator_chat_delay_duration settings
                                          The ID of a user that has permission to moderate the broadcaster’s chat room
                                          This ID must match the user ID associated with the user OAuth token
                                          If the broadcaster wants to get their own settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_chat_settings(
        self,
        broadcaster_id,
        moderator_id,
        emote_mode=None,
        follower_mode=None,
        follower_mode_duration=0,
        non_moderator_chat_delay=None,
        non_moderator_chat_delay_duration=0,
        slow_mode=None,
        slow_mode_wait_time=30,
        subscriber_mode=None,
        unique_chat_mode=None,
    ):
        &#34;&#34;&#34;
        Updates the broadcaster’s chat settings

        Args:
            broadcaster_id (str): The ID of the broadcaster whose chat settings you want to update
                                  This ID must match the user ID associated with the user OAuth token
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to update their own settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
            emote_mode (bool, optional): A Boolean value that determines whether chat messages must contain only emotes
                                         Set to true, if only messages that are 100% emotes are allowed; otherwise, false
                                         Default is false
            follower_mode (bool, optional): A Boolean value that determines whether the broadcaster restricts the chat room to followers only, based on how long they’ve followed
                                            Set to true, if the broadcaster restricts the chat room to followers only; otherwise, false
                                            Default is false
            follower_mode_duration (int, optional): The length of time, in minutes, that the followers must have followed the broadcaster to participate in the chat room
                                                    You may specify a value in the range: 0 (no restriction) through 129600 (3 months)
                                                    The default is 0
            non_moderator_chat_delay (bool, optional): A Boolean value that determines whether the broadcaster adds a short delay before chat messages appear in the chat room
                                                       This gives chat moderators and bots a chance to remove them before viewers can see the message
                                                       Set to true, if the broadcaster applies a delay; otherwise, false
                                                       Default is false
            non_moderator_chat_delay_duration (int, optional): The amount of time, in seconds, that messages are delayed from appearing in chat
                                                               Possible values are: 2, 4, 6
            slow_mode (bool, optional): A Boolean value that determines whether the broadcaster limits how often users in the chat room are allowed to send messages
                                        Set to true, if the broadcaster applies a wait period messages; otherwise, false
                                        Default is false
            slow_mode_wait_time (int, optional): The amount of time, in seconds, that users need to wait between sending messages
                                                 You may specify a value in the range: 3 (3 second delay) through 120 (2 minute delay)
                                                 The default is 30 seconds
            subscriber_mode (bool, optional): A Boolean value that determines whether only users that subscribe to the broadcaster’s channel can talk in the chat room
                                              Set to true, if the broadcaster restricts the chat room to subscribers only; otherwise, false
                                              Default is false
            unique_chat_mode (bool, optional): A Boolean value that determines whether the broadcaster requires users to post only unique messages in the chat room
                                               Set to true, if the broadcaster requires unique messages only; otherwise, false
                                               Default is false

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        if emote_mode is not None:
            data[&#34;emote_mode&#34;] = emote_mode

        if follower_mode is not None:
            data[&#34;follower_mode&#34;] = follower_mode

        if follower_mode_duration != 0:
            data[&#34;follower_mode_duration&#34;] = follower_mode_duration

        if non_moderator_chat_delay is not None:
            data[&#34;non_moderator_chat_delay&#34;] = non_moderator_chat_delay

        if non_moderator_chat_delay_duration != 0:
            data[
                &#34;non_moderator_chat_delay_duration&#34;
            ] = non_moderator_chat_delay_duration

        if slow_mode is not None:
            data[&#34;slow_mode&#34;] = slow_mode

        if slow_mode_wait_time != 30:
            data[&#34;slow_mode_wait_time&#34;] = slow_mode_wait_time

        if subscriber_mode is not None:
            data[&#34;subscriber_mode&#34;] = subscriber_mode

        if unique_chat_mode is not None:
            data[&#34;unique_chat_mode&#34;] = unique_chat_mode

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def send_chat_announcement(
        self, broadcaster_id: str, moderator_id: str, message: str, color: str = &#34;&#34;
    ) -&gt; None:
        &#34;&#34;&#34;
        Sends an announcement to the broadcaster’s chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster that owns the chat room to send the announcement to
            moderator_id (str): The ID of a user who has permission to moderate the broadcaster’s chat room, or the broadcaster’s ID if they’re sending the announcement
                This ID must match the user ID in the user access token
            message (str): The announcement to make in the broadcaster’s chat
                Announcements are limited to a maximum of 500 characters
            color (str): Announcements are limited to a maximum of 500 characters
                Possible case-sensitive values are: blue, green, orange, purple, primary (default)
                If color is set to primary or is not set, the channel’s accent color is used to highlight the announcement
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/announcements&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;message&#34;: message,
        }

        if color != &#34;&#34;:
            payload[&#34;color&#34;] = color

        requests.post(url, headers=headers, json=payload)

    def send_a_shoutout(
        self, from_broadcaster_id: str, to_broadcaster_id: str, moderator_id: str
    ) -&gt; None:
        &#34;&#34;&#34;
        Sends a Shoutout to the specified broadcaster

        Args:
            from_broadcaster_id (str): The ID of the broadcaster that’s sending the Shoutout
            to_broadcaster_id (str): The ID of the broadcaster that’s receiving the Shoutout
            moderator_id (str): The ID of the broadcaster or a user that is one of the broadcaster’s moderators
                This ID must match the user ID in the access token
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/shoutouts&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;from_broadcaster_id&#34;: from_broadcaster_id,
            &#34;to_broadcaster_id&#34;: to_broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
        }

        requests.post(url, headers=headers, json=payload)

    def get_user_chat_color(self, user_id: str | list[str]) -&gt; list[dict]:
        &#34;&#34;&#34;
        Gets the color used for the user’s name in chat

        Args:
            user_id (str | list[str]): The ID of the user whose username color you want to get
                Maximum: 100

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[dict]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/color&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;user_id&#34;: user_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_user_chat_color(self, user_id: str, color: str) -&gt; None:
        &#34;&#34;&#34;
        Updates the color used for the user’s name in chat

        Args:
            user_id (str): The ID of the user whose chat color you want to update
                This ID must match the user ID in the access token
            color (str): The color to use for the user’s name in chat
                All users may specify one of the following named color values: blue, blue_violet, cadet_blue, chocolate, coral, dodger_blue, firebrick, golden_rod, green, hot_pink, orange_red, red, sea_green, spring_green, yellow_green
                Turbo and Prime users may specify a named color or a Hex color code
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/color&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;user_id&#34;: user_id, &#34;color&#34;: color}

        requests.put(url, headers=headers, data=data)

    def create_clip(self, broadcaster_id, has_delay=False):
        &#34;&#34;&#34;
        This returns both an ID and an edit URL for a new clip

        Args:
            broadcaster_id (str): ID of the stream from which the clip will be made
            has_delay (bool, optional): If false, the clip is captured from the live stream when the API is called; otherwise, a delay is added before the clip is captured (to account for the brief delay between the broadcaster’s stream and the viewer’s experience of that stream)
                                        Default: false

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/clips&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;broadcaster_id&#34;: broadcaster_id}

        if has_delay is not False:
            payload[&#34;has_delay&#34;] = has_delay

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_clips(
        self,
        broadcaster_id: str = &#34;&#34;,
        game_id: str = &#34;&#34;,
        id: list[str] = [],
        started_at: str = &#34;&#34;,
        ended_at: str = &#34;&#34;,
        first: int = 20,
        is_featured: bool = False,
    ) -&gt; list[Clip]:
        &#34;&#34;&#34;
        Gets one or more video clips that were captured from streams
        The id, game_id, and broadcaster_id query parameters are mutually exclusive

        Args:
            broadcaster_id (str): An ID that identifies the broadcaster whose video clips you want to get
            game_id (str): An ID that identifies the game whose clips you want to get
            id (list[str]): An ID that identifies the clip to get
            started_at (str): The start date used to filter clips
            ended_at (str): The end date used to filter clips
            first (int): The maximum number of clips to return
                Minimum: 1
            is_featured (bool): A Boolean value that determines whether the response includes featured clips

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Clip]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/clips&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if broadcaster_id != &#34;&#34;:
            params[&#34;broadcaster_id&#34;] = broadcaster_id

        if game_id != &#34;&#34;:
            params[&#34;game_id&#34;] = game_id

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if started_at != &#34;&#34;:
            params[&#34;started_at&#34;] = started_at

        if ended_at != &#34;&#34;:
            params[&#34;ended_at&#34;] = ended_at

        if is_featured is not False:
            params[&#34;is_featured&#34;] = is_featured

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        clips = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for clip in response[&#34;data&#34;]:
                    clips.append(
                        Clip(
                            clip[&#34;id&#34;],
                            clip[&#34;url&#34;],
                            clip[&#34;embed_url&#34;],
                            clip[&#34;broadcaster_id&#34;],
                            clip[&#34;broadcaster_name&#34;],
                            clip[&#34;creator_id&#34;],
                            clip[&#34;creator_name&#34;],
                            clip[&#34;video_id&#34;],
                            clip[&#34;game_id&#34;],
                            clip[&#34;language&#34;],
                            clip[&#34;title&#34;],
                            clip[&#34;view_count&#34;],
                            clip[&#34;created_at&#34;],
                            clip[&#34;thumbnail_url&#34;],
                            clip[&#34;duration&#34;],
                            clip[&#34;vod_offset&#34;],
                            clip[&#34;is_featured&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return clips

    def get_conduits(self) -&gt; list[dict]:
        &#34;&#34;&#34;
        Gets the conduits for a client ID

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[dict]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/eventsub/conduits&#34;
        headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id}

        response = requests.get(url, headers=headers)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def create_conduits(self, shard_count: int) -&gt; dict:
        &#34;&#34;&#34;
        Creates a new conduit

        Args:
            shard_count (int): The number of shards to create for this conduit

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/eventsub/conduits&#34;
        headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id, &#34;Content-Type&#34;: &#34;application/json&#34;}
        payload = {&#34;shard_count&#34;, shard_count}

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_conduits(self, id: str, shard_count: int) -&gt; dict:
        &#34;&#34;&#34;
        Updates a conduit’s shard count
        To delete shards, update the count to a lower number, and the shards above the count will be deleted

        Args:
            id (str): Conduit ID
            shard_count (int): The new number of shards for this conduit

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/eventsub/conduits&#34;
        headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id, &#34;Content-Type&#34;: &#34;application/json&#34;}
        data = {&#34;id&#34;: id, &#34;shard_count&#34;: shard_count}

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def delete_conduit(self, id: str) -&gt; None:
        &#34;&#34;&#34;
        Deletes a specified conduit

        Args:
            id (str): Conduit ID

        Raises:
            twitchpy.errors.ClientError
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/eventsub/conduits&#34;
        headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id}
        data = {&#34;id&#34;: id}

        response = requests.delete(url, headers=headers, data=data)

        if not response.ok:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_conduit_shards(self, conduit_id: str, status: str = &#34;&#34;) -&gt; list[dict]:
        &#34;&#34;&#34;
        Gets a lists of all shards for a conduit

        Args:
            conduit_id (str): Conduit ID
            status (str): Status to filter by

        Raise:
            twitchpy.errors.ClientError

        Returns:
            list[dict]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/eventsub/conduits/shards&#34;
        headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id}
        params = {&#34;conduit_id&#34;: conduit_id}

        if status != &#34;&#34;:
            params[&#34;status&#34;] = status

        response = requests.get(url, headers=headers, params=params)

        conduit_shards = []

        while response.ok and &#34;pagination&#34; in response:
            conduit_shards.append(response.json()[&#34;data&#34;])
            params[&#34;after&#34;] = response.json()[&#34;pagination&#34;][&#34;cursor&#34;]

            response = requests.get(url, headers=headers, params=params)

        if not response.ok:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return conduit_shards

    def update_conduit_shards(self, conduit_id: str, shards: list[dict], session_id: str = &#34;&#34;) -&gt; dict:
        &#34;&#34;&#34;
        Updates shard(s) for a conduit

        Args:
            conduit_id (str): Conduit ID
            shards (list[dict]): List of shards to update
            session_id (str): An ID that identifies the WebSocket to send notifications to
                Specify this field only if method is set to websocket

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/eventsub/conduits/shards&#34;
        headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id, &#34;Content-Type&#34;: &#34;application/json&#34;}
        data = {&#34;conduit_id&#34;: conduit_id, &#34;shards&#34;: shards}

        if session_id != &#34;&#34;:
            data[&#34;session_id&#34;] = session_id

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_content_classification_labels(self, locale: str = &#34;en-US&#34;) -&gt; list[dict]:
        &#34;&#34;&#34;
        Gets information about Twitch content classification labels

        Args:
            locale (str): Locale for the Content Classification Labels
                Possible values: &#34;bg-BG&#34;, &#34;cs-CZ&#34;, &#34;da-DK&#34;, &#34;da-DK&#34;, &#34;de-DE&#34;, &#34;el-GR&#34;, &#34;en-GB&#34;, &#34;en-US&#34;, &#34;es-ES&#34;, &#34;es-MX&#34;, &#34;fi-FI&#34;, &#34;fr-FR&#34;, &#34;hu-HU&#34;, &#34;it-IT&#34;, &#34;ja-JP&#34;, &#34;ko-KR&#34;, &#34;nl-NL&#34;, &#34;no-NO&#34;, &#34;pl-PL&#34;, &#34;pt-BT&#34;, &#34;pt-PT&#34;, &#34;ro-RO&#34;, &#34;ru-RU&#34;, &#34;sk-SK&#34;, &#34;sv-SE&#34;, &#34;th-TH&#34;, &#34;tr-TR&#34;, &#34;vi-VN&#34;, &#34;zh-CN&#34;, &#34;zh-TW&#34;

        Raise:
            twitchpy.errors.ClientError

        Returns:
            list[dict]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/content_classification_labels&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if locale != &#34;en-US&#34;:
            params[&#34;locale&#34;] = locale

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_drops_entitlements(
        self, id=&#34;&#34;, user_id=&#34;&#34;, game_id=&#34;&#34;, fulfillment_status=&#34;&#34;, first=20
    ):
        &#34;&#34;&#34;
        Gets a list of entitlements for a given organization that have been granted to a game, user, or both

        Args:
            id (str, optional): ID of the entitlement
            user_id (str, optional): A Twitch User ID
            game_id (str, optional): A Twitch Game ID
            fulfillment_status (str, optional): An optional fulfillment status used to filter entitlements
                                                Valid values are &#34;CLAIMED&#34; or &#34;FULFILLED&#34;
            first (int, optional): Maximum number of entitlements to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/entitlements/drops&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if id != &#34;&#34;:
            params[&#34;id&#34;] = id

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        if game_id != &#34;&#34;:
            params[&#34;game_id&#34;] = game_id

        if fulfillment_status != &#34;&#34;:
            params[&#34;fulfillment_status&#34;] = fulfillment_status

        after = &#34;&#34;
        calls = math.ceil(first / 1000)
        drops_entitlements = []

        for call in range(calls):
            params[&#34;first&#34;] = min(1000, first - (1000 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                drops_entitlements.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return drops_entitlements

    def update_drops_entitlements(self, entitlement_ids=[], fulfillment_status=&#34;&#34;):
        &#34;&#34;&#34;
        Updates the fulfillment status on a set of Drops entitlements, specified by their entitlement IDs

        Args:
            entitlement_ids (list, optional): An array of unique identifiers of the entitlements to update
                                              Maximum: 100
            fulfillment_status (str, optional): A fulfillment status
                                                Valid values are &#34;CLAIMED&#34; or &#34;FULFILLED&#34;

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/entitlements/drops&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        data = {}

        if len(entitlement_ids) &gt; 0:
            data[&#34;entitlement_ids&#34;] = entitlement_ids

        if fulfillment_status != &#34;&#34;:
            data[&#34;fulfillment_status&#34;] = fulfillment_status

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_extension_configuration_segment(
        self, broadcaster_id, extension_id, segment
    ):
        &#34;&#34;&#34;
        Gets the specified configuration segment from the specified extension
        You can retrieve each segment a maximum of 20 times per minute

        Args:
            broadcaster_id (str): The ID of the broadcaster for the configuration returned
                                  This parameter is required if you set the segment parameter to &#34;broadcaster&#34; or &#34;developer&#34;
                                  Do not specify this parameter if you set segment to &#34;global&#34;
            extension_id (str): The ID of the extension that contains the configuration segment you want to get
            segment (list): The type of configuration segment to get
                           Valid values are: &#34;broadcaster&#34;, &#34;developer&#34;, &#34;global&#34;

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/configurations&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;extension_id&#34;: extension_id,
            &#34;segment&#34;: segment,
        }

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def set_extension_configuration_segment(
        self, extension_id, segment, broadcaster_id=&#34;&#34;, content=&#34;&#34;, version=&#34;&#34;
    ):
        &#34;&#34;&#34;
        Sets a single configuration segment of any type
        Each segment is limited to 5 KB and can be set at most 20 times per minute
        Updates to this data are not delivered to Extensions that have already been rendered

        Args:
            extension_id (str): ID for the Extension which the configuration is for
            segment (str): Configuration type
                           Valid values are &#34;global&#34;, &#34;developer&#34;, or &#34;broadcaster&#34;
            broadcaster_id (str, optional): User ID of the broadcaster
                                            Required if the segment type is &#34;developer&#34; or &#34;broadcaster&#34;
            content (str, optional): Configuration in a string-encoded format
            version (str, optional): Configuration version with the segment type
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/configurations&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;extension_id&#34;: extension_id, &#34;segment&#34;: segment}

        if broadcaster_id != &#34;&#34;:
            data[&#34;broadcaster_id&#34;] = broadcaster_id

        if content != &#34;&#34;:
            data[&#34;content&#34;] = content

        if version != &#34;&#34;:
            data[&#34;version&#34;] = version

        requests.put(url, headers=headers, data=data)

    def set_extension_required_configuration(
        self, broadcaster_id, extension_id, extension_version, configuration_version
    ):
        &#34;&#34;&#34;
        Enable activation of a specified Extension, after any required broadcaster configuration is correct

        Args:
            broadcaster_id (str): User ID of the broadcaster who has activated the specified Extension on their channel
            extension_id (str): ID for the Extension to activate
            extension_version (str): The version fo the Extension to release
            configuration_version (str): The version of the configuration to use with the Extension
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/required_configuration&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;extension_id&#34;: extension_id,
            &#34;extension_version&#34;: extension_version,
            &#34;configuration_version&#34;: configuration_version,
        }

        requests.put(url, headers=headers, data=data)

    def send_extension_pubsub_message(
        self, target, broadcaster_id, is_global_broadcast, message
    ):
        &#34;&#34;&#34;
        A message can be sent to either a specified channel or globally (all channels on which your extension is active)
        Extension PubSub has a rate limit of 100 requests per minute for a combination of Extension client ID and broadcaster ID

        Args:
            target (list): Array of strings for valid PubSub targets
                           Valid values: &#34;broadcast&#34;, &#34;global&#34;, &#34;whisper-&lt;user-id&gt;&#34;
            broadcaster_id (str): ID of the broadcaster receiving the payload
            is_global_broadcast (bool): Indicates if the message should be sent to all channels where your Extension is active
            message (str): String-encoded JSON message to be sent
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/pubsub&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;target&#34;: target,
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;is_global_broadcast&#34;: is_global_broadcast,
            &#34;message&#34;: message,
        }

        requests.post(url, headers=headers, data=data)

    def get_extension_live_channels(self, extension_id, first=20):
        &#34;&#34;&#34;
        Returns one page of live channels that have installed or activated a specific Extension, identified by a client ID value assigned to the Extension when it is created
        A channel that recently went live may take a few minutes to appear in this list, and a channel may continue to appear on this list for a few minutes after it stops broadcasting

        Args:
            extension_id (str): ID of the Extension to search for
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/live&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: {self.client_id},
        }
        params = {&#34;extension_id&#34;: extension_id}

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        channels = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for channel in response[&#34;data&#34;]:
                    channels.append(channel)

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return channels

    def get_extension_secrets(self):
        &#34;&#34;&#34;
        Retrieves a specified Extension’s secret data consisting of a version and an array of secret objects
        Each secret object contains a base64-encoded secret, a UTC timestamp when the secret becomes active, and a timestamp when the secret expires

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/jwt/secrets&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }

        response = requests.get(url, headers=headers)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def create_extension_secret(self, delay=300):
        &#34;&#34;&#34;
        Creates a JWT signing secret for a specific Extension
        Also rotates any current secrets out of service, with enough time for instances of the Extension to gracefully switch over to the new secret

        Args:
            delay (int, optional): JWT signing activation delay for the newly created secret in seconds
                                   Minimum: 300
                                   Default: 300

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/jwt/secrets&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {}

        if delay != 300:
            payload[&#34;delay&#34;] = delay

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def send_extension_chat_message(
        self, broadcaster_id, text, extension_id, extension_version
    ):
        &#34;&#34;&#34;
        Sends a specified chat message to a specified channel
        The message will appear in the channel’s chat as a normal message
        The &#34;username&#34; of the message is the Extension name
        There is a limit of 12 messages per minute, per channel

        Args:
            broadcaster_id (str): User ID of the broadcaster whose channel has the Extension activated
            text (str): Message for Twitch chat
                        Maximum: 280 characters
            extension_id (str): Client ID associated with the Extension
            extension_version (str): Version of the Extension sending this message
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/chat&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;text&#34;: text,
            &#34;extension_id&#34;: extension_id,
            &#34;extension_version&#34;: extension_version,
        }

        requests.post(url, headers=headers, json=payload)

    def get_extensions(self, extension_id, extension_version=&#34;&#34;):
        &#34;&#34;&#34;
        Gets information about your Extensions; either the current version or a specified version

        Args:
            extension_id (str): ID of the Extension
            extension_version (str, optional): The specific version of the Extension to return
                                               If not provided, the current version is returned

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;extension_id&#34;: extension_id}

        if extension_version != &#34;&#34;:
            params[&#34;extension_version&#34;] = extension_version

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            extensions = []

            for extension in response.json()[&#34;data&#34;]:
                extensions.append(
                    Extension(
                        extension[&#34;author_name&#34;],
                        extension[&#34;bits_enables&#34;],
                        extension[&#34;can_install&#34;],
                        extension[&#34;configuration_location&#34;],
                        extension[&#34;description&#34;],
                        extension[&#34;eula_tos_url&#34;],
                        extension[&#34;has_chat_support&#34;],
                        extension[&#34;icon_url&#34;],
                        extension[&#34;icon_urls&#34;],
                        extension[&#34;id&#34;],
                        extension[&#34;name&#34;],
                        extension[&#34;privacy_policy_url&#34;],
                        extension[&#34;request_identity_link&#34;],
                        extension[&#34;screenshot_urls&#34;],
                        extension[&#34;state&#34;],
                        extension[&#34;subscriptions_support_level&#34;],
                        extension[&#34;summary&#34;],
                        extension[&#34;support_email&#34;],
                        extension[&#34;version&#34;],
                        extension[&#34;viewer_summary&#34;],
                        extension[&#34;views&#34;],
                        extension[&#34;allowlisted_config_urls&#34;],
                        extension[&#34;allowlisted_panel_urls&#34;],
                    )
                )

            return extensions

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_released_extensions(self, extension_id, extension_version=&#34;&#34;):
        &#34;&#34;&#34;
        Gets information about a released Extension; either the current version or a specified version

        Args:
            extension_id (str): ID of the Extension
            extension_version (str, optional): The specific version of the Extension to return
                                               If not provided, the current version is returned

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/released&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;extension_id&#34;: extension_id}

        if extension_version != &#34;&#34;:
            params[&#34;extension_version&#34;] = extension_version

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            extensions = []

            for extension in response.json()[&#34;data&#34;]:
                extensions.append(
                    Extension(
                        extension[&#34;author_name&#34;],
                        extension[&#34;bits_enables&#34;],
                        extension[&#34;can_install&#34;],
                        extension[&#34;configuration_location&#34;],
                        extension[&#34;description&#34;],
                        extension[&#34;eula_tos_url&#34;],
                        extension[&#34;has_chat_support&#34;],
                        extension[&#34;icon_url&#34;],
                        extension[&#34;icon_urls&#34;],
                        extension[&#34;id&#34;],
                        extension[&#34;name&#34;],
                        extension[&#34;privacy_policy_url&#34;],
                        extension[&#34;request_identity_link&#34;],
                        extension[&#34;screenshot_urls&#34;],
                        extension[&#34;state&#34;],
                        extension[&#34;subscriptions_support_level&#34;],
                        extension[&#34;summary&#34;],
                        extension[&#34;support_email&#34;],
                        extension[&#34;version&#34;],
                        extension[&#34;viewer_summary&#34;],
                        extension[&#34;views&#34;],
                        extension[&#34;allowlisted_config_urls&#34;],
                        extension[&#34;allowlisted_panel_urls&#34;],
                    )
                )

            return extensions

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_extension_bits_products(
        self, extension_client_id, should_include_all=False
    ):
        &#34;&#34;&#34;
        Gets a list of Bits products that belongs to an Extension

        Args:
            extension_client_id (str): Extension client ID
            should_include_all (bool, optional): Whether Bits products that are disabled/expired should be included in the response
                                                 Default: false

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/bits/extensions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: extension_client_id,
        }
        params = {}

        if should_include_all is not False:
            params[&#34;should_include_all&#34;] = should_include_all

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_extension_bits_product(
        self,
        extension_client_id,
        sku,
        cost,
        display_name,
        in_development=False,
        expiration=&#34;&#34;,
        is_broadcast=False,
    ):
        &#34;&#34;&#34;
        Add or update a Bits products that belongs to an Extension

        Args:
            extension_client_id (str): Extension client ID
            sku (str): SKU of the Bits product
                       This must be unique across all products that belong to an Extension
                       The SKU cannot be changed after saving
                       Maximum: 255 characters, no white spaces
            cost (dict): Object containing cost information
            display_name (str): Name of the product to be displayed in the Extension
                                Maximum: 255 characters
            in_development (bool, optional): Set to true if the product is in development and not yet released for public use
                                             Default: false
            expiration (str, optional): Expiration time for the product in RFC3339 format
                                        If not provided, the Bits product will not have an expiration date
                                        Setting an expiration in the past will disable the product
            is_broadcast (bool, optional): Indicates if Bits product purchase events are broadcast to all instances of an Extension on a channel via the “onTransactionComplete” helper callback
                                           Default: false

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/bits/extensions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: extension_client_id,
        }
        data = {&#34;sku&#34;: sku, &#34;cost&#34;: cost, &#34;display_name&#34;: display_name}

        if in_development is not False:
            data[&#34;in_development&#34;] = in_development

        if expiration != &#34;&#34;:
            data[&#34;expiration&#34;] = expiration

        if is_broadcast is not False:
            data[&#34;is_broadcast&#34;] = is_broadcast

        response = requests.put(url, headers=headers, data=data)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def create_eventsub_subscription(self, type, version, condition, transport):
        &#34;&#34;&#34;
        Creates an EventSub subscription

        Args:
            type (str): The category of the subscription that is being created
                        Valid values: &#34;channel.update&#34;, &#34;channel.follow&#34;, &#34;channel.subscribe&#34;, &#34;channel.subscription.end&#34;, &#34;channel.subscription.gift&#34;,&#34;channel.subscription.message&#34;, &#34;channel.cheer&#34;, &#34;channel.raid&#34;, &#34;channel.ban&#34;, &#34;channel.unban&#34;, &#34;channel.moderator.add&#34;, &#34;channel.moderator.remove&#34;, &#34;channel.channel_points_custom_reward.add&#34;, &#34;channel.channel_points_custom_reward.update&#34;, &#34;channel.channel_points_custom_reward.remove&#34;, &#34;channel.channel_points_custom_reward_redemption.add&#34;, &#34;channel.channel_points_custom_reward_redemption.update&#34;, &#34;channel.poll.begin&#34;, &#34;channel.poll.progress&#34;, &#34;channel.poll.end&#34;, &#34;channel.prediction.begin&#34;, &#34;channel.prediction.progress&#34;, &#34;channel.prediction.lock&#34;, &#34;channel.prediction.end&#34;, &#34;drop.entitlement.grant&#34;, &#34;extension.bits_transaction.create&#34;, &#34;channel.hype_train.begin&#34;, &#34;channel.hype_train.progress&#34;, &#34;channel.hype_train.end&#34;, &#34;stream.online&#34;, &#34;stream.offline&#34;, &#34;user.authorization.grant&#34;, &#34;user.authorization.revoke&#34;, &#34;user.update&#34;
            version (str): The version of the subscription type that is being created
                           Each subscription type has independent versioning
            condition (dict): Custom parameters for the subscription
            transport (dict): Notification delivery specific configuration including a method string
                              Valid transport methods include: webhook
                              In addition to the method string, a webhook transport must include the callback and secret information

        Raises:
            twitchpy.errors.ClientError

        Returns:
            EventSubSubscription
        &#34;&#34;&#34;

        url = ENDPOINT_EVENTSUB_SUBSCRIPTION
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {
            &#34;type&#34;: type,
            &#34;version&#34;: version,
            &#34;condition&#34;: condition,
            &#34;transport&#34;: transport,
        }

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            subscription = response.json()[&#34;data&#34;][0]
            subscription = EventSubSubscription(
                subscription[&#34;id&#34;],
                subscription[&#34;status&#34;],
                subscription[&#34;type&#34;],
                subscription[&#34;version&#34;],
                subscription[&#34;condition&#34;],
                subscription[&#34;created_at&#34;],
                subscription[&#34;transport&#34;],
                subscription[&#34;cost&#34;],
            )

            return subscription

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def delete_eventsub_subscription(self, id):
        &#34;&#34;&#34;
        Delete an EventSub subscription

        Args:
            id (str): The subscription ID for the subscription to delete
        &#34;&#34;&#34;

        url = ENDPOINT_EVENTSUB_SUBSCRIPTION
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;id&#34;: id}

        requests.delete(url, headers=headers, data=data)

    def get_eventsub_subscriptions(
        self, status: str = &#34;&#34;, type: str = &#34;&#34;, user_id: str = &#34;&#34;
    ) -&gt; list[EventSubSubscription]:
        &#34;&#34;&#34;
        Get a list of your EventSub subscriptions
        Only include one filter query parameter

        Args:
            status (str, optional): Filters subscriptions by one status type
                Valid values: &#34;enabled&#34;, &#34;webhook_callback_verification_pending&#34;, &#34;webhook_callback_verification_failed&#34;, &#34;notification_failures_exceeded&#34;, &#34;authorization_revoked&#34;, &#34;moderator_removed&#34;, &#34;user_removed&#34;, &#34;version_removed&#34;, &#34;websocket_disconnected&#34;, &#34;websocket_failed_ping_pong&#34;, &#34;websocket_received_inbound_traffic&#34;, &#34;websocket_connection_unused&#34;, &#34;websocket_internal_error&#34;, &#34;websocket_network_timeout&#34;, &#34;websocket_network_error&#34;
            type (str, optional): Filters subscriptions by subscription type name
            user_id (str, optional): Filter subscriptions by user ID

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[EventSubSubscription]
        &#34;&#34;&#34;

        url = ENDPOINT_EVENTSUB_SUBSCRIPTION
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if status != &#34;&#34;:
            params[&#34;status&#34;] = status

        if type != &#34;&#34;:
            params[&#34;type&#34;] = type

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            subscriptions = []

            for subscription in response.json()[&#34;data&#34;]:
                subscriptions.append(
                    EventSubSubscription(
                        subscription[&#34;id&#34;],
                        subscription[&#34;status&#34;],
                        subscription[&#34;type&#34;],
                        subscription[&#34;version&#34;],
                        subscription[&#34;condition&#34;],
                        subscription[&#34;created_at&#34;],
                        subscription[&#34;transport&#34;],
                        subscription[&#34;cost&#34;],
                    )
                )

            return subscriptions

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_top_games(self, first=20):
        &#34;&#34;&#34;
        Gets games sorted by number of current viewers on Twitch, most popular first

        Args:
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/games/top&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        games = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for game in response[&#34;data&#34;]:
                    games.append(
                        Game(
                            game[&#34;id&#34;],
                            game[&#34;name&#34;],
                            game[&#34;box_art_url&#34;],
                            game[&#34;igdb_id&#34;],
                        )
                    )

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return games

    def get_games(
        self, id: list[str] = [], name: list[str] = [], igdb_id: list[str] = []
    ) -&gt; list[Game]:
        &#34;&#34;&#34;
        Gets information about specified categories or games

        Args:
            id (list[str]): The ID of the category or game to get
                Maximum: 100
            name (list[str]): The name of the category or game to get
                Maximum: 100
            igdb_id (list[str]): The IGDB ID of the game to get
                Maximum: 100

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Game]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/games&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if len(name) &gt; 0:
            params[&#34;name&#34;] = name

        if len(igdb_id) &gt; 0:
            params[&#34;igdb_id&#34;] = igdb_id

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            games = []

            for game in response.json()[&#34;data&#34;]:
                games.append(
                    Game(game[&#34;id&#34;], game[&#34;name&#34;], game[&#34;box_art_url&#34;], game[&#34;igdb_id&#34;])
                )

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return games

    def get_creator_goals(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets the broadcaster’s list of active goals
        Use this to get the current progress of each goal

        Args:
            broadcaster_id (str): The ID of the broadcaster that created the goals

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/goals&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_channel_guest_star_settings(
        self, broadcaster_id: str, moderator_id: str
    ) -&gt; dict:
        &#34;&#34;&#34;
        Gets the channel settings for configuration of the Guest Star feature for a particular host

        Args:
            broadcaster_id (str): The ID of the broadcaster you want to get guest star settings for
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user ID in the user access token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/guest_star/channel_settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_channel_guest_star_settings(
        self,
        broadcaster_id: str,
        is_moderator_send_live_enabled: bool = None,
        slot_count: int = None,
        is_browser_source_audio_enabled: bool = None,
        group_layout: str = &#34;&#34;,
        regenerate_browser_sources: bool = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Mutates the channel settings for configuration of the Guest Star feature for a particular host

        Args:
            broadcaster_id (str): The ID of the broadcaster you want to update Guest Star settings for
            is_moderator_send_live_enabled (bool): Flag determining if Guest Star moderators have access to control whether a guest is live once assigned to a slot
            slot_count (int): Number of slots the Guest Star call interface will allow the host to add to a call.
                Required to be between 1 and 6
            is_browser_source_audio_enabled (bool): Flag determining if Browser Sources subscribed to sessions on this channel should output audio
            group_layout (str): This setting determines how the guests within a session should be laid out within the browser source
                Possible values: TILED_LAYOUT, SCREENSHARE_LAYOUT, HORIZONTAL_LAYOUT, VERTICAL_LAYOUT
            regenerate_browser_sources (bool): Flag determining if Guest Star should regenerate the auth token associated with the channel’s browser sources
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/guest_star/channel_settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id}

        if is_moderator_send_live_enabled is not None:
            data[&#34;is_moderator_send_live_enabled&#34;] = is_moderator_send_live_enabled

        if slot_count is not None:
            data[&#34;slot_count&#34;] = slot_count

        if is_browser_source_audio_enabled is not None:
            data[&#34;is_browser_source_audio_enabled&#34;] = is_browser_source_audio_enabled

        if group_layout != &#34;&#34;:
            data[&#34;group_layout&#34;] = group_layout

        if regenerate_browser_sources is not None:
            data[&#34;regenerate_browser_sources&#34;] = regenerate_browser_sources

        requests.put(url, headers=headers, json=data)

    def get_guest_star_session(
        self, broadcaster_id: str, moderator_id: str
    ) -&gt; GuestStarSession:
        &#34;&#34;&#34;
        Gets information about an ongoing Guest Star session for a particular channel

        Args:
            broadcaster_id (str): ID for the user hosting the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user ID in the user access token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            GuestStarSession
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_SESSION
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()[&#34;data&#34;][0]

            return GuestStarSession(response[&#34;id&#34;], response[&#34;guests&#34;])

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;data&#34;][&#34;message&#34;])

    def create_guest_star_session(self, broadcaster_id: str) -&gt; GuestStarSession:
        &#34;&#34;&#34;
        Programmatically creates a Guest Star session on behalf of the broadcaster

        Args:
            broadcaster_id (str): The ID of the broadcaster you want to create a Guest Star session for
                Provided broadcaster_id must match the user_id in the auth token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            GuestStarSession
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_SESSION
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            response = response.json()[&#34;data&#34;][0]

            return GuestStarSession(response[&#34;id&#34;], response[&#34;guests&#34;])

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;data&#34;][&#34;message&#34;])

    def end_guest_star_session(
        self, broadcaster_id: str, session_id: str
    ) -&gt; GuestStarSession:
        &#34;&#34;&#34;
        Programmatically ends a Guest Star session on behalf of the broadcaster

        Args:
            broadcaster_id (str): The ID of the broadcaster you want to end a Guest Star session for
                Provided broadcaster_id must match the user_id in the auth token
            session_id (str): ID for the session to end on behalf of the broadcaster

        Raises:
            twitchpy.errors.ClientError

        Returns:
            GuestStarSession
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_SESSION
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;session_id&#34;: session_id}

        response = requests.delete(url, headers=headers, data=data)

        if response.ok:
            response = response.json()[&#34;data&#34;][0]

            return GuestStarSession(response[&#34;id&#34;], response[&#34;guests&#34;])

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;data&#34;][&#34;message&#34;])

    def get_guest_star_invites(
        self, broadcaster_id: str, moderator_id: str, session_id: str
    ) -&gt; list[dict]:
        &#34;&#34;&#34;
        Provides a list of pending invites to a Guest Star session, including the invitee’s ready status while joining the waiting room

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user_id in the user access token
            session_id (str): The session ID to query for invite status

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[dict]
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_INVITES
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
        }

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def send_guest_star_invite(
        self, broadcaster_id: str, moderator_id: str, session_id: str, guest_id: str
    ) -&gt; None:
        &#34;&#34;&#34;
        Sends an invite to a specified guest on behalf of the broadcaster for a Guest Star session in progress

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user_id in the user access token
            session_id (str): The session ID for the invite to be sent on behalf of the broadcaster
            guest_id (str): Twitch User ID for the guest to invite to the Guest Star session
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_INVITES
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
            &#34;guest_id&#34;: guest_id,
        }

        requests.post(url, headers=headers, json=payload)

    def delete_guest_star_invite(
        self, broadcaster_id: str, moderator_id: str, session_id: str, guest_id: str
    ) -&gt; None:
        &#34;&#34;&#34;
        Revokes a previously sent invite for a Guest Star session

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user_id in the user access token
            session_id (str): The ID of the session for the invite to be revoked on behalf of the broadcaster
            guest_id (str): Twitch User ID for the guest to revoke the Guest Star session invite from
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_INVITES
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
            &#34;guest_id&#34;: guest_id,
        }

        requests.delete(url, headers=headers, data=data)

    def assign_guest_star_slot(
        self,
        broadcaster_id: str,
        moderator_id: str,
        session_id: str,
        guest_id: str,
        slot_id: str,
    ) -&gt; None:
        &#34;&#34;&#34;
        Allows a previously invited user to be assigned a slot within the active Guest Star session, once that guest has indicated they are ready to join

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user_id in the user access token
            session_id (str): The ID of the Guest Star session in which to assign the slot
            guest_id (str): The Twitch User ID corresponding to the guest to assign a slot in the session
                This user must already have an invite to this session, and have indicated that they are ready to join
            slot_id (str): The slot assignment to give to the user
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_SLOT
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
            &#34;guest_id&#34;: guest_id,
            &#34;slot_id&#34;: slot_id,
        }

        requests.post(url, headers=headers, json=payload)

    def update_guest_star_slot(
        self,
        broadcaster_id: str,
        moderator_id: str,
        session_id: str,
        source_slot_id: str,
        destination_slot_id: str = &#34;&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;
        Allows a user to update the assigned slot for a particular user within the active Guest Star session

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user_id in the user access token
            session_id (str): The ID of the Guest Star session in which to update slot settings
            source_slot_id (str): The slot assignment previously assigned to a user
            destination_slot_id (str): The slot to move this user assignment to
                If the destination slot is occupied, the user assigned will be swapped into source_slot_id
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_SLOT
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
            &#34;source_slot_id&#34;: source_slot_id,
        }

        if destination_slot_id != &#34;&#34;:
            data[&#34;destination_slot_id&#34;] = destination_slot_id

        requests.patch(url, headers=headers, data=data)

    def delete_guest_star_slot(
        self,
        broadcaster_id: str,
        moderator_id: str,
        session_id: str,
        guest_id: str,
        slot_id: str,
        should_reinvite_guest: str = &#34;&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;
        Allows a caller to remove a slot assignment from a user participating in an active Guest Star session

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user ID in the user access token
            session_id (str): The ID of the Guest Star session in which to remove the slot assignment
            guest_id (str): The Twitch User ID corresponding to the guest to remove from the session
            slot_id (str): The slot ID representing the slot assignment to remove from the session
            should_reinvite_guest (str): Flag signaling that the guest should be reinvited to the session, sending them back to the invite queue
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_SLOT
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
            &#34;guest_id&#34;: guest_id,
            &#34;slot_id&#34;: slot_id,
        }

        if should_reinvite_guest != &#34;&#34;:
            data[&#34;should_reinvite_guest&#34;] = should_reinvite_guest

        requests.delete(url, headers=headers, data=data)

    def update_guest_star_slot_settings(
        self,
        broadcaster_id: str,
        moderator_id: str,
        session_id: str,
        slot_id: str,
        is_audio_enabled: bool = None,
        is_video_enabled: bool = None,
        is_live: bool = None,
        volume: int = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Allows a user to update slot settings for a particular guest within a Guest Star session, such as allowing the user to share audio or video within the call as a host

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user ID in the user access token
            session_id (str): The ID of the Guest Star session in which to update a slot’s settings
            slot_id (str): The slot assignment that has previously been assigned to a user
            is_audio_enabled (bool): Flag indicating whether the slot is allowed to share their audio with the rest of the session
            is_video_enabled (bool): Flag indicating whether the slot is allowed to share their video with the rest of the session
            is_live (bool): Flag indicating whether the user assigned to this slot is visible/can be heard from any public subscriptions
            volume (int): Value from 0-100 that controls the audio volume for shared views containing the slot
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/guest_star/slot_settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
            &#34;slot_id&#34;: slot_id,
        }

        if is_audio_enabled is not None:
            data[&#34;is_audio_enabled&#34;] = is_audio_enabled

        if is_video_enabled is not None:
            data[&#34;is_video_enabled&#34;] = is_video_enabled

        if is_live is not None:
            data[&#34;is_live&#34;] = is_live

        if volume is not None:
            data[&#34;volume&#34;] = volume

        requests.patch(url, headers=headers, data=data)

    def get_hype_train_events(
        self, broadcaster_id: str, first: int = 1
    ) -&gt; list[HypeTrainEvent]:
        &#34;&#34;&#34;
        Gets the information of the most recent Hype Train of the given channel ID
        When there is currently an active Hype Train, it returns information about that Hype Train
        When there is currently no active Hype Train, it returns information about the most recent Hype Train
        After 5 days, if no Hype Train has been active, the endpoint will return an empty response

        Args:
            broadcaster_id (str): User ID of the broadcaster
                Must match the User ID in the Bearer token if User Token is used
            first (int, optional): Maximum number of objects to return
                Default: 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[HypeTrainEvent]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/hypetrain/events&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        cursor = &#34;&#34;
        calls = math.ceil(first / 100)
        events = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if cursor != &#34;&#34;:
                params[&#34;cursor&#34;] = cursor

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for event in response[&#34;data&#34;]:
                    events.append(
                        HypeTrainEvent(
                            event[&#34;id&#34;],
                            event[&#34;event_type&#34;],
                            event[&#34;event_timestamp&#34;],
                            event[&#34;version&#34;],
                            event[&#34;event_data&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and response[&#34;pagination&#34;] is not None:
                    cursor = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return events

    def check_automod_status(
        self, broadcaster_id: str, msg_id: str, msg_user: str
    ) -&gt; list[dict]:
        &#34;&#34;&#34;
        Determines whether a string message meets the channel’s AutoMod requirements

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token
            msg_id (str): Developer-generated identifier for mapping messages to results
            msg_user (str): Message text

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[dict]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/enforcements/status&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;data&#34;: [{&#34;msg_id&#34;: msg_id, &#34;msg_user&#34;: msg_user}],
        }

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def manage_held_automod_messages(self, user_id, msg_id, action):
        &#34;&#34;&#34;
        Allow or deny a message that was held for review by AutoMod

        Args:
            user_id (str): The moderator who is approving or rejecting the held message
                           Must match the user_id in the user OAuth token
            msg_id (str): ID of the message to be allowed or denied
            action (str): The action to take for the message
                          Must be &#34;ALLOW&#34; or &#34;DENY&#34;
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/automod/message&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;user_id&#34;: user_id, &#34;msg_id&#34;: msg_id, &#34;action&#34;: action}

        requests.post(url, headers=headers, json=payload)

    def get_automod_settings(self, broadcaster_id, moderator_id):
        &#34;&#34;&#34;
        Gets the broadcaster’s AutoMod settings, which are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster whose AutoMod settings you want to get
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to get their own AutoMod settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/automod/settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_automod_settings(
        self,
        broadcaster_id,
        moderator_id,
        aggression=None,
        bullying=None,
        disability=None,
        misogyny=None,
        overall_level=None,
        race_ethnicity_or_religion=None,
        sex_based_terms=None,
        sexuality_sex_or_gender=None,
        swearing=None,
    ):
        &#34;&#34;&#34;
        Updates the broadcaster’s AutoMod settings, which are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster whose AutoMod settings you want to update
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to update their own AutoMod settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
            aggression (int, optional): The Automod level for hostility involving aggression
            bullying (int, optional): The Automod level for hostility involving name calling or insults
            disability (int, optional): The Automod level for discrimination against disability
            misogyny (int, optional): The Automod level for discrimination against women
            overall_level (int, optional): The default AutoMod level for the broadcaster
            race_ethnicity_or_religion (int, optional): The Automod level for racial discrimination
            sex_based_terms (int, optional): The Automod level for sexual content
            sexuality_sex_or_gender (int, optional): The AutoMod level for discrimination based on sexuality, sex, or gender
            swearing (int, optional): The Automod level for profanity

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/automod/settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        if aggression is not None:
            data[&#34;aggression&#34;] = aggression

        if bullying is not None:
            data[&#34;bullying&#34;] = bullying

        if disability is not None:
            data[&#34;disability&#34;] = disability

        if misogyny is not None:
            data[&#34;misogyny&#34;] = misogyny

        if overall_level is not None:
            data[&#34;overall_level&#34;] = overall_level

        if race_ethnicity_or_religion is not None:
            data[&#34;race_ethnicity_or_religion&#34;] = race_ethnicity_or_religion

        if sex_based_terms is not None:
            data[&#34;sex_based_terms&#34;] = sex_based_terms

        if sexuality_sex_or_gender is not None:
            data[&#34;sexuality_sex_or_gender&#34;] = sexuality_sex_or_gender

        if swearing is not None:
            data[&#34;swearing&#34;] = swearing

        response = requests.put(url, headers=headers, json=data)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_banned_users(self, broadcaster_id, user_id=[], first=20):
        &#34;&#34;&#34;
        Returns all banned and timed-out users in a channel

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token
            user_id (list, optional): Filters the results and only returns a status object for users who are banned in this channel and have a matching user_id
                                     Maximum: 100
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/banned&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(user_id) &gt; 0:
            params[&#34;user_id&#34;] = user_id

        if first != 20:
            params[&#34;first&#34;] = first

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        users = []

        for call in range(calls):
            if first - (100 * call) &gt; 100:
                params[&#34;first&#34;] = 100

            else:
                params[&#34;first&#34;] = first - (100 * call)

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                users.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return users

    def ban_user(self, broadcaster_id, moderator_id, reason, user_id, duration=None):
        &#34;&#34;&#34;
        Bans a user from participating in a broadcaster’s chat room, or puts them in a timeout
        If the user is currently in a timeout, you can use this method to change the duration of the timeout or ban them altogether
        If the user is currently banned, you cannot call this method to put them in a timeout instead

        Args:
            broadcaster_id (str): The ID of the broadcaster whose chat room the user is being banned from
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to ban the user (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
            reason (reason): The reason the user is being banned or put in a timeout
                             The text is user defined and limited to a maximum of 500 characters
            user_id (str): The ID of the user to ban or put in a timeout
            duration (int, optional): To ban a user indefinitely, don’t include this field
                                      To put a user in a timeout, include this field and specify the timeout period, in seconds
                                      The minimum timeout is 1 second and the maximum is 1,209,600 seconds (2 weeks)
                                      To end a user’s timeout early, set this field to 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/bans&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        data = {&#34;reason&#34;: reason, &#34;user_id&#34;: user_id}

        if duration is not None:
            data[&#34;duration&#34;] = duration

        payload[&#34;data&#34;] = data

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def unban_user(self, broadcaster_id, moderator_id, user_id):
        &#34;&#34;&#34;
        Removes the ban or timeout that was placed on the specified user

        Args:
            broadcaster_id (str): The ID of the broadcaster whose chat room the user is banned from chatting in
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to remove the ban (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
            user_id (str): The ID of the user to remove the ban or timeout from

        Raises:
            twitchpy.errors.ClientError
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/bans&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;user_id&#34;: user_id,
        }

        requests.delete(url, headers=headers, data=data)

    def get_blocked_terms(self, broadcaster_id, moderator_id, first=20):
        &#34;&#34;&#34;
        Gets the broadcaster’s list of non-private, blocked words or phrases
        These are the terms that the broadcaster or moderator added manually, or that were denied by AutoMod

        Args:
            broadcaster_id (str): The ID of the broadcaster whose blocked terms you’re getting
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to get their own block terms (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
            first (int, optional): The maximum number of blocked terms to return per page in the response
                                   The minimum page size is 1 blocked term per page and the maximum is 100
                                   The default is 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = ENDPOINT_MODERATION_BLOCKED_TERMS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        if first != 20:
            params[&#34;first&#34;] = first

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        blocked_terms = []

        for call in range(calls):
            if first - (100 * call) &gt; 100:
                params[&#34;first&#34;] = 100

            else:
                params[&#34;first&#34;] = first - (100 * call)

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                blocked_terms.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return blocked_terms

    def add_blocked_term(self, broadcaster_id, moderator_id, text):
        &#34;&#34;&#34;
        Adds a word or phrase to the broadcaster’s list of blocked terms
        These are the terms that broadcasters don’t want used in their chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster that owns the list of blocked terms
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to add the blocked term (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
            text (str): The word or phrase to block from being used in the broadcaster’s chat room
                        The term must contain a minimum of 2 characters and may contain up to a maximum of 500 characters
                        Terms can use a wildcard character (*)
                        The wildcard character must appear at the beginning or end of a word, or set of characters

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = ENDPOINT_MODERATION_BLOCKED_TERMS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;text&#34;: text,
        }

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def remove_blocked_term(self, broadcaster_id, id, moderator_id):
        &#34;&#34;&#34;
        Removes the word or phrase that the broadcaster is blocking users from using in their chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster that owns the list of blocked terms
            id (str): The ID of the blocked term you want to delete
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to delete the blocked term (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
        &#34;&#34;&#34;

        url = ENDPOINT_MODERATION_BLOCKED_TERMS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;id&#34;: id,
            &#34;moderator_id&#34;: moderator_id,
        }

        requests.delete(url, headers=headers, data=data)

    def delete_chat_messages(
        self, broadcaster_id: str, moderator_id: str, message_id: str = &#34;&#34;
    ) -&gt; None:
        &#34;&#34;&#34;
        Removes a single chat message or all chat messages from the broadcaster’s chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster that owns the chat room to remove messages from
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user ID in the user access token
            message_id (str, optional): The ID of the message to remove
                If not specified, the request removes all messages in the broadcaster’s chat room
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/chat&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        if message_id != &#34;&#34;:
            data[&#34;message_id&#34;] = message_id

        requests.delete(url, headers=headers, data=data)

    def get_moderators(self, broadcaster_id, user_id=[], first=20):
        &#34;&#34;&#34;
        Returns all moderators in a channel

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token
            user_id (list, optional): Filters the results and only returns a status object for users who are moderators in this channel and have a matching user_id
                                      Maximum: 100
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = ENDPOINT_MODERATORS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(user_id) &gt; 0:
            params[&#34;user_id&#34;] = user_id

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        ids = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for user in response[&#34;data&#34;]:
                    ids.append(user[&#34;user_id&#34;])

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return self.get_users(id=ids)

    def add_channel_moderator(self, broadcaster_id: str, user_id: str) -&gt; None:
        &#34;&#34;&#34;
        Adds a moderator to the broadcaster’s chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster that owns the chat room
                This ID must match the user ID in the access token
            user_id (str): The ID of the user to add as a moderator in the broadcaster’s chat room
        &#34;&#34;&#34;

        url = ENDPOINT_MODERATORS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;user_id&#34;: user_id}

        requests.post(url, headers=headers, json=payload)

    def remove_channel_moderator(self, broadcaster_id: str, user_id: str) -&gt; None:
        &#34;&#34;&#34;
        Removes a moderator from the broadcaster’s chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster that owns the chat room
                This ID must match the user ID in the access token
            user_id (str): The ID of the user to remove as a moderator from the broadcaster’s chat room
        &#34;&#34;&#34;

        url = ENDPOINT_MODERATORS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;user_id&#34;: user_id}

        requests.delete(url, headers=headers, data=data)

    def get_vips(
        self, broadcaster_id: str, user_id: list[str] = [], first: int = 20
    ) -&gt; list[User]:
        &#34;&#34;&#34;
        Gets a list of the broadcaster’s VIPs

        Args:
            broadcaster_id (str): The ID of the broadcaster whose list of VIPs you want to get
                This ID must match the user ID in the access token
            user_id (list[str]): Filters the list for specific VIPs
                Maximum: 100
            first (int): The number of items to return
                Minimum: 1
                Maximum: 100

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[User]
        &#34;&#34;&#34;

        url = ENDPOINT_VIPS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(user_id) &gt; 0:
            params[&#34;user_id&#34;] = user_id

        after = &#34;&#34;
        calls = math.ceil(first / 20)
        users = []

        for call in range(calls):
            params[&#34;first&#34;] = min(20, first - (20 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                if response[&#34;data&#34;] is not None:
                    users.append(
                        self.get_users(
                            id=[user[&#34;user_id&#34;] for user in response[&#34;data&#34;]]
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return users

    def add_channel_vip(self, user_id: str, broadcaster_id: str) -&gt; None:
        &#34;&#34;&#34;
        Adds the specified user as a VIP in the broadcaster’s channel

        Args:
            user_id (str): The ID of the user to give VIP status to
            broadcaster_id (str): The ID of the broadcaster that’s adding the user as a VIP
                This ID must match the user ID in the access token
        &#34;&#34;&#34;

        url = ENDPOINT_VIPS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;user_id&#34;: user_id, &#34;broadcaster_id&#34;: broadcaster_id}

        requests.post(url, headers=headers, json=payload)

    def remove_channel_vip(self, user_id: str, broadcaster_id: str) -&gt; None:
        &#34;&#34;&#34;
        Removes the specified user as a VIP in the broadcaster’s channel

        Args:
            user_id (str): The ID of the user to remove VIP status from
            broadcaster_id (str): The ID of the user to remove VIP status from
        &#34;&#34;&#34;

        url = ENDPOINT_VIPS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;user_id&#34;: user_id, &#34;broadcaster_id&#34;: broadcaster_id}

        requests.delete(url, headers=headers, data=data)

    def update_shield_mode_status(
        self, broadcaster_id: str, moderator_id: str, is_active: bool
    ) -&gt; dict:
        &#34;&#34;&#34;
        Activates or deactivates the broadcaster’s Shield Mode

        Args:
            broadcaster_id (str): The ID of the broadcaster whose Shield Mode you want to activate or deactivate
            moderator_id (str): The ID of the broadcaster or a user that is one of the broadcaster’s moderators
                This ID must match the user ID in the access token
            is_active (bool): A Boolean value that determines whether to activate Shield Mode

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/shield_mode&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;is_active&#34;: is_active,
        }

        response = requests.put(url, headers=headers, data=data)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_shield_mode_status(self, broadcaster_id: str, moderator_id: str) -&gt; dict:
        &#34;&#34;&#34;
        Gets the broadcaster’s Shield Mode activation status

        Args:
            broadcaster_id (str): The ID of the broadcaster whose Shield Mode activation status you want to get
            moderator_id (str): The ID of the broadcaster or a user that is one of the broadcaster’s moderators
                This ID must match the user ID in the access token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/shield_mode&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_polls(self, broadcaster_id, id=[], first=20):
        &#34;&#34;&#34;
        Get information about all polls or specific polls for a Twitch channel
        Poll information is available for 90 days

        Args:
            broadcaster_id (str): The broadcaster running polls
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (list, optional): ID of a poll
                                 Maximum: 100
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = ENDPOINT_POLLS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        after = &#34;&#34;
        calls = math.ceil(first / 20)
        polls = []

        for call in range(calls):
            params[&#34;first&#34;] = min(20, first - (20 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                if response[&#34;data&#34;] is not None:
                    for poll in response[&#34;data&#34;]:
                        polls.append(
                            Poll(
                                poll[&#34;id&#34;],
                                poll[&#34;broadcaster_id&#34;],
                                poll[&#34;broadcaster_name&#34;],
                                poll[&#34;broadcaster_login&#34;],
                                poll[&#34;title&#34;],
                                poll[&#34;choices&#34;],
                                poll[&#34;bits_voting_enabled&#34;],
                                poll[&#34;bits_per_vote&#34;],
                                poll[&#34;channel_points_voting_enabled&#34;],
                                poll[&#34;channel_points_per_vote&#34;],
                                poll[&#34;status&#34;],
                                poll[&#34;duration&#34;],
                                poll[&#34;started_at&#34;],
                            )
                        )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return polls

    def create_poll(
        self,
        broadcaster_id: str,
        title: str,
        choices: list[str],
        duration: int,
        channel_points_voting_enabled: bool = False,
        channel_points_per_vote: int = 0,
    ) -&gt; Poll:
        &#34;&#34;&#34;
        Create a poll for a specific Twitch channel

        Args:
            broadcaster_id (str): The broadcaster running polls
                Provided broadcaster_id must match the user_id in the user OAuth token
            title (str): Question displayed for the poll
                Maximum: 60 characters
            choices (list): Array of the poll choices
                Minimum: 2 choices
                Maximum: 5 choices
            duration (int): Total duration for the poll (in seconds)
                Minimum: 15
                Maximum: 1800
            channel_points_voting_enabled (bool, optional): Indicates if Channel Points can be used for voting
                Default: false
            channel_points_per_vote (int, optional): Number of Channel Points required to vote once with Channel Points
                Minimum: 0
                Maximum: 1000000

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Poll
        &#34;&#34;&#34;

        url = ENDPOINT_POLLS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }

        choices_dicts = []

        for choice in choices:
            choices_dicts.append({&#34;title&#34;: choice})

        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;title&#34;: title,
            &#34;choices&#34;: choices_dicts,
            &#34;duration&#34;: duration,
        }

        if channel_points_voting_enabled is not False:
            payload[&#34;channel_points_voting_enabled&#34;] = channel_points_voting_enabled

        if channel_points_per_vote != 0:
            payload[&#34;channel_points_per_vote&#34;] = channel_points_per_vote

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            poll = response.json()[&#34;data&#34;][0]
            poll = Poll(
                poll[&#34;id&#34;],
                poll[&#34;broadcaster_id&#34;],
                poll[&#34;broadcaster_name&#34;],
                poll[&#34;broadcaster_login&#34;],
                poll[&#34;title&#34;],
                poll[&#34;choices&#34;],
                poll[&#34;channel_points_voting_enabled&#34;],
                poll[&#34;channel_points_per_vote&#34;],
                poll[&#34;status&#34;],
                poll[&#34;duration&#34;],
                poll[&#34;started_at&#34;],
            )

            return poll

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def end_poll(self, broadcaster_id, id, status):
        &#34;&#34;&#34;
        End a poll that is currently active

        Args:
            broadcaster_id (str): The broadcaster running polls
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (str): ID of the poll
            status (str): The poll status to be set
                          Valid values: &#34;TERMINATED&#34;, &#34;ARCHIVED&#34;

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Poll
        &#34;&#34;&#34;

        url = ENDPOINT_POLLS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id, &#34;status&#34;: status}

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            poll = response.json()[&#34;data&#34;][0]
            poll = Poll(
                poll[&#34;id&#34;],
                poll[&#34;broadcaster_id&#34;],
                poll[&#34;broadcaster_name&#34;],
                poll[&#34;broadcaster_login&#34;],
                poll[&#34;title&#34;],
                poll[&#34;choices&#34;],
                poll[&#34;bits_voting_enabled&#34;],
                poll[&#34;bits_per_vote&#34;],
                poll[&#34;channel_points_voting_enabled&#34;],
                poll[&#34;channel_points_per_vote&#34;],
                poll[&#34;status&#34;],
                poll[&#34;duration&#34;],
                poll[&#34;started_at&#34;],
            )

            return poll

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_predictions(self, broadcaster_id, id=[], first=20):
        &#34;&#34;&#34;
        Get information about all Channel Points Predictions or specific Channel Points Predictions for a Twitch channel

        Args:
            broadcaster_id (str): The broadcaster running Predictions
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (str, optional): ID of a Prediction
                                Maximum: 100
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = ENDPOINT_PREDICTIONS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        after = &#34;&#34;
        calls = math.ceil(first / 20)
        predictions = []

        for call in range(calls):
            params[&#34;first&#34;] = min(20, first - (20 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for prediction in response[&#34;data&#34;]:
                    predictions.append(
                        Prediction(
                            prediction[&#34;id&#34;],
                            prediction[&#34;broadcaster_id&#34;],
                            prediction[&#34;broadcaster_name&#34;],
                            prediction[&#34;broadcaster_login&#34;],
                            prediction[&#34;title&#34;],
                            prediction[&#34;winning_outcome_id&#34;],
                            prediction[&#34;outcomes&#34;],
                            prediction[&#34;prediction_window&#34;],
                            prediction[&#34;status&#34;],
                            prediction[&#34;created_at&#34;],
                            prediction[&#34;ended_at&#34;],
                            prediction[&#34;locked_at&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return predictions

    def create_prediction(
        self,
        broadcaster_id: str,
        title: str,
        outcomes: list[str],
        prediction_window: int,
    ) -&gt; Prediction:
        &#34;&#34;&#34;
        Create a Channel Points Prediction for a specific Twitch channel

        Args:
            broadcaster_id (str): The broadcaster running Predictions
                Provided broadcaster_id must match the user_id in the user OAuth token
            title (str): Title for the Prediction
                Maximum: 45 characters
            outcomes (list[str]): The list of possible outcomes that the viewers may choose from
                Minimum: 2
                Maximum: 10
            prediction_window (int): Total duration for the Prediction (in seconds)
                Minimum: 1
                Maximum: 1800

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Prediction
        &#34;&#34;&#34;

        url = ENDPOINT_PREDICTIONS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;title&#34;: title,
            &#34;prediction_window&#34;: prediction_window,
        }

        outcomes_payload = []

        for outcome in outcomes:
            outcomes_payload.append({&#34;title&#34;: outcome})

        payload[&#34;outcomes&#34;] = outcomes_payload

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            prediction = response.json()[&#34;data&#34;][0]
            prediction = Prediction(
                prediction[&#34;id&#34;],
                prediction[&#34;broadcaster_id&#34;],
                prediction[&#34;broadcaster_name&#34;],
                prediction[&#34;broadcaster_login&#34;],
                prediction[&#34;title&#34;],
                prediction[&#34;winning_outcome_id&#34;],
                prediction[&#34;outcomes&#34;],
                prediction[&#34;prediction_window&#34;],
                prediction[&#34;status&#34;],
                prediction[&#34;created_at&#34;],
                prediction[&#34;ended_at&#34;],
                prediction[&#34;locked_at&#34;],
            )

            return prediction

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def end_prediction(self, broadcaster_id, id, status, winning_outcome_id=&#34;&#34;):
        &#34;&#34;&#34;
        Lock, resolve, or cancel a Channel Points Prediction
        Active Predictions can be updated to be &#34;locked&#34;, &#34;resolved&#34;, or &#34;canceled&#34;
        Locked Predictions can be updated to be &#34;resolved&#34; or &#34;canceled&#34;

        Args:
            broadcaster_id (str): The broadcaster running prediction events
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (str): ID of the Prediction
            status (str): The Prediction status to be set
                          Valid values: &#34;RESOLVED&#34;, &#34;CANCELED&#34;, &#34;LOCKED&#34;
            winning_outcome_id (str, optional): ID of the winning outcome for the Prediction
                                                This parameter is required if status is being set to RESOLVED

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Prediction
        &#34;&#34;&#34;

        url = ENDPOINT_PREDICTIONS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id, &#34;status&#34;: status}

        if winning_outcome_id != &#34;&#34;:
            data[&#34;winning_outcome_id&#34;] = winning_outcome_id

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            prediction = response.json()[&#34;data&#34;][0]
            prediction = Prediction(
                prediction[&#34;id&#34;],
                prediction[&#34;broadcaster_id&#34;],
                prediction[&#34;broadcaster_name&#34;],
                prediction[&#34;broadcaster_login&#34;],
                prediction[&#34;title&#34;],
                prediction[&#34;winning_outcome_id&#34;],
                prediction[&#34;outcomes&#34;],
                prediction[&#34;prediction_window&#34;],
                prediction[&#34;status&#34;],
                prediction[&#34;created_at&#34;],
                prediction[&#34;ended_at&#34;],
                prediction[&#34;locked_at&#34;],
            )

            return prediction

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def start_raid(self, from_broadcaster_id: str, to_broadcaster_id: str) -&gt; dict:
        &#34;&#34;&#34;
        Raid another channel by sending the broadcaster’s viewers to the targeted channel

        Args:
            from_broadcaster_id (str): The ID of the broadcaster that’s sending the raiding party
                This ID must match the user ID in the user access token
            to_broadcaster_id (str): The ID of the broadcaster to raid

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/raids&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;from_broadcaster_id&#34;: from_broadcaster_id,
            &#34;to_broadcaster_id&#34;: to_broadcaster_id,
        }

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def cancel_raid(self, broadcaster_id: str) -&gt; None:
        &#34;&#34;&#34;
        Cancel a pending raid

        Args:
            broadcaster_id (str): The ID of the broadcaster that initiated the raid
                This ID must match the user ID in the user access token
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/raids&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id}

        requests.delete(url, headers=headers, data=data)

    def get_channel_stream_schedule(
        self, broadcaster_id, id=[], start_time=&#34;&#34;, utc_offset=&#34;0&#34;, first=20
    ):
        &#34;&#34;&#34;
        Gets all scheduled broadcasts or specific scheduled broadcasts from a channel’s stream schedule
        Scheduled broadcasts are defined as &#34;stream segments&#34;

        Args:
            broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (str, optional): The ID of the stream segment to return
                                Maximum: 100
            start_time (str, optional): A timestamp in RFC3339 format to start returning stream segments from
                                        If not specified, the current date and time is used
            utc_offset (str, optional): A timezone offset for the requester specified in minutes
                                        If not specified, &#34;0&#34; is used for GMT
            first (int, optional): Maximum number of stream segments to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/schedule&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if start_time != &#34;&#34;:
            params[&#34;start_time&#34;] = start_time

        if utc_offset != &#34;0&#34;:
            params[&#34;utc_offset&#34;] = utc_offset

        after = &#34;&#34;
        calls = math.ceil(first / 25)
        schedules = []

        for call in range(calls):
            params[&#34;first&#34;] = min(25, first - (25 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for schedule in response[&#34;data&#34;]:
                    schedules.append(
                        StreamSchedule(
                            schedule[&#34;segments&#34;],
                            schedule[&#34;broadcaster_id&#34;],
                            schedule[&#34;broadcaster_name&#34;],
                            schedule[&#34;broadcaster_login&#34;],
                            schedule[&#34;vacation&#34;],
                        )
                    )

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return schedules

    def get_channel_icalendar(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets all scheduled broadcasts from a channel’s stream schedule as an iCalendar

        Args:
            broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule

        Returns:
            str
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/schedule/icalendar&#34;
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, params=params)

        if response.ok:
            return response.text

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_channel_stream_schedule(
        self,
        broadcaster_id,
        is_vacation_enabled=False,
        vacation_start_time=&#34;&#34;,
        vacation_end_time=&#34;&#34;,
        timezone=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Update the settings for a channel’s stream schedule
        This can be used for setting vacation details

        Args:
            broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            is_vacation_enabled (bool, optional): Indicates if Vacation Mode is enabled
                                                  Set to true to add a vacation or false to remove vacation from the channel streaming schedule
            vacation_start_time (str, optional): Start time for vacation specified in RFC3339 format
                                                 Required if is_vacation_enabled is set to true
            vacation_end_time (str, optional): End time for vacation specified in RFC3339 format
                                               Required if is_vacation_enabled is set to true
            timezone (str, optional): The timezone for when the vacation is being scheduled using the IANA time zone database format
                                      Required if is_vacation_enabled is set to true

        Raises:
            twitchpy.errors.ClientError
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/schedule/settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id}

        if is_vacation_enabled:
            data[&#34;is_vacation_enabled&#34;] = True

        if vacation_start_time != &#34;&#34;:
            data[&#34;vacation_start_time&#34;] = vacation_start_time

        if vacation_end_time != &#34;&#34;:
            data[&#34;vacation_end_time&#34;] = vacation_end_time

        if timezone != &#34;&#34;:
            data[&#34;timezone&#34;] = timezone

        requests.patch(url, headers=headers, data=data)

    def create_channel_stream_schedule_segment(
        self,
        broadcaster_id,
        start_time,
        timezone,
        is_recurring,
        duration=240,
        category_id=&#34;&#34;,
        title=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Create a single scheduled broadcast or a recurring scheduled broadcast for a channel’s stream schedule

        Args:
            broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            start_time (str): Start time for the scheduled broadcast specified in RFC3339 format
            timezone (str): The timezone of the application creating the scheduled broadcast using the IANA time zone database format
            is_recurring (bool): Indicates if the scheduled broadcast is recurring weekly
            duration (int, optional): Duration of the scheduled broadcast in minutes from the start_time
                                      Default: 240
            category_id (str, optional): Game/Category ID for the scheduled broadcast
            title (str, optional): Title for the scheduled broadcast
                                   Maximum: 140 characters

        Raises:
            twitchpy.errors.ClientError

        Returns:
            StreamSchedule
        &#34;&#34;&#34;

        url = ENDPOINT_SCHEDULE_SEGMENT
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;start_time&#34;: start_time,
            &#34;timezone&#34;: timezone,
            &#34;is_recurring&#34;: is_recurring,
        }

        if duration != 240:
            payload[&#34;duration&#34;] = duration

        if category_id != &#34;&#34;:
            payload[&#34;category_id&#34;] = category_id

        if title != &#34;&#34;:
            payload[&#34;title&#34;] = title

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            schedule = response.json()[&#34;data&#34;][0]
            schedule = StreamSchedule(
                schedule[&#34;segments&#34;],
                schedule[&#34;broadcaster_id&#34;],
                schedule[&#34;broadcaster_name&#34;],
                schedule[&#34;broadcaster_login&#34;],
                schedule[&#34;vacation&#34;],
            )

            return schedule

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_channel_stream_schedule_segment(
        self,
        broadcaster_id,
        id,
        start_time=&#34;&#34;,
        duration=240,
        category_id=&#34;&#34;,
        title=&#34;&#34;,
        is_canceled=False,
        timezone=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Update a single scheduled broadcast or a recurring scheduled broadcast for a channel’s stream schedule

        Args:
            broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (str): The ID of the streaming segment to update
            start_time (str, optional): Start time for the scheduled broadcast specified in RFC3339 format
            duration (int, optional): Duration of the scheduled broadcast in minutes from the start_time
                                      Default: 240
            category_id (str, optional): Game/Category ID for the scheduled broadcast
            title (str, optional): Title for the scheduled broadcast
                                   Maximum: 140 characters
            is_canceled (bool, optional): Indicated if the scheduled broadcast is canceled
            timezone (str, optional): The timezone of the application creating the scheduled broadcast using the IANA time zone database format

        Raises:
            twitchpy.errors.ClientError

        Returns:
            StreamSchedule
        &#34;&#34;&#34;

        url = ENDPOINT_SCHEDULE_SEGMENT
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id}

        if start_time != &#34;&#34;:
            data[&#34;start_time&#34;] = start_time

        if duration != 240:
            data[&#34;duration&#34;] = duration

        if category_id != &#34;&#34;:
            data[&#34;category_id&#34;] = category_id

        if title != &#34;&#34;:
            data[&#34;title&#34;] = title

        if is_canceled is not False:
            data[&#34;is_canceled&#34;] = is_canceled

        if timezone != &#34;&#34;:
            data[&#34;timezone&#34;] = timezone

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            schedule = response.json()[&#34;data&#34;][0]
            schedule = StreamSchedule(
                schedule[&#34;segments&#34;],
                schedule[&#34;broadcaster_id&#34;],
                schedule[&#34;broadcaster_name&#34;],
                schedule[&#34;broadcaster_login&#34;],
                schedule[&#34;vacation&#34;],
            )

            return schedule

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def delete_channel_stream_schedule_segment(self, broadcaster_id, id):
        &#34;&#34;&#34;
        Delete a single scheduled broadcast or a recurring scheduled broadcast for a channel’s stream schedule

        Args:
            broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (str): The ID of the streaming segment to delete
        &#34;&#34;&#34;

        url = ENDPOINT_SCHEDULE_SEGMENT
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id}

        requests.delete(url, headers=headers, data=data)

    def search_categories(self, query, first=20):
        &#34;&#34;&#34;
        Returns a list of games or categories that match the query via name either entirely or partially

        Args:
            query (str): URI encoded search query
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/search/categories&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;query&#34;: query}

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        games = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for game in response[&#34;data&#34;]:
                    games.append(
                        Game(game[&#34;id&#34;], game[&#34;name&#34;], box_art_url=game[&#34;box_art_url&#34;])
                    )

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return games

    def search_channels(
        self, query: str, first: int = 20, live_only: bool = False
    ) -&gt; list[Channel]:
        &#34;&#34;&#34;
        Gets the channels that match the specified query and have streamed content within the past 6 months
        To match, the beginning of the broadcaster’s name or category must match the query string

        Args:
            query (str): The URI-encoded search string
            first (int): The maximum number of items to return
                Minimum: 1
            live_only (bool): A Boolean value that determines whether the response includes only channels that are currently streaming live

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Channel]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/search/channels&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;query&#34;: query}

        if live_only is not False:
            params[&#34;live_only&#34;] = live_only

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        channels = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for channel in response[&#34;data&#34;]:
                    channels.append(
                        Channel(
                            channel[&#34;id&#34;],
                            channel[&#34;broadcaster_login&#34;],
                            channel[&#34;display_name&#34;],
                            channel[&#34;game_id&#34;],
                            channel[&#34;game_name&#34;],
                            channel[&#34;title&#34;],
                            broadcaster_language=channel[&#34;broadcaster_language&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return channels

    def get_stream_key(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets the channel stream key for a user

        Args:
            broadcaster_id (str): User ID of the broadcaster

        Raises:
            twitchpy.errors.ClientError

        Returns:
            str
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/streams/key&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0][&#34;stream_key&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_streams(
        self,
        user_id: str | list[str] = &#34;&#34;,
        user_login: str | list[str] = &#34;&#34;,
        game_id: str | list[str] = &#34;&#34;,
        type: str = &#34;all&#34;,
        language: str | list[str] = &#34;&#34;,
        first: int = 20,
    ) -&gt; list[Stream]:
        &#34;&#34;&#34;
        Gets a list of all streams
        The list is in descending order by the number of viewers watching the stream

        Args:
            user_id (str | list[str]): A user ID used to filter the list of streams
                Maximum: 100
            user_login (str | list[str]): A user login name used to filter the list of streams
                Maximum: 100
            game_id (str | list[str]): A game (category) ID used to filter the list of streams
                Maximum: 100
            type (str): The type of stream to filter the list of streams by
                Possible values: all, live
            language (str | list[str]): A language code used to filter the list of streams
                Maximum: 100
            first (int): The maximum number of items to return
                Minimum: 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Stream]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/streams&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        if user_login != &#34;&#34;:
            params[&#34;user_login&#34;] = user_login

        if game_id != &#34;&#34;:
            params[&#34;game_id&#34;] = game_id

        if type != &#34;all&#34;:
            params[&#34;type&#34;] = type

        if language != &#34;&#34;:
            params[&#34;language&#34;] = language

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        streams = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for stream in response[&#34;data&#34;]:
                    streams.append(
                        Stream(
                            stream[&#34;id&#34;],
                            stream[&#34;user_id&#34;],
                            stream[&#34;user_login&#34;],
                            stream[&#34;user_name&#34;],
                            stream[&#34;game_id&#34;],
                            stream[&#34;game_name&#34;],
                            stream[&#34;type&#34;],
                            stream[&#34;title&#34;],
                            stream[&#34;tags&#34;],
                            stream[&#34;viewer_count&#34;],
                            stream[&#34;started_at&#34;],
                            stream[&#34;language&#34;],
                            stream[&#34;thumbnail_url&#34;],
                            stream[&#34;is_mature&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return streams

    def get_followed_streams(self, user_id: str, first: int = 100) -&gt; list[Stream]:
        &#34;&#34;&#34;
        Gets the list of broadcasters that the user follows and that are streaming live

        Args:
            user_id (str): The ID of the user whose list of followed streams you want to get
                This ID must match the user ID in the access token
            first (int): The maximum number of items to return
                Minimum: 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Stream]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/streams/followed&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;user_id&#34;: user_id}

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        streams = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for stream in response[&#34;data&#34;]:
                    streams.append(
                        Stream(
                            stream[&#34;id&#34;],
                            stream[&#34;user_id&#34;],
                            stream[&#34;user_login&#34;],
                            stream[&#34;user_name&#34;],
                            stream[&#34;game_id&#34;],
                            stream[&#34;game_name&#34;],
                            stream[&#34;type&#34;],
                            stream[&#34;title&#34;],
                            stream[&#34;tags&#34;],
                            stream[&#34;viewer_count&#34;],
                            stream[&#34;started_at&#34;],
                            stream[&#34;language&#34;],
                            stream[&#34;thumbnail_url&#34;],
                            stream[&#34;is_mature&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return streams

    def create_stream_marker(self, user_id, description=&#34;&#34;):
        &#34;&#34;&#34;
        Creates a marker in the stream of a user specified by user ID
        A marker is an arbitrary point in a stream that the broadcaster wants to mark; e.g., to easily return to later
        The marker is created at the current timestamp in the live broadcast when the request is processed

        Args:
            user_id (str): ID of the broadcaster in whose live stream the marker is created
            description (str, optional): Description of or comments on the marker
                                         Max length is 140 characters

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/streams/markers&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {&#34;user_id&#34;: user_id}

        if description != &#34;&#34;:
            payload[&#34;description&#34;] = description

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_stream_markers(self, user_id=&#34;&#34;, video_id=&#34;&#34;, first=20):
        &#34;&#34;&#34;
        Gets a list of markers for either a specified user’s most recent stream or a specified VOD/video (stream)
        A marker is an arbitrary point in a stream that the broadcaster wants to mark; e.g., to easily return to later
        The only markers returned are those created by the user identified by the Bearer token
        Only one of user_id and video_id must be specified

        Args:
            user_id (str, optional): ID of the broadcaster from whose stream markers are returned
            video_id (str, optional): ID of the VOD/video whose stream markers are returned
            first (int, optional): Number of values to be returned when getting videos by user or game ID
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/streams/markers&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        if video_id != &#34;&#34;:
            params[&#34;video_id&#34;] = video_id

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        markers = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                markers.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return markers

    def get_broadcaster_subscriptions(self, broadcaster_id, user_id=[], first=20):
        &#34;&#34;&#34;
        Get all of a broadcaster’s subscriptions

        Args:
            broadcaster_id (str): User ID of the broadcaster
                                  Must match the User ID in the Bearer token
            user_id (list, optional): Filters results to only include potential subscriptions made by the provided user ID
                                      Accepts up to 100 values
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/subscriptions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(user_id) &gt; 0:
            params[&#34;user_id&#34;] = user_id

        if first != 20:
            params[&#34;first&#34;] = first

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        subscriptions = []

        for call in range(calls):
            if first - (100 * call) &gt; 100:
                params[&#34;first&#34;] = 100

            else:
                params[&#34;first&#34;] = first - (100 * call)

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                subscriptions.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return subscriptions

    def check_user_subscription(self, broadcaster_id, user_id):
        &#34;&#34;&#34;
        Checks if a specific user (user_id) is subscribed to a specific channel (broadcaster_id)

        Args:
            broadcaster_id (str): User ID of an Affiliate or Partner broadcaster
            user_id (str): User ID of a Twitch viewer

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/subscriptions/user&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;user_id&#34;: user_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_all_stream_tags(self, first=20, tag_id=[]):
        &#34;&#34;&#34;
        Gets the list of all stream tags defined by Twitch

        Args:
            first (int, optional): Maximum number of objects to return
                                   Default: 20
            tag_id (list, optional): ID of a tag

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/tags/streams&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if len(tag_id) &gt; 0:
            params[&#34;tag_id&#34;] = tag_id

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        tags = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for tag in response[&#34;data&#34;]:
                    tags.append(
                        Tag(
                            tag[&#34;tag_id&#34;],
                            tag[&#34;is_auto&#34;],
                            tag[&#34;localization_names&#34;],
                            tag[&#34;localization_descriptions&#34;],
                        )
                    )

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return tags

    def get_stream_tags(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets the list of current stream tags that have been set for a channel

        Args:
            broadcaster_id (str): User ID of the channel to get tags

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/streams/tags&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()
            tags = []

            for tag in response[&#34;data&#34;]:
                tags.append(
                    Tag(
                        tag[&#34;tag_id&#34;],
                        tag[&#34;is_auto&#34;],
                        tag[&#34;localization_names&#34;],
                        tag[&#34;localization_descriptions&#34;],
                    )
                )

            return tags

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_channel_teams(self, broadcaster_id):
        &#34;&#34;&#34;
        Retrieves a list of Twitch Teams of which the specified channel/broadcaster is a member

        Args:
            broadcaster_id (str): User ID for a Twitch user

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/teams/channel&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            teams = []

            for team in response.json()[&#34;data&#34;]:
                teams.append(self.get_teams(id=team[&#34;id&#34;]))

            return teams

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_teams(self, name=&#34;&#34;, id=&#34;&#34;):
        &#34;&#34;&#34;
        Gets information for a specific Twitch Team
        One of the two optional query parameters must be specified to return Team information

        Args:
            name (str, optional): Team name
            id (str, optional): Team ID

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Team
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/teams&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if name != &#34;&#34;:
            params[&#34;name&#34;] = name

        if id != &#34;&#34;:
            params[&#34;id&#34;] = id

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            team = response.json()[&#34;data&#34;][0]
            users = []

            for user in team[&#34;users&#34;]:
                users.append(
                    User(user[&#34;user_id&#34;], user[&#34;user_login&#34;], user[&#34;user_name&#34;])
                )

            team = Team(
                users,
                team[&#34;background_image_url&#34;],
                team[&#34;banner&#34;],
                team[&#34;created_at&#34;],
                team[&#34;updated_at&#34;],
                team[&#34;info&#34;],
                team[&#34;thumbnail_url&#34;],
                team[&#34;team_name&#34;],
                team[&#34;team_display_name&#34;],
                team[&#34;id&#34;],
            )

            return team

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_users(self, id=[], login=[]):
        &#34;&#34;&#34;
        Gets an user
        Users are identified by optional user IDs and/or login name
        If neither a user ID nor a login name is specified, the user is looked up by Bearer token

        Args:
            id (list, optional): User ID
                                 Limit: 100
            login (list, optional): User login name
                                    Limit: 100

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/users&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if len(login) &gt; 0:
            aux = []

            for i in range(len(login)):
                aux.append(login[i].replace(&#34;@&#34;, &#34;&#34;).lower())

            params[&#34;login&#34;] = aux

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            users = []

            for user in response.json()[&#34;data&#34;]:
                users.append(
                    User(
                        user[&#34;id&#34;],
                        user[&#34;login&#34;],
                        user[&#34;display_name&#34;],
                        user[&#34;type&#34;],
                        user[&#34;broadcaster_type&#34;],
                        user[&#34;description&#34;],
                        user[&#34;profile_image_url&#34;],
                        user[&#34;offline_image_url&#34;],
                        user[&#34;view_count&#34;],
                    )
                )

            return users

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_user(self, description=&#34;&#34;):
        &#34;&#34;&#34;
        Updates the description of a user specified by the bearer token
        If the description parameter is not provided, no update will occur and the current user data is returned

        Args:
            description (str, optional): User’s account description

        Raises:
            twitchpy.errors.ClientError

        Returns:
            User
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/users&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {}

        if description != &#34;&#34;:
            data = {&#34;description&#34;: description}

        response = requests.put(url, headers=headers, data=data)

        if response.ok:
            user = response.json()[&#34;data&#34;][0]
            user = User(
                user[&#34;id&#34;],
                user[&#34;login&#34;],
                user[&#34;display_name&#34;],
                user[&#34;type&#34;],
                user[&#34;broadcaster_type&#34;],
                user[&#34;description&#34;],
                user[&#34;profile_image_url&#34;],
                user[&#34;offline_image_url&#34;],
                user[&#34;view_count&#34;],
            )

            return user

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_user_block_list(self, broadcaster_id, first=20):
        &#34;&#34;&#34;
        Gets a specified user’s block list

        Args:
            broadcaster_id (str): User ID for a Twitch user
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = ENDPOINT_USER_BLOCKS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if first != 20:
            params[&#34;first&#34;] = first

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        ids = []

        for call in range(calls):
            if first - (100 * call) &gt; 100:
                params[&#34;first&#34;] = 100

            else:
                params[&#34;first&#34;] = first - (100 * call)

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                for user in response.json()[&#34;data&#34;]:
                    ids.append(user[&#34;user_id&#34;])

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return self.get_users(id=ids)

    def block_user(self, target_user_id, source_context=&#34;&#34;, reason=&#34;&#34;):
        &#34;&#34;&#34;
        Blocks the specified user on behalf of the authenticated user

        Args:
            target_user_id (str): User ID of the user to be blocked
            source_context (str, optional): Source context for blocking the user
                                            Valid values: &#34;chat&#34;, &#34;whisper&#34;
            reason (str, optional): Reason for blocking the user
                                    Valid values: &#34;spam&#34;, &#34;harassment&#34;, or &#34;other&#34;
        &#34;&#34;&#34;

        url = ENDPOINT_USER_BLOCKS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;target_user_id&#34;: target_user_id}

        if source_context != &#34;&#34;:
            data[&#34;source_context&#34;] = source_context

        if reason != &#34;&#34;:
            data[&#34;reason&#34;] = reason

        requests.put(url, headers=headers, data=data)

    def unblock_user(self, target_user_id):
        &#34;&#34;&#34;
        Unblocks the specified user on behalf of the authenticated user

        Args:
            target_user_id (str): User ID of the user to be unblocked
        &#34;&#34;&#34;

        url = ENDPOINT_USER_BLOCKS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;target_user_id&#34;: target_user_id}

        requests.delete(url, headers=headers, data=data)

    def get_user_extensions(self):
        &#34;&#34;&#34;
        Gets a list of all extensions (both active and inactive) for a specified user, identified by a Bearer token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/users/extensions/list&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }

        response = requests.get(url, headers=headers)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_user_active_extensions(self, user_id=&#34;&#34;):
        &#34;&#34;&#34;
        Gets information about active extensions installed by a specified user, identified by a user ID or Bearer token

        Args:
            user_id (str, optional): ID of the user whose installed extensions will be returned

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/users/extensions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if user_id != &#34;&#34;:
            params = {&#34;user_id&#34;: user_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_user_extensions(self):
        &#34;&#34;&#34;
        Updates the activation state, extension ID, and/or version number of installed extensions for a specified user, identified by a Bearer token
        If you try to activate a given extension under multiple extension types, the last write wins (and there is no guarantee of write order)

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/users/extensions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }

        response = requests.put(url, headers=headers)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_videos(
        self,
        id=[],
        user_id=&#34;&#34;,
        game_id=&#34;&#34;,
        first=20,
        language=&#34;&#34;,
        period=&#34;all&#34;,
        sort=&#34;time&#34;,
        type=&#34;all&#34;,
    ):
        &#34;&#34;&#34;
        Gets video information by video ID, user ID, or game ID
        Each request must specify one video id, one user_id, or one game_id

        Args:
            id (list): ID of the video being queried
                       Limit: 100
                       If this is specified, you cannot use first, language, period, sort and type
            user_id (str): ID of the user who owns the video
            game_id (str): ID of the game the video is of
            first (int, optional): Number of values to be returned when getting videos by user or game ID
                                   Default: 20
            language (str, optional): Language of the video being queried
                                      A language value must be either the ISO 639-1 two-letter code for a supported stream language or &#34;other&#34;
            period (str, optional): Period during which the video was created
                                    Valid values: &#34;all&#34;, &#34;day&#34;, &#34;week&#34;, &#34;month&#34;
            sort (str, optional): Sort order of the videos
                                  Valid values: &#34;time&#34;, &#34;trending&#34;, &#34;views&#34;
                                  Default: &#34;time&#34;
            type (str, optional): Type of video
                                  Valid values: &#34;all&#34;, &#34;upload&#34;, &#34;archive&#34;, &#34;highlight&#34;
                                  Default: &#34;all&#34;

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/videos&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        if game_id != &#34;&#34;:
            params[&#34;game_id&#34;] = game_id

        if language != &#34;&#34;:
            params[&#34;language&#34;] = language

        if period != &#34;all&#34;:
            params[&#34;period&#34;] = period

        if sort != &#34;time&#34;:
            params[&#34;sort&#34;] = sort

        if type != &#34;all&#34;:
            params[&#34;type&#34;] = type

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        videos = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for video in response[&#34;data&#34;]:
                    videos.append(
                        Video(
                            video[&#34;id&#34;],
                            video[&#34;user_id&#34;],
                            video[&#34;user_name&#34;],
                            video[&#34;title&#34;],
                            video[&#34;description&#34;],
                            video[&#34;created_at&#34;],
                            video[&#34;published_at&#34;],
                            video[&#34;url&#34;],
                            video[&#34;thumbnail_url&#34;],
                            video[&#34;viewable&#34;],
                            video[&#34;view_count&#34;],
                            video[&#34;language&#34;],
                            video[&#34;type&#34;],
                            video[&#34;duration&#34;],
                        )
                    )

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return videos

    def delete_video(self, id):
        &#34;&#34;&#34;
        Deletes a video
        Videos are past broadcasts, Highlights, or uploads

        Args:
            id (str): ID of the video(s) to be deleted
                      Limit: 5
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/videos&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;id&#34;: id}

        requests.delete(url, headers=headers, data=data)

    def send_whisper(self, from_user_id: str, to_user_id: str, message: str) -&gt; None:
        &#34;&#34;&#34;
        Sends a whisper message to the specified use

        Args:
            from_user_id (str): The ID of the user sending the whisper
                This user must have a verified phone number
                This ID must match the user ID in the user access token
            to_user_id (str): The ID of the user to receive the whisper
            message (str): The whisper message to send
                Maximum length: 500 characters if the user you&#39;re sending the message to hasn&#39;t whispered you before or 10,000 characters if the user you&#39;re sending the message to has whispered you before
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/whispers&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {
            &#34;from_user_id&#34;: from_user_id,
            &#34;to_user_id&#34;: to_user_id,
            &#34;message&#34;: message,
        }

        requests.post(url, headers=headers, json=payload)

    def get_webhook_subscriptions(self, first=20):
        &#34;&#34;&#34;
        Gets the Webhook subscriptions of an application identified by a Bearer token, in order of expiration

        Args:
            first (int, optional): Number of values to be returned
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/webhooks/subscriptions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if first != 20:
            params = {&#34;first&#34;: first}

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        subscriptions = []

        for call in range(calls):
            if first - (100 * call) &gt; 100:
                params[&#34;first&#34;] = 100

            else:
                params[&#34;first&#34;] = first - (100 * call)

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                subscriptions.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return subscriptions</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="twitchpy.client.Client"><code class="flex name class">
<span>class <span class="ident">Client</span></span>
<span>(</span><span>oauth_token, client_id, client_secret, redirect_uri, tokens_path, code='', jwt_token='')</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a client connection to the Twitch API</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>oauth_token</code></strong> :&ensp;<code>str</code></dt>
<dd>OAuth Token</dd>
<dt><strong><code>client_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Client ID</dd>
<dt><strong><code>client_secret</code></strong> :&ensp;<code>str</code></dt>
<dd>Client secret</dd>
<dt><strong><code>redirect_uri</code></strong> :&ensp;<code>str</code></dt>
<dd>Redirect URI</dd>
<dt><strong><code>tokens_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path of tokens file (file included)</dd>
<dt><strong><code>code</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Authorization code for getting an user token</dd>
<dt><strong><code>jwt_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>JWT Token</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Client:
    &#34;&#34;&#34;
    Represents a client connection to the Twitch API
    &#34;&#34;&#34;

    def __init__(
        self,
        oauth_token,
        client_id,
        client_secret,
        redirect_uri,
        tokens_path,
        code=&#34;&#34;,
        jwt_token=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Args:
            oauth_token (str): OAuth Token
            client_id (str): Client ID
            client_secret (str): Client secret
            redirect_uri (str): Redirect URI
            tokens_path (str): Path of tokens file (file included)
            code (str, optional): Authorization code for getting an user token
            jwt_token (str, optional): JWT Token
        &#34;&#34;&#34;

        self.oauth_token = oauth_token
        self.client_id = client_id
        self.client_secret = client_secret
        self.redirect_uri = redirect_uri
        self.tokens_path = tokens_path
        self.__app_token = self.__get_app_token()

        if code != &#34;&#34;:
            self.__user_token = self.__get_user_token(code)

        else:
            self.__user_token = &#34;&#34;

        self.__jwt_token = jwt_token

    def __get_app_token(self):
        url = URL_OAUTH2_TOKEN
        payload = {
            &#34;client_id&#34;: self.client_id,
            &#34;client_secret&#34;: self.client_secret,
            &#34;grant_type&#34;: &#34;client_credentials&#34;,
        }

        response = requests.post(url, json=payload)

        if response.ok:
            return response.json()[&#34;access_token&#34;]

        else:
            raise twitchpy.errors.AppTokenError(&#34;Error obtaining app token&#34;)

    def __is_last_code_used(self, code):
        try:
            tokens_file = open(self.tokens_path)
            tokens = tokens_file.readlines()
            tokens_file.close()

        except Exception:
            return False

        for token in tokens:
            token = token.replace(&#34; &#34;, &#34;&#34;).replace(&#34;\n&#34;, &#34;&#34;)
            token = token.split(&#34;=&#34;)

            if token[0] == &#34;CODE&#34; and token[1] == code:
                return True

        return False

    def __read_user_tokens_from_file(self, file):
        try:
            secret_file = open(file, &#34;rt&#34;)
            data = secret_file.readlines()
            secret_file.close()

        except Exception as error:
            logging.exception(&#34;Error reading tokens&#34;)
            raise error

        user_token = &#34;&#34;
        refresh_user_token = &#34;&#34;

        for i in range(len(data)):
            secret = data[i].split(&#34;=&#34;)

            if &#34;USER_TOKEN&#34; == secret[0]:
                user_token = secret[1].replace(&#34;\n&#34;, &#34;&#34;)

            if &#34;REFRESH_USER_TOKEN&#34; == secret[0]:
                refresh_user_token = secret[1].replace(&#34;\n&#34;, &#34;&#34;)

        return user_token, refresh_user_token

    def __save_user_tokens_in_file(self, file, user_token, user_refresh_token, code):
        data = f&#34;USER_TOKEN={user_token}\nREFRESH_USER_TOKEN={user_refresh_token}\nCODE={code}&#34;

        secret_file = open(file, &#34;wt&#34;)
        secret_file.write(data)
        secret_file.close()

    def __generate_user_tokens(self, code, file):
        url = URL_OAUTH2_TOKEN
        payload = {
            &#34;client_id&#34;: self.client_id,
            &#34;client_secret&#34;: self.client_secret,
            &#34;code&#34;: code,
            &#34;grant_type&#34;: &#34;authorization_code&#34;,
            &#34;redirect_uri&#34;: self.redirect_uri,
        }

        response = requests.post(url, payload)

        if response.ok:
            response = response.json()
            self.__save_user_tokens_in_file(
                file, response[&#34;access_token&#34;], response[&#34;refresh_token&#34;], code
            )

            return response[&#34;access_token&#34;], response[&#34;refresh_token&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def __refresh_user_tokens(self, refresh_user_token):
        url = URL_OAUTH2_TOKEN
        payload = {
            &#34;grant_type&#34;: &#34;refresh_token&#34;,
            &#34;refresh_token&#34;: refresh_user_token,
            &#34;client_id&#34;: self.client_id,
            &#34;client_secret&#34;: self.client_secret,
        }

        response = requests.post(url, json=payload)

        if response.ok:
            response = response.json()
            return response[&#34;access_token&#34;], response[&#34;refresh_token&#34;]

        else:
            raise twitchpy.errors.UserTokenError(&#34;Error obtaining user token&#34;)

    def __get_user_token(self, code):
        if self.__is_last_code_used(code) or (
            not self.__is_last_code_used(code) and os.path.isfile(self.tokens_path)
        ):
            user_token, refresh_user_token = self.__read_user_tokens_from_file(
                self.tokens_path
            )
            user_token, refresh_user_token = self.__refresh_user_tokens(
                refresh_user_token
            )
            self.__save_user_tokens_in_file(
                self.tokens_path, user_token, refresh_user_token, code
            )

        else:
            user_token, refresh_user_token = self.__generate_user_tokens(
                code, self.tokens_path
            )

        return user_token

    def start_commercial(self, broadcaster_id, length):
        &#34;&#34;&#34;
        Starts a commercial on a specified channel

        Args:
            broadcaster_id (int): ID of the channel requesting a commercial
            length (int): Desired length of the commercial in seconds
                          Valid options are 30, 60, 90, 120, 150 and 180

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels/commercial&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;length&#34;: length}

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            response = response.json()
            return response[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_ad_schedule(self, broadcaster_id: str) -&gt; dict:
        &#34;&#34;&#34;
        Returns ad schedule related information, including snooze, when the last ad was run, when the next ad is scheduled, and if the channel is currently in pre-roll free time

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels/ads&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def snooze_next_ad(self, broadcaster_id) -&gt; dict:
        &#34;&#34;&#34;
        If available, pushes back the timestamp of the upcoming automatic mid-roll ad by 5 minutes

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels/ads/schedule/snooze&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_extension_analytics(
        self, ended_at=&#34;&#34;, extension_id=&#34;&#34;, first=20, started_at=&#34;&#34;, type=&#34;&#34;
    ):
        &#34;&#34;&#34;
        Gets a URL that Extension developers can use to download analytics reports for their Extensions
        The URL is valid for 5 minutes

        Args:
            ended_at (str, optional): Ending date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
                                      If this is provided, started_at also must be specified
            extension_id (str, optional): Client ID value assigned to the extension when it is created
            first (int, optional): Maximum number of objects to return
                                   Default: 20
            started_at (str, optional): Starting date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
                                        This must be on or after January 31, 2018
                                        If this is provided, ended_at also must be specified
            type (str, optional): Type of analytics report that is returned
                                  Valid values: &#34;overview_v2&#34;

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/analytics/extensions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if ended_at != &#34;&#34;:
            params[&#34;ended_at&#34;] = ended_at

        if extension_id != &#34;&#34;:
            params[&#34;extension_id&#34;] = extension_id

        if started_at != &#34;&#34;:
            params[&#34;started_at&#34;] = started_at

        if type != &#34;&#34;:
            params[&#34;type&#34;] = type

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        extension_analytics = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                extension_analytics.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return extension_analytics

    def get_game_analytics(
        self, ended_at=&#34;&#34;, first=20, game_id=&#34;&#34;, started_at=&#34;&#34;, type=&#34;&#34;
    ):
        &#34;&#34;&#34;
        Gets a URL that game developers can use to download analytics reports for their games
        The URL is valid for 5 minutes

        Args:
            ended_at (str, optional): Ending date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
                                      If this is provided, started_at also must be specified
            first (int, optional): Maximum number of objects to return
                                   Default: 20
            game_id (str, optional): Game ID
            started_at (str, optional): Starting date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
                                        If this is provided, ended_at also must be specified
            type (str, optional): Type of analytics report that is returned
                                  Valid values: &#34;overview_v2&#34;

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/analytics/games&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if ended_at != &#34;&#34;:
            params[&#34;ended_at&#34;] = ended_at

        if game_id != &#34;&#34;:
            params[&#34;game_id&#34;] = game_id

        if started_at != &#34;&#34;:
            params[&#34;started_at&#34;] = started_at

        if type != &#34;&#34;:
            params[&#34;type&#34;] = type

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        game_analytics = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                game_analytics.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return game_analytics

    def get_bits_leaderboard(self, count=10, period=&#34;all&#34;, started_at=&#34;&#34;, user_id=&#34;&#34;):
        &#34;&#34;&#34;
        Gets a ranked list of Bits leaderboard information for a broadcaster

        Args:
            count (int, optional): Number of results to be returned
                                   Maximum: 100
                                   Default: 10
            period (str, optional): Time period over which data is aggregated (PST time zone)
                                    This parameter interacts with started_at
                                    Default: &#34;all&#34;
                                    Valid values: &#34;day&#34;, &#34;week&#34;, &#34;month&#34;, &#34;year&#34;, &#34;all&#34;
            started_at (str, optional): Timestamp for the period over which the returned data is aggregated
                                        Must be in RFC 3339 format
                                        This value is ignored if period is &#34;all&#34;
            user_id (str, optional): ID of the user whose results are returned
                                     As long as count is greater than 1, the returned data includes additional users, with Bits amounts above and below the user specified

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/bits/leaderboard&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if count != 10:
            params[&#34;count&#34;] = count

        if period != &#34;all&#34;:
            params[&#34;period&#34;] = period

        if started_at != &#34;&#34;:
            params[&#34;started_at&#34;] = started_at

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_cheermotes(self, broadcaster_id=&#34;&#34;):
        &#34;&#34;&#34;
        Retrieves the list of available Cheermotes
        Cheermotes returned are available throughout Twitch, in all Bits-enabled channels

        Args:
            broadcaster_id (str, optional): ID for the broadcaster who might own specialized Cheermotes

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/bits/cheermotes&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if broadcaster_id != &#34;&#34;:
            params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_extension_transactions(self, extension_id, id=[], first=20):
        &#34;&#34;&#34;
        Allows extension back-end servers to fetch a list of transactions that have occurred for their extension across all of Twitch
        A transaction is a record of a user exchanging Bits for an in-Extension digital good

        Args:
            extension_id (str): ID of the extension to list transactions for
            id (list, optional): Transaction IDs to look up
                                 Maximum: 100
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/transactions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;extension_id&#34;: extension_id}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if first != 20:
            params[&#34;first&#34;] = first

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        extension_transactions = []

        for call in range(calls):
            if first - (100 * call) &gt; 100:
                params[&#34;first&#34;] = 100

            else:
                params[&#34;first&#34;] = first - (100 * call)

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                extension_transactions.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return extension_transactions

    def get_channel(self, broadcaster_id: str | list[str]) -&gt; Channel:
        &#34;&#34;&#34;
        Gets one or more channels

        Args:
            broadcaster_id (str | list[str]): The ID of the broadcaster whose channel you want to get
                Maximum: 100

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Channel
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token if self.__user_token != &#39;&#39; else self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            channel = response.json()[&#34;data&#34;][0]
            channel = Channel(
                channel[&#34;broadcaster_id&#34;],
                channel[&#34;broadcaster_login&#34;],
                channel[&#34;broadcaster_name&#34;],
                channel[&#34;broadcaster_language&#34;],
                channel[&#34;game_name&#34;],
                channel[&#34;game_id&#34;],
                channel[&#34;title&#34;],
                channel[&#34;delay&#34;],
                channel[&#34;tags&#34;],
                channel[&#34;content_classification_labels&#34;],
                channel[&#34;is_branded_content&#34;],
            )

            return channel

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def modify_channel_information(
        self,
        broadcaster_id: str,
        game_id: str = None,
        broadcaster_language: str = None,
        title: str = None,
        delay: int = None,
        tags: list[str] = [],
        content_classification_labels: list[dict] = [],
        is_branded_content: bool = None,
    ):
        &#34;&#34;&#34;
        Updates a channel’s properties

        Args:
            broadcaster_id (str): The ID of the broadcaster whose channel you want to update
                ID must match the user ID in the user access token
            game_id (str): The ID of the game that the user plays
            broadcaster_language (str): The user’s preferred language
                Set the value to an ISO 639-1 two-letter language code
                Set to “other” if the user’s preferred language is not a Twitch supported language
            title (str): The title of the user’s stream
            delay (int): The number of seconds you want your broadcast buffered before streaming it live
                Only users with Partner status may set this field
                Maximum: 900 seconds
            tags (list[str]): A list of channel-defined tags to apply to the channel
                Maximum: 10
            content_classification_labels (list[dict]): List of labels that should be set as the Channel’s CCLs
            is_branded_content (bool): Boolean flag indicating if the channel has branded content
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id}

        if game_id is not None:
            data[&#34;game_id&#34;] = game_id

        if broadcaster_language is not None:
            data[&#34;broadcaster_language&#34;] = broadcaster_language

        if title is not None:
            data[&#34;title&#34;] = title

        if delay is not None:
            data[&#34;delay&#34;] = delay

        if len(tags) &gt; 0:
            data[&#34;tags&#34;] = tags

        if len(content_classification_labels) &gt; 0:
            data[&#34;content_classification_labels&#34;] = content_classification_labels

        if is_branded_content is not None:
            data[&#34;is_branded_content&#34;] = is_branded_content

        requests.patch(url, headers=headers, data=data)

    def get_channel_editors(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets a list of users who have editor permissions for a specific channel

        Args:
            broadcaster_id (str): Broadcaster’s user ID associated with the channel

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels/editors&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            ids = []

            for user in response.json()[&#34;data&#34;]:
                ids.append(user[&#34;user_id&#34;])

            users = self.get_users(id=ids)

            return users

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_followed_channels(
        self, user_id: str, broadcaster_id: str = &#34;&#34;, first: int = 20
    ) -&gt; list[Channel]:
        &#34;&#34;&#34;
        Gets a list of broadcasters that the specified user follows

        Args:
            user_id (str): A user’s ID
                Returns the list of broadcasters that this user follows
                This ID must match the user ID in the user OAuth token
            broadcaster_id (str): A broadcaster’s ID
                Use this parameter to see whether the user follows this broadcaster
            first (int): The maximum number of items to return
                Default: 20
                Minimum: 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Channel]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels/followed&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;user_id&#34;: user_id}

        if broadcaster_id != &#34;&#34;:
            params[&#34;broadcaster_id&#34;] = broadcaster_id

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        channels = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                channels.append(
                    self.get_channel(
                        [channel[&#34;broadcaster_id&#34;] for channel in response[&#34;data&#34;]]
                    )
                )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return channels

    def get_channel_followers(
        self, broadcaster_id: str, user_id: str = &#34;&#34;, first: int = 20
    ) -&gt; list[Channel]:
        &#34;&#34;&#34;
        The function `get_channel_followers` retrieves a list of channels that are following a specific
        broadcaster on Twitch.

        Args:
            broadcaster_id (str): The broadcaster’s ID
                Returns the list of users that follow this broadcaster
            user_id (str): A user’s ID
                Use this parameter to see whether the user follows this broadcaster
            first (int): The maximum number of items to return
                Default: 20
                Minimum: 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Channel]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channels/followers&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        channels = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                channels.append(
                    self.get_channel(
                        [channel[&#34;user_id&#34;] for channel in response[&#34;data&#34;]]
                    )
                )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return channels

    def create_custom_reward(
        self,
        broadcaster_id,
        title,
        cost,
        prompt=&#34;&#34;,
        is_enabled=True,
        background_color=&#34;&#34;,
        is_user_input_required=False,
        is_max_per_stream_enabled=False,
        max_per_stream=None,
        is_max_per_user_per_stream_enabled=False,
        max_per_user_per_stream=None,
        is_global_cooldown_enabled=False,
        global_cooldown_seconds=None,
        should_redemptions_skip_request_queue=False,
    ):
        &#34;&#34;&#34;
        Creates a Custom Reward on a channel

        Args:
            broadcaster_id (str): ID of the channel creating a reward
            title (str): The title of the reward
            cost (int): The cost of the reward
            prompt (str, optional): The prompt for the viewer when they are redeeming the reward
            is_enabled (bool, optional): Is the reward currently enabled, if false the reward won’t show up to viewers
                                         Default: true
            background_color (str, optional): Custom background color for the reward
                                              Format: Hex with # prefix
            is_user_input_required (bool, optional): Does the user need to enter information when redeeming the reward
                                                     Default: false
            is_max_per_stream_enabled (bool, optional): Whether a maximum per stream is enabled
                                                        Default: false
            max_per_stream (int, optional): The maximum number per stream if enabled
                                            Required when any value of is_max_per_stream_enabled is included
            is_max_per_user_per_stream_enabled (bool, optional): Whether a maximum per user per stream is enabled
                                                                 Default: false
            max_per_user_per_stream (int, optional): The maximum number per user per stream if enabled
                                                     Required when any value of is_max_per_user_per_stream_enabled is included
            is_global_cooldown_enabled (bool, optional): Whether a cooldown is enabled
                                                         Default: false
            global_cooldown_seconds (int, optional): The cooldown in seconds if enabled
                                                     Required when any value of is_global_cooldown_enabled is included
            should_redemptions_skip_request_queue (bool, optional): Should redemptions be set to FULFILLED status immediately when redeemed and skip the request queue instead of the normal UNFULFILLED status
                                                                    Default: false

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Reward
        &#34;&#34;&#34;

        url = ENDPOINT_CUSTOM_REWARDS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;title&#34;: title, &#34;cost&#34;: cost}

        if prompt != &#34;&#34;:
            params[&#34;prompt&#34;] = prompt

        if is_enabled is not True:
            params[&#34;is_enabled&#34;] = is_enabled

        if background_color != &#34;&#34;:
            params[&#34;background_color&#34;] = background_color

        if is_user_input_required is not False:
            params[&#34;is_user_input_required&#34;] = is_user_input_required

        if is_max_per_stream_enabled is not False:
            params[&#34;is_max_per_stream_enabled&#34;] = is_max_per_stream_enabled

        if max_per_stream is not None:
            params[&#34;max_per_stream&#34;] = max_per_stream

        if is_max_per_user_per_stream_enabled is not False:
            params[
                &#34;is_max_per_user_per_stream_enabled&#34;
            ] = is_max_per_user_per_stream_enabled

        if max_per_user_per_stream is not None:
            params[&#34;max_per_user_per_stream&#34;] = max_per_user_per_stream

        if is_global_cooldown_enabled is not False:
            params[&#34;is_global_cooldown_enabled&#34;] = is_global_cooldown_enabled

        if global_cooldown_seconds is not None:
            params[&#34;global_cooldown_seconds&#34;] = global_cooldown_seconds

        if should_redemptions_skip_request_queue is not False:
            params[
                &#34;should_redemptions_skip_request_queue&#34;
            ] = should_redemptions_skip_request_queue

        response = requests.post(url, headers=headers, params=params)

        if response.ok:
            reward = response.json()[&#34;data&#34;][0]
            reward = Reward(
                reward[&#34;broadcaster_name&#34;],
                reward[&#34;broadcaster_id&#34;],
                reward[&#34;id&#34;],
                image=reward[&#34;image&#34;],
                background_color=reward[&#34;background_color&#34;],
                is_enabled=reward[&#34;is_enabled&#34;],
                cost=reward[&#34;cost&#34;],
                title=reward[&#34;title&#34;],
                prompt=reward[&#34;prompt&#34;],
                is_user_input_required=reward[&#34;is_user_input_required&#34;],
                max_per_stream_setting=reward[&#34;max_per_stream_setting&#34;],
                max_per_user_per_stream_setting=reward[
                    &#34;max_per_user_per_stream_setting&#34;
                ],
                global_cooldown_setting=reward[&#34;global_cooldown_setting&#34;],
                is_paused=reward[&#34;is_paused&#34;],
                is_in_stock=reward[&#34;is_in_stock&#34;],
                default_image=reward[&#34;default_image&#34;],
                should_redemptions_skip_request_queue=reward[
                    &#34;should_redemptions_skip_request_queue&#34;
                ],
                redemptions_redeemed_current_stream=reward[
                    &#34;redemptions_redeemed_current_stream&#34;
                ],
                cooldown_expires_at=reward[&#34;cooldown_expires_at&#34;],
            )

            return reward

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def delete_custom_reward(self, broadcaster_id, id):
        &#34;&#34;&#34;
        Deletes a Custom Reward on a channel
        The Custom Reward specified by id must have been created by the client_id attached to the OAuth token in order to be deleted
        Any UNFULFILLED Custom Reward Redemptions of the deleted Custom Reward will be updated to the FULFILLED status

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
            id (str): ID of the Custom Reward to delete
                      Must match a Custom Reward on broadcaster_id’s channel
        &#34;&#34;&#34;

        url = ENDPOINT_CUSTOM_REWARDS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id}

        requests.delete(url, headers=headers, data=data)

    def get_custom_reward(self, broadcaster_id, id=[], only_manageable_rewards=False):
        &#34;&#34;&#34;
        Returns a list of Custom Reward objects for the Custom Rewards on a channel

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
            id (list, optional): This parameter filters the results and only returns reward objects for the Custom Rewards with matching ID
                                Maximum: 50
            only_manageable_rewards (bool, optional): When set to true, only returns custom rewards that the calling broadcaster can manage
                                                      Default: false

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channel_points/custom_rewards&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if only_manageable_rewards is not False:
            params[&#34;only_manageable_rewards&#34;] = only_manageable_rewards

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            rewards = []

            for reward in response.json()[&#34;data&#34;]:
                rewards.append(
                    Reward(
                        reward[&#34;broadcaster_name&#34;],
                        reward[&#34;broadcaster_id&#34;],
                        reward[&#34;id&#34;],
                        image=reward[&#34;image&#34;],
                        background_color=reward[&#34;background_color&#34;],
                        is_enabled=reward[&#34;is_enabled&#34;],
                        cost=reward[&#34;cost&#34;],
                        title=reward[&#34;title&#34;],
                        prompt=reward[&#34;prompt&#34;],
                        is_user_input_required=reward[&#34;is_user_input_required&#34;],
                        max_per_stream_setting=reward[&#34;max_per_stream_setting&#34;],
                        max_per_user_per_stream_setting=reward[
                            &#34;max_per_user_per_stream_setting&#34;
                        ],
                        global_cooldown_setting=reward[&#34;global_cooldown_setting&#34;],
                        is_paused=reward[&#34;is_paused&#34;],
                        is_in_stock=reward[&#34;is_in_stock&#34;],
                        default_image=reward[&#34;default_image&#34;],
                        should_redemptions_skip_request_queue=reward[
                            &#34;should_redemptions_skip_request_queue&#34;
                        ],
                        redemptions_redeemed_current_stream=reward[
                            &#34;redemptions_redeemed_current_stream&#34;
                        ],
                        cooldown_expires_at=reward[&#34;cooldown_expires_at&#34;],
                    )
                )

            return rewards

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_custom_reward_redemption(
        self, broadcaster_id, reward_id, id=[], status=&#34;&#34;, sort=&#34;OLDEST&#34;, first=20
    ):
        &#34;&#34;&#34;
        Returns Custom Reward Redemption objects for a Custom Reward on a channel that was created by the same client_id
        Developers only have access to get and update redemptions for the rewards created programmatically by the same client_id

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
            reward_id (str): When ID is not provided, this parameter returns Custom Reward Redemption objects for redemptions of the Custom Reward with ID reward_id
            id (list, optional): When id is not provided, this param filters the results and only returns Custom Reward Redemption objects for the redemptions with matching ID
                                Maximum: 50
            status (str, optional): This param filters the Custom Reward Redemption objects for redemptions with the matching status
                                    Can be one of UNFULFILLED, FULFILLED or CANCELED
            sort (str, optional): Sort order of redemptions returned when getting the Custom Reward Redemption objects for a reward
                                  One of: OLDEST, NEWEST
                                  Default: OLDEST
            first (int, optional): Number of results to be returned when getting the Custom Reward Redemption objects for a reward
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channel_points/custom_rewards/redemptions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;reward_id&#34;: reward_id}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if status != &#34;&#34;:
            params[&#34;status&#34;] = status

        if sort != &#34;OLDEST&#34;:
            params[&#34;sort&#34;] = sort

        after = &#34;&#34;
        calls = math.ceil(first / 50)
        redemptions = []

        for call in range(calls):
            params[&#34;first&#34;] = min(50, first - (50 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                for redemption in response.json()[&#34;data&#34;]:
                    reward = Reward(
                        redemption[&#34;broadcaster_name&#34;],
                        redemption[&#34;broadcaster_id&#34;],
                        redemption[&#34;reward&#34;][&#34;id&#34;],
                        cost=redemption[&#34;reward&#34;][&#34;cost&#34;],
                        title=redemption[&#34;reward&#34;][&#34;title&#34;],
                        prompt=redemption[&#34;reward&#34;][&#34;prompt&#34;],
                    )
                    redemptions.append(
                        Redemption(
                            redemption[&#34;broadcaster_name&#34;],
                            redemption[&#34;broadcaster_id&#34;],
                            redemption[&#34;id&#34;],
                            redemption[&#34;user_id&#34;],
                            redemption[&#34;user_name&#34;],
                            redemption[&#34;user_input&#34;],
                            redemption[&#34;status&#34;],
                            redemption[&#34;redeemed_at&#34;],
                            reward,
                        )
                    )

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return redemptions

    def update_custom_reward(
        self,
        broadcaster_id,
        id,
        title=&#34;&#34;,
        prompt=&#34;&#34;,
        cost=None,
        background_color=&#34;&#34;,
        is_enabled=None,
        is_user_input_required=None,
        is_max_per_stream_enabled=None,
        max_per_stream=None,
        is_max_per_user_per_stream_enabled=None,
        max_per_user_per_stream=None,
        is_global_cooldown_enabled=None,
        global_cooldown_seconds=None,
        is_paused=None,
        should_redemptions_skip_request_queue=None,
    ):
        &#34;&#34;&#34;
        Updates a Custom Reward created on a channel
        The Custom Reward specified by id must have been created by the client_id attached to the user OAuth token

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
            id (str): ID of the Custom Reward to update
                      Must match a Custom Reward on the channel of the broadcaster_id
            title (str, optional): The title of the reward
            prompt (str, optional): The prompt for the viewer when they are redeeming the reward
            cost (int, optional): The cost of the reward
            background_color (str, optional): Custom background color for the reward as a hexadecimal value
            is_enabled (bool, optional): Is the reward currently enabled, if false the reward won’t show up to viewers
            is_user_input_required (bool, optional): Does the user need to enter information when redeeming the reward
            is_max_per_stream_enabled (bool, optional): Whether a maximum per stream is enabled
                                                        Required when any value of max_per_stream is included
            max_per_stream (int, optional): The maximum number per stream if enabled
                                            Required when any value of is_max_per_stream_enabled is included
            is_max_per_user_per_stream_enabled (bool, optional): Whether a maximum per user per stream is enabled
                                                                 Required when any value of max_per_user_per_stream is included
            max_per_user_per_stream (int, optional): The maximum number per user per stream if enabled
                                                     Required when any value of is_max_per_user_per_stream_enabled is included
            is_global_cooldown_enabled (bool, optional): Whether a cooldown is enabled
                                                         Required when any value of global_cooldown_seconds is included
            global_cooldown_seconds (int, optional): The cooldown in seconds if enabled
                                                     Required when any value of is_global_cooldown_enabled is included
            is_paused (bool, optional): Is the reward currently paused, if true viewers cannot redeem
            should_redemptions_skip_request_queue (bool, optional): Should redemptions be set to FULFILLED status immediately when redeemed and skip the request queue instead of the normal UNFULFILLED status

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Reward
        &#34;&#34;&#34;

        url = ENDPOINT_CUSTOM_REWARDS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id}

        if title != &#34;&#34;:
            data[&#34;title&#34;] = title

        if prompt != &#34;&#34;:
            data[&#34;prompt&#34;] = prompt

        if cost is not None:
            data[&#34;cost&#34;] = cost

        if background_color != &#34;&#34;:
            data[&#34;background_color&#34;] = background_color

        if is_enabled is not None:
            data[&#34;is_enabled&#34;] = is_enabled

        if is_user_input_required is not None:
            data[&#34;is_user_input_required&#34;] = is_user_input_required

        if is_max_per_stream_enabled is not None:
            data[&#34;is_max_per_stream_enabled&#34;] = is_max_per_stream_enabled

        if max_per_stream is not None:
            data[&#34;max_per_stream&#34;] = max_per_stream

        if is_max_per_user_per_stream_enabled is not None:
            data[
                &#34;is_max_per_user_per_stream_enabled&#34;
            ] = is_max_per_user_per_stream_enabled

        if max_per_user_per_stream is not None:
            data[&#34;max_per_user_per_stream&#34;] = max_per_user_per_stream

        if is_global_cooldown_enabled is not None:
            data[&#34;is_global_cooldown_enabled&#34;] = is_global_cooldown_enabled

        if global_cooldown_seconds is not None:
            data[&#34;global_cooldown_seconds&#34;] = global_cooldown_seconds

        if is_paused is not None:
            data[&#34;is_paused&#34;] = is_paused

        if should_redemptions_skip_request_queue is not None:
            data[
                &#34;should_redemptions_skip_request_queue&#34;
            ] = should_redemptions_skip_request_queue

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            reward = response.json()[&#34;data&#34;]
            reward = Reward(
                reward[&#34;broadcaster_name&#34;],
                reward[&#34;broadcaster_id&#34;],
                reward[&#34;id&#34;],
                image=reward[&#34;image&#34;],
                background_color=reward[&#34;background_color&#34;],
                is_enabled=reward[&#34;is_enabled&#34;],
                cost=reward[&#34;cost&#34;],
                title=reward[&#34;title&#34;],
                prompt=reward[&#34;prompt&#34;],
                is_user_input_required=reward[&#34;is_user_input_required&#34;],
                max_per_stream_setting=reward[&#34;max_per_stream_setting&#34;],
                max_per_user_per_stream_setting=reward[
                    &#34;max_per_user_per_stream_setting&#34;
                ],
                global_cooldown_setting=reward[&#34;global_cooldown_setting&#34;],
                is_paused=reward[&#34;is_paused&#34;],
                is_in_stock=reward[&#34;is_in_stock&#34;],
                default_image=reward[&#34;default_image&#34;],
                should_redemptions_skip_request_queue=reward[
                    &#34;should_redemptions_skip_request_queue&#34;
                ],
                redemptions_redeemed_current_stream=reward[
                    &#34;redemptions_redeemed_current_stream&#34;
                ],
                cooldown_expires_at=reward[&#34;cooldown_expires_at&#34;],
            )

            return reward

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_redemption_status(self, id, broadcaster_id, reward_id, status=&#34;&#34;):
        &#34;&#34;&#34;
        Updates the status of Custom Reward Redemption objects on a channel that are in the UNFULFILLED status
        The Custom Reward Redemption specified by id must be for a Custom Reward created by the client_id attached to the user OAuth token

        Args:
            id (list): ID of the Custom Reward Redemption to update
                      Must match a Custom Reward Redemption on broadcaster_id’s channel
                      Maximum: 50
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
            reward_id (str): ID of the Custom Reward the redemptions to be updated are for
            status (str, optional): The new status to set redemptions to
                                    Can be either FULFILLED or CANCELED
                                    Updating to CANCELED will refund the user their Channel Points

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Redemption
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/channel_points/custom_rewards/redemptions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;id&#34;: id, &#34;broadcaster_id&#34;: broadcaster_id, &#34;reward_id&#34;: reward_id}

        if status != &#34;&#34;:
            data[&#34;status&#34;] = status

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            redemption = response.json()[&#34;data&#34;][0]
            reward = Reward(
                redemption[&#34;broadcaster_name&#34;],
                redemption[&#34;broadcaster_id&#34;],
                redemption[&#34;reward&#34;][&#34;id&#34;],
                cost=redemption[&#34;reward&#34;][&#34;cost&#34;],
                title=redemption[&#34;reward&#34;][&#34;title&#34;],
                prompt=redemption[&#34;reward&#34;][&#34;prompt&#34;],
            )
            redemption = Redemption(
                redemption[&#34;broadcaster_name&#34;],
                redemption[&#34;broadcaster_id&#34;],
                redemption[&#34;id&#34;],
                redemption[&#34;user_id&#34;],
                redemption[&#34;user_name&#34;],
                redemption[&#34;user_input&#34;],
                redemption[&#34;status&#34;],
                redemption[&#34;redeemed_at&#34;],
                reward,
            )

            return redemption

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_charity_campaign(self, broadcaster_id: str) -&gt; CharityCampaign:
        &#34;&#34;&#34;
        Gets information about the charity campaign that a broadcaster is running

        Args:
            broadcaster_id (str): The ID of the broadcaster that’s currently running a charity campaign
                This ID must match the user ID in the access token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            CharityCampaign
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/charity/campaigns&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return CharityCampaign(
                response.json()[&#34;data&#34;][0][&#34;id&#34;],
                response.json()[&#34;data&#34;][0][&#34;broadcaster_id&#34;],
                response.json()[&#34;data&#34;][0][&#34;broadcaster_name&#34;],
                response.json()[&#34;data&#34;][0][&#34;broadcaster_login&#34;],
                response.json()[&#34;data&#34;][0][&#34;charity_name&#34;],
                response.json()[&#34;data&#34;][0][&#34;charity_description&#34;],
                response.json()[&#34;data&#34;][0][&#34;charity_logo&#34;],
                response.json()[&#34;data&#34;][0][&#34;charity_website&#34;],
                response.json()[&#34;data&#34;][0][&#34;current_amount&#34;],
                response.json()[&#34;data&#34;][0][&#34;target_amount&#34;],
            )

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_charity_campaign_donations(
        self, broadcaster_id: str, first: int = 20
    ) -&gt; list[CharityCampaignDonation]:
        &#34;&#34;&#34;
        Gets the list of donations that users have made to the broadcaster’s active charity campaign

        Args:
            broadcaster_id (str): The ID of the broadcaster that’s currently running a charity campaign
                This ID must match the user ID in the access token
            first (int): The maximum number of items to return
                Default: 20
                Minimum: 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[CharityCampaignDonation]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/charity/donations&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        after = &#34;&#34;
        calls = math.ceil(first / 20)
        donations = []

        for call in range(calls):
            params[&#34;first&#34;] = min(20, first - (20 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for donation in response[&#34;data&#34;]:
                    donations.append(
                        CharityCampaignDonation(
                            donation[&#34;id&#34;],
                            donation[&#34;campaign_id&#34;],
                            donation[&#34;user_id&#34;],
                            donation[&#34;user_login&#34;],
                            donation[&#34;user_name&#34;],
                            donation[&#34;amount&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return donations

    def get_chatters(
        self, broadcaster_id: str, moderator_id: str, first: int = 100
    ) -&gt; list[User]:
        &#34;&#34;&#34;
        Gets the list of users that are connected to the broadcaster’s chat session

        Args:
            broadcaster_id (str): The ID of the broadcaster whose list of chatters you want to get
            moderator_id (str): The ID of the broadcaster or one of the broadcaster’s moderators
                This ID must match the user ID in the user access token
            first (int): The maximum number of items to return
                Default: 100
                Minimum: 1
                Maximum: 1000

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[User]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/chatters&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        users = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                users.extend(
                    self.get_users([user[&#34;user_id&#34;] for user in response[&#34;data&#34;]])
                )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return users

    def get_channel_emotes(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets all custom emotes for a specific Twitch channel including subscriber emotes, Bits tier emotes, and follower emotes
        Custom channel emotes are custom emoticons that viewers may use in Twitch chat once they are subscribed to, cheered in, or followed the channel that owns the emotes

        Args:
            broadcaster_id (str): The broadcaster whose emotes are being requested

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/emotes&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            emotes = []

            for emote in response.json()[&#34;data&#34;]:
                emotes.append(
                    Emote(
                        emote[&#34;id&#34;],
                        emote[&#34;name&#34;],
                        emote[&#34;images&#34;],
                        emote[&#34;format&#34;],
                        emote[&#34;scale&#34;],
                        emote[&#34;theme_mode&#34;],
                        emote[&#34;tier&#34;],
                        emote[&#34;emote_type&#34;],
                        emote[&#34;emote_set_id&#34;],
                    )
                )

            return emotes

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_global_emotes(self):
        &#34;&#34;&#34;
        Gets all global emotes
        Global emotes are Twitch-specific emoticons that every user can use in Twitch chat

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/emotes/global&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }

        response = requests.get(url, headers=headers)

        if response.ok:
            emotes = []

            for emote in response.json()[&#34;data&#34;]:
                emotes.append(
                    Emote(
                        emote[&#34;id&#34;],
                        emote[&#34;name&#34;],
                        emote[&#34;images&#34;],
                        emote[&#34;format&#34;],
                        emote[&#34;scale&#34;],
                        emote[&#34;theme_mode&#34;],
                    )
                )

            return emotes

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_emote_sets(self, emote_set_id):
        &#34;&#34;&#34;
        Gets all Twitch emotes for one or more specific emote sets

        Args:
            emote_set_id (list): ID(s) of the emote set
                                 Maximum: 25

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/emotes/set&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;emote_set_id&#34;: emote_set_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            emotes = []

            for emote in response.json()[&#34;data&#34;]:
                emotes.append(
                    Emote(
                        emote[&#34;id&#34;],
                        emote[&#34;name&#34;],
                        emote[&#34;images&#34;],
                        emote[&#34;format&#34;],
                        emote[&#34;scale&#34;],
                        emote[&#34;theme_mode&#34;],
                        emote_type=emote[&#34;emote_type&#34;],
                        emote_set_id=emote[&#34;emote_set_id&#34;],
                    )
                )

            return emotes

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_channel_chat_badges(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets a list of custom chat badges that can be used in chat for the specified channel
        This includes subscriber badges and Bit badges

        Args:
            broadcaster_id (str): The broadcaster whose chat badges are being requested
                                  Provided broadcaster_id must match the user_id in the user OAuth token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/badges&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            badges = []

            for badge in response.json()[&#34;data&#34;]:
                badges.append(Badge(badge[&#34;set_id&#34;], badge[&#34;versions&#34;]))

            return badges

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_global_chat_badges(self):
        &#34;&#34;&#34;
        Gets a list of chat badges that can be used in chat for any channel

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/badges/global&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }

        response = requests.get(url, headers=headers)

        if response.ok:
            badges = []

            for badge in response.json()[&#34;data&#34;]:
                badges.append(Badge(badge[&#34;set_id&#34;], badge[&#34;versions&#34;]))

            return badges

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_chat_settings(self, broadcaster_id, moderator_id=&#34;&#34;):
        &#34;&#34;&#34;
        Gets the broadcaster’s chat settings

        Args:
            broadcaster_id (str): The ID of the broadcaster whose chat settings you want to get
            moderator_id (str, optional): Required only to access the non_moderator_chat_delay or non_moderator_chat_delay_duration settings
                                          The ID of a user that has permission to moderate the broadcaster’s chat room
                                          This ID must match the user ID associated with the user OAuth token
                                          If the broadcaster wants to get their own settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_chat_settings(
        self,
        broadcaster_id,
        moderator_id,
        emote_mode=None,
        follower_mode=None,
        follower_mode_duration=0,
        non_moderator_chat_delay=None,
        non_moderator_chat_delay_duration=0,
        slow_mode=None,
        slow_mode_wait_time=30,
        subscriber_mode=None,
        unique_chat_mode=None,
    ):
        &#34;&#34;&#34;
        Updates the broadcaster’s chat settings

        Args:
            broadcaster_id (str): The ID of the broadcaster whose chat settings you want to update
                                  This ID must match the user ID associated with the user OAuth token
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to update their own settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
            emote_mode (bool, optional): A Boolean value that determines whether chat messages must contain only emotes
                                         Set to true, if only messages that are 100% emotes are allowed; otherwise, false
                                         Default is false
            follower_mode (bool, optional): A Boolean value that determines whether the broadcaster restricts the chat room to followers only, based on how long they’ve followed
                                            Set to true, if the broadcaster restricts the chat room to followers only; otherwise, false
                                            Default is false
            follower_mode_duration (int, optional): The length of time, in minutes, that the followers must have followed the broadcaster to participate in the chat room
                                                    You may specify a value in the range: 0 (no restriction) through 129600 (3 months)
                                                    The default is 0
            non_moderator_chat_delay (bool, optional): A Boolean value that determines whether the broadcaster adds a short delay before chat messages appear in the chat room
                                                       This gives chat moderators and bots a chance to remove them before viewers can see the message
                                                       Set to true, if the broadcaster applies a delay; otherwise, false
                                                       Default is false
            non_moderator_chat_delay_duration (int, optional): The amount of time, in seconds, that messages are delayed from appearing in chat
                                                               Possible values are: 2, 4, 6
            slow_mode (bool, optional): A Boolean value that determines whether the broadcaster limits how often users in the chat room are allowed to send messages
                                        Set to true, if the broadcaster applies a wait period messages; otherwise, false
                                        Default is false
            slow_mode_wait_time (int, optional): The amount of time, in seconds, that users need to wait between sending messages
                                                 You may specify a value in the range: 3 (3 second delay) through 120 (2 minute delay)
                                                 The default is 30 seconds
            subscriber_mode (bool, optional): A Boolean value that determines whether only users that subscribe to the broadcaster’s channel can talk in the chat room
                                              Set to true, if the broadcaster restricts the chat room to subscribers only; otherwise, false
                                              Default is false
            unique_chat_mode (bool, optional): A Boolean value that determines whether the broadcaster requires users to post only unique messages in the chat room
                                               Set to true, if the broadcaster requires unique messages only; otherwise, false
                                               Default is false

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        if emote_mode is not None:
            data[&#34;emote_mode&#34;] = emote_mode

        if follower_mode is not None:
            data[&#34;follower_mode&#34;] = follower_mode

        if follower_mode_duration != 0:
            data[&#34;follower_mode_duration&#34;] = follower_mode_duration

        if non_moderator_chat_delay is not None:
            data[&#34;non_moderator_chat_delay&#34;] = non_moderator_chat_delay

        if non_moderator_chat_delay_duration != 0:
            data[
                &#34;non_moderator_chat_delay_duration&#34;
            ] = non_moderator_chat_delay_duration

        if slow_mode is not None:
            data[&#34;slow_mode&#34;] = slow_mode

        if slow_mode_wait_time != 30:
            data[&#34;slow_mode_wait_time&#34;] = slow_mode_wait_time

        if subscriber_mode is not None:
            data[&#34;subscriber_mode&#34;] = subscriber_mode

        if unique_chat_mode is not None:
            data[&#34;unique_chat_mode&#34;] = unique_chat_mode

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def send_chat_announcement(
        self, broadcaster_id: str, moderator_id: str, message: str, color: str = &#34;&#34;
    ) -&gt; None:
        &#34;&#34;&#34;
        Sends an announcement to the broadcaster’s chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster that owns the chat room to send the announcement to
            moderator_id (str): The ID of a user who has permission to moderate the broadcaster’s chat room, or the broadcaster’s ID if they’re sending the announcement
                This ID must match the user ID in the user access token
            message (str): The announcement to make in the broadcaster’s chat
                Announcements are limited to a maximum of 500 characters
            color (str): Announcements are limited to a maximum of 500 characters
                Possible case-sensitive values are: blue, green, orange, purple, primary (default)
                If color is set to primary or is not set, the channel’s accent color is used to highlight the announcement
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/announcements&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;message&#34;: message,
        }

        if color != &#34;&#34;:
            payload[&#34;color&#34;] = color

        requests.post(url, headers=headers, json=payload)

    def send_a_shoutout(
        self, from_broadcaster_id: str, to_broadcaster_id: str, moderator_id: str
    ) -&gt; None:
        &#34;&#34;&#34;
        Sends a Shoutout to the specified broadcaster

        Args:
            from_broadcaster_id (str): The ID of the broadcaster that’s sending the Shoutout
            to_broadcaster_id (str): The ID of the broadcaster that’s receiving the Shoutout
            moderator_id (str): The ID of the broadcaster or a user that is one of the broadcaster’s moderators
                This ID must match the user ID in the access token
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/shoutouts&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;from_broadcaster_id&#34;: from_broadcaster_id,
            &#34;to_broadcaster_id&#34;: to_broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
        }

        requests.post(url, headers=headers, json=payload)

    def get_user_chat_color(self, user_id: str | list[str]) -&gt; list[dict]:
        &#34;&#34;&#34;
        Gets the color used for the user’s name in chat

        Args:
            user_id (str | list[str]): The ID of the user whose username color you want to get
                Maximum: 100

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[dict]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/color&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;user_id&#34;: user_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_user_chat_color(self, user_id: str, color: str) -&gt; None:
        &#34;&#34;&#34;
        Updates the color used for the user’s name in chat

        Args:
            user_id (str): The ID of the user whose chat color you want to update
                This ID must match the user ID in the access token
            color (str): The color to use for the user’s name in chat
                All users may specify one of the following named color values: blue, blue_violet, cadet_blue, chocolate, coral, dodger_blue, firebrick, golden_rod, green, hot_pink, orange_red, red, sea_green, spring_green, yellow_green
                Turbo and Prime users may specify a named color or a Hex color code
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/chat/color&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;user_id&#34;: user_id, &#34;color&#34;: color}

        requests.put(url, headers=headers, data=data)

    def create_clip(self, broadcaster_id, has_delay=False):
        &#34;&#34;&#34;
        This returns both an ID and an edit URL for a new clip

        Args:
            broadcaster_id (str): ID of the stream from which the clip will be made
            has_delay (bool, optional): If false, the clip is captured from the live stream when the API is called; otherwise, a delay is added before the clip is captured (to account for the brief delay between the broadcaster’s stream and the viewer’s experience of that stream)
                                        Default: false

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/clips&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;broadcaster_id&#34;: broadcaster_id}

        if has_delay is not False:
            payload[&#34;has_delay&#34;] = has_delay

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_clips(
        self,
        broadcaster_id: str = &#34;&#34;,
        game_id: str = &#34;&#34;,
        id: list[str] = [],
        started_at: str = &#34;&#34;,
        ended_at: str = &#34;&#34;,
        first: int = 20,
        is_featured: bool = False,
    ) -&gt; list[Clip]:
        &#34;&#34;&#34;
        Gets one or more video clips that were captured from streams
        The id, game_id, and broadcaster_id query parameters are mutually exclusive

        Args:
            broadcaster_id (str): An ID that identifies the broadcaster whose video clips you want to get
            game_id (str): An ID that identifies the game whose clips you want to get
            id (list[str]): An ID that identifies the clip to get
            started_at (str): The start date used to filter clips
            ended_at (str): The end date used to filter clips
            first (int): The maximum number of clips to return
                Minimum: 1
            is_featured (bool): A Boolean value that determines whether the response includes featured clips

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Clip]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/clips&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if broadcaster_id != &#34;&#34;:
            params[&#34;broadcaster_id&#34;] = broadcaster_id

        if game_id != &#34;&#34;:
            params[&#34;game_id&#34;] = game_id

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if started_at != &#34;&#34;:
            params[&#34;started_at&#34;] = started_at

        if ended_at != &#34;&#34;:
            params[&#34;ended_at&#34;] = ended_at

        if is_featured is not False:
            params[&#34;is_featured&#34;] = is_featured

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        clips = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for clip in response[&#34;data&#34;]:
                    clips.append(
                        Clip(
                            clip[&#34;id&#34;],
                            clip[&#34;url&#34;],
                            clip[&#34;embed_url&#34;],
                            clip[&#34;broadcaster_id&#34;],
                            clip[&#34;broadcaster_name&#34;],
                            clip[&#34;creator_id&#34;],
                            clip[&#34;creator_name&#34;],
                            clip[&#34;video_id&#34;],
                            clip[&#34;game_id&#34;],
                            clip[&#34;language&#34;],
                            clip[&#34;title&#34;],
                            clip[&#34;view_count&#34;],
                            clip[&#34;created_at&#34;],
                            clip[&#34;thumbnail_url&#34;],
                            clip[&#34;duration&#34;],
                            clip[&#34;vod_offset&#34;],
                            clip[&#34;is_featured&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return clips

    def get_conduits(self) -&gt; list[dict]:
        &#34;&#34;&#34;
        Gets the conduits for a client ID

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[dict]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/eventsub/conduits&#34;
        headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id}

        response = requests.get(url, headers=headers)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def create_conduits(self, shard_count: int) -&gt; dict:
        &#34;&#34;&#34;
        Creates a new conduit

        Args:
            shard_count (int): The number of shards to create for this conduit

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/eventsub/conduits&#34;
        headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id, &#34;Content-Type&#34;: &#34;application/json&#34;}
        payload = {&#34;shard_count&#34;, shard_count}

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_conduits(self, id: str, shard_count: int) -&gt; dict:
        &#34;&#34;&#34;
        Updates a conduit’s shard count
        To delete shards, update the count to a lower number, and the shards above the count will be deleted

        Args:
            id (str): Conduit ID
            shard_count (int): The new number of shards for this conduit

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/eventsub/conduits&#34;
        headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id, &#34;Content-Type&#34;: &#34;application/json&#34;}
        data = {&#34;id&#34;: id, &#34;shard_count&#34;: shard_count}

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def delete_conduit(self, id: str) -&gt; None:
        &#34;&#34;&#34;
        Deletes a specified conduit

        Args:
            id (str): Conduit ID

        Raises:
            twitchpy.errors.ClientError
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/eventsub/conduits&#34;
        headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id}
        data = {&#34;id&#34;: id}

        response = requests.delete(url, headers=headers, data=data)

        if not response.ok:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_conduit_shards(self, conduit_id: str, status: str = &#34;&#34;) -&gt; list[dict]:
        &#34;&#34;&#34;
        Gets a lists of all shards for a conduit

        Args:
            conduit_id (str): Conduit ID
            status (str): Status to filter by

        Raise:
            twitchpy.errors.ClientError

        Returns:
            list[dict]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/eventsub/conduits/shards&#34;
        headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id}
        params = {&#34;conduit_id&#34;: conduit_id}

        if status != &#34;&#34;:
            params[&#34;status&#34;] = status

        response = requests.get(url, headers=headers, params=params)

        conduit_shards = []

        while response.ok and &#34;pagination&#34; in response:
            conduit_shards.append(response.json()[&#34;data&#34;])
            params[&#34;after&#34;] = response.json()[&#34;pagination&#34;][&#34;cursor&#34;]

            response = requests.get(url, headers=headers, params=params)

        if not response.ok:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return conduit_shards

    def update_conduit_shards(self, conduit_id: str, shards: list[dict], session_id: str = &#34;&#34;) -&gt; dict:
        &#34;&#34;&#34;
        Updates shard(s) for a conduit

        Args:
            conduit_id (str): Conduit ID
            shards (list[dict]): List of shards to update
            session_id (str): An ID that identifies the WebSocket to send notifications to
                Specify this field only if method is set to websocket

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/eventsub/conduits/shards&#34;
        headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id, &#34;Content-Type&#34;: &#34;application/json&#34;}
        data = {&#34;conduit_id&#34;: conduit_id, &#34;shards&#34;: shards}

        if session_id != &#34;&#34;:
            data[&#34;session_id&#34;] = session_id

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_content_classification_labels(self, locale: str = &#34;en-US&#34;) -&gt; list[dict]:
        &#34;&#34;&#34;
        Gets information about Twitch content classification labels

        Args:
            locale (str): Locale for the Content Classification Labels
                Possible values: &#34;bg-BG&#34;, &#34;cs-CZ&#34;, &#34;da-DK&#34;, &#34;da-DK&#34;, &#34;de-DE&#34;, &#34;el-GR&#34;, &#34;en-GB&#34;, &#34;en-US&#34;, &#34;es-ES&#34;, &#34;es-MX&#34;, &#34;fi-FI&#34;, &#34;fr-FR&#34;, &#34;hu-HU&#34;, &#34;it-IT&#34;, &#34;ja-JP&#34;, &#34;ko-KR&#34;, &#34;nl-NL&#34;, &#34;no-NO&#34;, &#34;pl-PL&#34;, &#34;pt-BT&#34;, &#34;pt-PT&#34;, &#34;ro-RO&#34;, &#34;ru-RU&#34;, &#34;sk-SK&#34;, &#34;sv-SE&#34;, &#34;th-TH&#34;, &#34;tr-TR&#34;, &#34;vi-VN&#34;, &#34;zh-CN&#34;, &#34;zh-TW&#34;

        Raise:
            twitchpy.errors.ClientError

        Returns:
            list[dict]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/content_classification_labels&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if locale != &#34;en-US&#34;:
            params[&#34;locale&#34;] = locale

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_drops_entitlements(
        self, id=&#34;&#34;, user_id=&#34;&#34;, game_id=&#34;&#34;, fulfillment_status=&#34;&#34;, first=20
    ):
        &#34;&#34;&#34;
        Gets a list of entitlements for a given organization that have been granted to a game, user, or both

        Args:
            id (str, optional): ID of the entitlement
            user_id (str, optional): A Twitch User ID
            game_id (str, optional): A Twitch Game ID
            fulfillment_status (str, optional): An optional fulfillment status used to filter entitlements
                                                Valid values are &#34;CLAIMED&#34; or &#34;FULFILLED&#34;
            first (int, optional): Maximum number of entitlements to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/entitlements/drops&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if id != &#34;&#34;:
            params[&#34;id&#34;] = id

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        if game_id != &#34;&#34;:
            params[&#34;game_id&#34;] = game_id

        if fulfillment_status != &#34;&#34;:
            params[&#34;fulfillment_status&#34;] = fulfillment_status

        after = &#34;&#34;
        calls = math.ceil(first / 1000)
        drops_entitlements = []

        for call in range(calls):
            params[&#34;first&#34;] = min(1000, first - (1000 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                drops_entitlements.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return drops_entitlements

    def update_drops_entitlements(self, entitlement_ids=[], fulfillment_status=&#34;&#34;):
        &#34;&#34;&#34;
        Updates the fulfillment status on a set of Drops entitlements, specified by their entitlement IDs

        Args:
            entitlement_ids (list, optional): An array of unique identifiers of the entitlements to update
                                              Maximum: 100
            fulfillment_status (str, optional): A fulfillment status
                                                Valid values are &#34;CLAIMED&#34; or &#34;FULFILLED&#34;

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/entitlements/drops&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        data = {}

        if len(entitlement_ids) &gt; 0:
            data[&#34;entitlement_ids&#34;] = entitlement_ids

        if fulfillment_status != &#34;&#34;:
            data[&#34;fulfillment_status&#34;] = fulfillment_status

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_extension_configuration_segment(
        self, broadcaster_id, extension_id, segment
    ):
        &#34;&#34;&#34;
        Gets the specified configuration segment from the specified extension
        You can retrieve each segment a maximum of 20 times per minute

        Args:
            broadcaster_id (str): The ID of the broadcaster for the configuration returned
                                  This parameter is required if you set the segment parameter to &#34;broadcaster&#34; or &#34;developer&#34;
                                  Do not specify this parameter if you set segment to &#34;global&#34;
            extension_id (str): The ID of the extension that contains the configuration segment you want to get
            segment (list): The type of configuration segment to get
                           Valid values are: &#34;broadcaster&#34;, &#34;developer&#34;, &#34;global&#34;

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/configurations&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;extension_id&#34;: extension_id,
            &#34;segment&#34;: segment,
        }

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def set_extension_configuration_segment(
        self, extension_id, segment, broadcaster_id=&#34;&#34;, content=&#34;&#34;, version=&#34;&#34;
    ):
        &#34;&#34;&#34;
        Sets a single configuration segment of any type
        Each segment is limited to 5 KB and can be set at most 20 times per minute
        Updates to this data are not delivered to Extensions that have already been rendered

        Args:
            extension_id (str): ID for the Extension which the configuration is for
            segment (str): Configuration type
                           Valid values are &#34;global&#34;, &#34;developer&#34;, or &#34;broadcaster&#34;
            broadcaster_id (str, optional): User ID of the broadcaster
                                            Required if the segment type is &#34;developer&#34; or &#34;broadcaster&#34;
            content (str, optional): Configuration in a string-encoded format
            version (str, optional): Configuration version with the segment type
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/configurations&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;extension_id&#34;: extension_id, &#34;segment&#34;: segment}

        if broadcaster_id != &#34;&#34;:
            data[&#34;broadcaster_id&#34;] = broadcaster_id

        if content != &#34;&#34;:
            data[&#34;content&#34;] = content

        if version != &#34;&#34;:
            data[&#34;version&#34;] = version

        requests.put(url, headers=headers, data=data)

    def set_extension_required_configuration(
        self, broadcaster_id, extension_id, extension_version, configuration_version
    ):
        &#34;&#34;&#34;
        Enable activation of a specified Extension, after any required broadcaster configuration is correct

        Args:
            broadcaster_id (str): User ID of the broadcaster who has activated the specified Extension on their channel
            extension_id (str): ID for the Extension to activate
            extension_version (str): The version fo the Extension to release
            configuration_version (str): The version of the configuration to use with the Extension
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/required_configuration&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;extension_id&#34;: extension_id,
            &#34;extension_version&#34;: extension_version,
            &#34;configuration_version&#34;: configuration_version,
        }

        requests.put(url, headers=headers, data=data)

    def send_extension_pubsub_message(
        self, target, broadcaster_id, is_global_broadcast, message
    ):
        &#34;&#34;&#34;
        A message can be sent to either a specified channel or globally (all channels on which your extension is active)
        Extension PubSub has a rate limit of 100 requests per minute for a combination of Extension client ID and broadcaster ID

        Args:
            target (list): Array of strings for valid PubSub targets
                           Valid values: &#34;broadcast&#34;, &#34;global&#34;, &#34;whisper-&lt;user-id&gt;&#34;
            broadcaster_id (str): ID of the broadcaster receiving the payload
            is_global_broadcast (bool): Indicates if the message should be sent to all channels where your Extension is active
            message (str): String-encoded JSON message to be sent
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/pubsub&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;target&#34;: target,
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;is_global_broadcast&#34;: is_global_broadcast,
            &#34;message&#34;: message,
        }

        requests.post(url, headers=headers, data=data)

    def get_extension_live_channels(self, extension_id, first=20):
        &#34;&#34;&#34;
        Returns one page of live channels that have installed or activated a specific Extension, identified by a client ID value assigned to the Extension when it is created
        A channel that recently went live may take a few minutes to appear in this list, and a channel may continue to appear on this list for a few minutes after it stops broadcasting

        Args:
            extension_id (str): ID of the Extension to search for
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/live&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: {self.client_id},
        }
        params = {&#34;extension_id&#34;: extension_id}

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        channels = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for channel in response[&#34;data&#34;]:
                    channels.append(channel)

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return channels

    def get_extension_secrets(self):
        &#34;&#34;&#34;
        Retrieves a specified Extension’s secret data consisting of a version and an array of secret objects
        Each secret object contains a base64-encoded secret, a UTC timestamp when the secret becomes active, and a timestamp when the secret expires

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/jwt/secrets&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }

        response = requests.get(url, headers=headers)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def create_extension_secret(self, delay=300):
        &#34;&#34;&#34;
        Creates a JWT signing secret for a specific Extension
        Also rotates any current secrets out of service, with enough time for instances of the Extension to gracefully switch over to the new secret

        Args:
            delay (int, optional): JWT signing activation delay for the newly created secret in seconds
                                   Minimum: 300
                                   Default: 300

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/jwt/secrets&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {}

        if delay != 300:
            payload[&#34;delay&#34;] = delay

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def send_extension_chat_message(
        self, broadcaster_id, text, extension_id, extension_version
    ):
        &#34;&#34;&#34;
        Sends a specified chat message to a specified channel
        The message will appear in the channel’s chat as a normal message
        The &#34;username&#34; of the message is the Extension name
        There is a limit of 12 messages per minute, per channel

        Args:
            broadcaster_id (str): User ID of the broadcaster whose channel has the Extension activated
            text (str): Message for Twitch chat
                        Maximum: 280 characters
            extension_id (str): Client ID associated with the Extension
            extension_version (str): Version of the Extension sending this message
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/chat&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;text&#34;: text,
            &#34;extension_id&#34;: extension_id,
            &#34;extension_version&#34;: extension_version,
        }

        requests.post(url, headers=headers, json=payload)

    def get_extensions(self, extension_id, extension_version=&#34;&#34;):
        &#34;&#34;&#34;
        Gets information about your Extensions; either the current version or a specified version

        Args:
            extension_id (str): ID of the Extension
            extension_version (str, optional): The specific version of the Extension to return
                                               If not provided, the current version is returned

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;extension_id&#34;: extension_id}

        if extension_version != &#34;&#34;:
            params[&#34;extension_version&#34;] = extension_version

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            extensions = []

            for extension in response.json()[&#34;data&#34;]:
                extensions.append(
                    Extension(
                        extension[&#34;author_name&#34;],
                        extension[&#34;bits_enables&#34;],
                        extension[&#34;can_install&#34;],
                        extension[&#34;configuration_location&#34;],
                        extension[&#34;description&#34;],
                        extension[&#34;eula_tos_url&#34;],
                        extension[&#34;has_chat_support&#34;],
                        extension[&#34;icon_url&#34;],
                        extension[&#34;icon_urls&#34;],
                        extension[&#34;id&#34;],
                        extension[&#34;name&#34;],
                        extension[&#34;privacy_policy_url&#34;],
                        extension[&#34;request_identity_link&#34;],
                        extension[&#34;screenshot_urls&#34;],
                        extension[&#34;state&#34;],
                        extension[&#34;subscriptions_support_level&#34;],
                        extension[&#34;summary&#34;],
                        extension[&#34;support_email&#34;],
                        extension[&#34;version&#34;],
                        extension[&#34;viewer_summary&#34;],
                        extension[&#34;views&#34;],
                        extension[&#34;allowlisted_config_urls&#34;],
                        extension[&#34;allowlisted_panel_urls&#34;],
                    )
                )

            return extensions

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_released_extensions(self, extension_id, extension_version=&#34;&#34;):
        &#34;&#34;&#34;
        Gets information about a released Extension; either the current version or a specified version

        Args:
            extension_id (str): ID of the Extension
            extension_version (str, optional): The specific version of the Extension to return
                                               If not provided, the current version is returned

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/extensions/released&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;extension_id&#34;: extension_id}

        if extension_version != &#34;&#34;:
            params[&#34;extension_version&#34;] = extension_version

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            extensions = []

            for extension in response.json()[&#34;data&#34;]:
                extensions.append(
                    Extension(
                        extension[&#34;author_name&#34;],
                        extension[&#34;bits_enables&#34;],
                        extension[&#34;can_install&#34;],
                        extension[&#34;configuration_location&#34;],
                        extension[&#34;description&#34;],
                        extension[&#34;eula_tos_url&#34;],
                        extension[&#34;has_chat_support&#34;],
                        extension[&#34;icon_url&#34;],
                        extension[&#34;icon_urls&#34;],
                        extension[&#34;id&#34;],
                        extension[&#34;name&#34;],
                        extension[&#34;privacy_policy_url&#34;],
                        extension[&#34;request_identity_link&#34;],
                        extension[&#34;screenshot_urls&#34;],
                        extension[&#34;state&#34;],
                        extension[&#34;subscriptions_support_level&#34;],
                        extension[&#34;summary&#34;],
                        extension[&#34;support_email&#34;],
                        extension[&#34;version&#34;],
                        extension[&#34;viewer_summary&#34;],
                        extension[&#34;views&#34;],
                        extension[&#34;allowlisted_config_urls&#34;],
                        extension[&#34;allowlisted_panel_urls&#34;],
                    )
                )

            return extensions

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_extension_bits_products(
        self, extension_client_id, should_include_all=False
    ):
        &#34;&#34;&#34;
        Gets a list of Bits products that belongs to an Extension

        Args:
            extension_client_id (str): Extension client ID
            should_include_all (bool, optional): Whether Bits products that are disabled/expired should be included in the response
                                                 Default: false

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/bits/extensions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: extension_client_id,
        }
        params = {}

        if should_include_all is not False:
            params[&#34;should_include_all&#34;] = should_include_all

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_extension_bits_product(
        self,
        extension_client_id,
        sku,
        cost,
        display_name,
        in_development=False,
        expiration=&#34;&#34;,
        is_broadcast=False,
    ):
        &#34;&#34;&#34;
        Add or update a Bits products that belongs to an Extension

        Args:
            extension_client_id (str): Extension client ID
            sku (str): SKU of the Bits product
                       This must be unique across all products that belong to an Extension
                       The SKU cannot be changed after saving
                       Maximum: 255 characters, no white spaces
            cost (dict): Object containing cost information
            display_name (str): Name of the product to be displayed in the Extension
                                Maximum: 255 characters
            in_development (bool, optional): Set to true if the product is in development and not yet released for public use
                                             Default: false
            expiration (str, optional): Expiration time for the product in RFC3339 format
                                        If not provided, the Bits product will not have an expiration date
                                        Setting an expiration in the past will disable the product
            is_broadcast (bool, optional): Indicates if Bits product purchase events are broadcast to all instances of an Extension on a channel via the “onTransactionComplete” helper callback
                                           Default: false

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/bits/extensions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: extension_client_id,
        }
        data = {&#34;sku&#34;: sku, &#34;cost&#34;: cost, &#34;display_name&#34;: display_name}

        if in_development is not False:
            data[&#34;in_development&#34;] = in_development

        if expiration != &#34;&#34;:
            data[&#34;expiration&#34;] = expiration

        if is_broadcast is not False:
            data[&#34;is_broadcast&#34;] = is_broadcast

        response = requests.put(url, headers=headers, data=data)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def create_eventsub_subscription(self, type, version, condition, transport):
        &#34;&#34;&#34;
        Creates an EventSub subscription

        Args:
            type (str): The category of the subscription that is being created
                        Valid values: &#34;channel.update&#34;, &#34;channel.follow&#34;, &#34;channel.subscribe&#34;, &#34;channel.subscription.end&#34;, &#34;channel.subscription.gift&#34;,&#34;channel.subscription.message&#34;, &#34;channel.cheer&#34;, &#34;channel.raid&#34;, &#34;channel.ban&#34;, &#34;channel.unban&#34;, &#34;channel.moderator.add&#34;, &#34;channel.moderator.remove&#34;, &#34;channel.channel_points_custom_reward.add&#34;, &#34;channel.channel_points_custom_reward.update&#34;, &#34;channel.channel_points_custom_reward.remove&#34;, &#34;channel.channel_points_custom_reward_redemption.add&#34;, &#34;channel.channel_points_custom_reward_redemption.update&#34;, &#34;channel.poll.begin&#34;, &#34;channel.poll.progress&#34;, &#34;channel.poll.end&#34;, &#34;channel.prediction.begin&#34;, &#34;channel.prediction.progress&#34;, &#34;channel.prediction.lock&#34;, &#34;channel.prediction.end&#34;, &#34;drop.entitlement.grant&#34;, &#34;extension.bits_transaction.create&#34;, &#34;channel.hype_train.begin&#34;, &#34;channel.hype_train.progress&#34;, &#34;channel.hype_train.end&#34;, &#34;stream.online&#34;, &#34;stream.offline&#34;, &#34;user.authorization.grant&#34;, &#34;user.authorization.revoke&#34;, &#34;user.update&#34;
            version (str): The version of the subscription type that is being created
                           Each subscription type has independent versioning
            condition (dict): Custom parameters for the subscription
            transport (dict): Notification delivery specific configuration including a method string
                              Valid transport methods include: webhook
                              In addition to the method string, a webhook transport must include the callback and secret information

        Raises:
            twitchpy.errors.ClientError

        Returns:
            EventSubSubscription
        &#34;&#34;&#34;

        url = ENDPOINT_EVENTSUB_SUBSCRIPTION
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {
            &#34;type&#34;: type,
            &#34;version&#34;: version,
            &#34;condition&#34;: condition,
            &#34;transport&#34;: transport,
        }

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            subscription = response.json()[&#34;data&#34;][0]
            subscription = EventSubSubscription(
                subscription[&#34;id&#34;],
                subscription[&#34;status&#34;],
                subscription[&#34;type&#34;],
                subscription[&#34;version&#34;],
                subscription[&#34;condition&#34;],
                subscription[&#34;created_at&#34;],
                subscription[&#34;transport&#34;],
                subscription[&#34;cost&#34;],
            )

            return subscription

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def delete_eventsub_subscription(self, id):
        &#34;&#34;&#34;
        Delete an EventSub subscription

        Args:
            id (str): The subscription ID for the subscription to delete
        &#34;&#34;&#34;

        url = ENDPOINT_EVENTSUB_SUBSCRIPTION
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;id&#34;: id}

        requests.delete(url, headers=headers, data=data)

    def get_eventsub_subscriptions(
        self, status: str = &#34;&#34;, type: str = &#34;&#34;, user_id: str = &#34;&#34;
    ) -&gt; list[EventSubSubscription]:
        &#34;&#34;&#34;
        Get a list of your EventSub subscriptions
        Only include one filter query parameter

        Args:
            status (str, optional): Filters subscriptions by one status type
                Valid values: &#34;enabled&#34;, &#34;webhook_callback_verification_pending&#34;, &#34;webhook_callback_verification_failed&#34;, &#34;notification_failures_exceeded&#34;, &#34;authorization_revoked&#34;, &#34;moderator_removed&#34;, &#34;user_removed&#34;, &#34;version_removed&#34;, &#34;websocket_disconnected&#34;, &#34;websocket_failed_ping_pong&#34;, &#34;websocket_received_inbound_traffic&#34;, &#34;websocket_connection_unused&#34;, &#34;websocket_internal_error&#34;, &#34;websocket_network_timeout&#34;, &#34;websocket_network_error&#34;
            type (str, optional): Filters subscriptions by subscription type name
            user_id (str, optional): Filter subscriptions by user ID

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[EventSubSubscription]
        &#34;&#34;&#34;

        url = ENDPOINT_EVENTSUB_SUBSCRIPTION
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if status != &#34;&#34;:
            params[&#34;status&#34;] = status

        if type != &#34;&#34;:
            params[&#34;type&#34;] = type

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            subscriptions = []

            for subscription in response.json()[&#34;data&#34;]:
                subscriptions.append(
                    EventSubSubscription(
                        subscription[&#34;id&#34;],
                        subscription[&#34;status&#34;],
                        subscription[&#34;type&#34;],
                        subscription[&#34;version&#34;],
                        subscription[&#34;condition&#34;],
                        subscription[&#34;created_at&#34;],
                        subscription[&#34;transport&#34;],
                        subscription[&#34;cost&#34;],
                    )
                )

            return subscriptions

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_top_games(self, first=20):
        &#34;&#34;&#34;
        Gets games sorted by number of current viewers on Twitch, most popular first

        Args:
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/games/top&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        games = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for game in response[&#34;data&#34;]:
                    games.append(
                        Game(
                            game[&#34;id&#34;],
                            game[&#34;name&#34;],
                            game[&#34;box_art_url&#34;],
                            game[&#34;igdb_id&#34;],
                        )
                    )

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return games

    def get_games(
        self, id: list[str] = [], name: list[str] = [], igdb_id: list[str] = []
    ) -&gt; list[Game]:
        &#34;&#34;&#34;
        Gets information about specified categories or games

        Args:
            id (list[str]): The ID of the category or game to get
                Maximum: 100
            name (list[str]): The name of the category or game to get
                Maximum: 100
            igdb_id (list[str]): The IGDB ID of the game to get
                Maximum: 100

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Game]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/games&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if len(name) &gt; 0:
            params[&#34;name&#34;] = name

        if len(igdb_id) &gt; 0:
            params[&#34;igdb_id&#34;] = igdb_id

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            games = []

            for game in response.json()[&#34;data&#34;]:
                games.append(
                    Game(game[&#34;id&#34;], game[&#34;name&#34;], game[&#34;box_art_url&#34;], game[&#34;igdb_id&#34;])
                )

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return games

    def get_creator_goals(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets the broadcaster’s list of active goals
        Use this to get the current progress of each goal

        Args:
            broadcaster_id (str): The ID of the broadcaster that created the goals

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/goals&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_channel_guest_star_settings(
        self, broadcaster_id: str, moderator_id: str
    ) -&gt; dict:
        &#34;&#34;&#34;
        Gets the channel settings for configuration of the Guest Star feature for a particular host

        Args:
            broadcaster_id (str): The ID of the broadcaster you want to get guest star settings for
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user ID in the user access token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/guest_star/channel_settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_channel_guest_star_settings(
        self,
        broadcaster_id: str,
        is_moderator_send_live_enabled: bool = None,
        slot_count: int = None,
        is_browser_source_audio_enabled: bool = None,
        group_layout: str = &#34;&#34;,
        regenerate_browser_sources: bool = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Mutates the channel settings for configuration of the Guest Star feature for a particular host

        Args:
            broadcaster_id (str): The ID of the broadcaster you want to update Guest Star settings for
            is_moderator_send_live_enabled (bool): Flag determining if Guest Star moderators have access to control whether a guest is live once assigned to a slot
            slot_count (int): Number of slots the Guest Star call interface will allow the host to add to a call.
                Required to be between 1 and 6
            is_browser_source_audio_enabled (bool): Flag determining if Browser Sources subscribed to sessions on this channel should output audio
            group_layout (str): This setting determines how the guests within a session should be laid out within the browser source
                Possible values: TILED_LAYOUT, SCREENSHARE_LAYOUT, HORIZONTAL_LAYOUT, VERTICAL_LAYOUT
            regenerate_browser_sources (bool): Flag determining if Guest Star should regenerate the auth token associated with the channel’s browser sources
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/guest_star/channel_settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id}

        if is_moderator_send_live_enabled is not None:
            data[&#34;is_moderator_send_live_enabled&#34;] = is_moderator_send_live_enabled

        if slot_count is not None:
            data[&#34;slot_count&#34;] = slot_count

        if is_browser_source_audio_enabled is not None:
            data[&#34;is_browser_source_audio_enabled&#34;] = is_browser_source_audio_enabled

        if group_layout != &#34;&#34;:
            data[&#34;group_layout&#34;] = group_layout

        if regenerate_browser_sources is not None:
            data[&#34;regenerate_browser_sources&#34;] = regenerate_browser_sources

        requests.put(url, headers=headers, json=data)

    def get_guest_star_session(
        self, broadcaster_id: str, moderator_id: str
    ) -&gt; GuestStarSession:
        &#34;&#34;&#34;
        Gets information about an ongoing Guest Star session for a particular channel

        Args:
            broadcaster_id (str): ID for the user hosting the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user ID in the user access token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            GuestStarSession
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_SESSION
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()[&#34;data&#34;][0]

            return GuestStarSession(response[&#34;id&#34;], response[&#34;guests&#34;])

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;data&#34;][&#34;message&#34;])

    def create_guest_star_session(self, broadcaster_id: str) -&gt; GuestStarSession:
        &#34;&#34;&#34;
        Programmatically creates a Guest Star session on behalf of the broadcaster

        Args:
            broadcaster_id (str): The ID of the broadcaster you want to create a Guest Star session for
                Provided broadcaster_id must match the user_id in the auth token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            GuestStarSession
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_SESSION
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            response = response.json()[&#34;data&#34;][0]

            return GuestStarSession(response[&#34;id&#34;], response[&#34;guests&#34;])

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;data&#34;][&#34;message&#34;])

    def end_guest_star_session(
        self, broadcaster_id: str, session_id: str
    ) -&gt; GuestStarSession:
        &#34;&#34;&#34;
        Programmatically ends a Guest Star session on behalf of the broadcaster

        Args:
            broadcaster_id (str): The ID of the broadcaster you want to end a Guest Star session for
                Provided broadcaster_id must match the user_id in the auth token
            session_id (str): ID for the session to end on behalf of the broadcaster

        Raises:
            twitchpy.errors.ClientError

        Returns:
            GuestStarSession
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_SESSION
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;session_id&#34;: session_id}

        response = requests.delete(url, headers=headers, data=data)

        if response.ok:
            response = response.json()[&#34;data&#34;][0]

            return GuestStarSession(response[&#34;id&#34;], response[&#34;guests&#34;])

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;data&#34;][&#34;message&#34;])

    def get_guest_star_invites(
        self, broadcaster_id: str, moderator_id: str, session_id: str
    ) -&gt; list[dict]:
        &#34;&#34;&#34;
        Provides a list of pending invites to a Guest Star session, including the invitee’s ready status while joining the waiting room

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user_id in the user access token
            session_id (str): The session ID to query for invite status

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[dict]
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_INVITES
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
        }

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def send_guest_star_invite(
        self, broadcaster_id: str, moderator_id: str, session_id: str, guest_id: str
    ) -&gt; None:
        &#34;&#34;&#34;
        Sends an invite to a specified guest on behalf of the broadcaster for a Guest Star session in progress

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user_id in the user access token
            session_id (str): The session ID for the invite to be sent on behalf of the broadcaster
            guest_id (str): Twitch User ID for the guest to invite to the Guest Star session
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_INVITES
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
            &#34;guest_id&#34;: guest_id,
        }

        requests.post(url, headers=headers, json=payload)

    def delete_guest_star_invite(
        self, broadcaster_id: str, moderator_id: str, session_id: str, guest_id: str
    ) -&gt; None:
        &#34;&#34;&#34;
        Revokes a previously sent invite for a Guest Star session

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user_id in the user access token
            session_id (str): The ID of the session for the invite to be revoked on behalf of the broadcaster
            guest_id (str): Twitch User ID for the guest to revoke the Guest Star session invite from
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_INVITES
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
            &#34;guest_id&#34;: guest_id,
        }

        requests.delete(url, headers=headers, data=data)

    def assign_guest_star_slot(
        self,
        broadcaster_id: str,
        moderator_id: str,
        session_id: str,
        guest_id: str,
        slot_id: str,
    ) -&gt; None:
        &#34;&#34;&#34;
        Allows a previously invited user to be assigned a slot within the active Guest Star session, once that guest has indicated they are ready to join

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user_id in the user access token
            session_id (str): The ID of the Guest Star session in which to assign the slot
            guest_id (str): The Twitch User ID corresponding to the guest to assign a slot in the session
                This user must already have an invite to this session, and have indicated that they are ready to join
            slot_id (str): The slot assignment to give to the user
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_SLOT
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
            &#34;guest_id&#34;: guest_id,
            &#34;slot_id&#34;: slot_id,
        }

        requests.post(url, headers=headers, json=payload)

    def update_guest_star_slot(
        self,
        broadcaster_id: str,
        moderator_id: str,
        session_id: str,
        source_slot_id: str,
        destination_slot_id: str = &#34;&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;
        Allows a user to update the assigned slot for a particular user within the active Guest Star session

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user_id in the user access token
            session_id (str): The ID of the Guest Star session in which to update slot settings
            source_slot_id (str): The slot assignment previously assigned to a user
            destination_slot_id (str): The slot to move this user assignment to
                If the destination slot is occupied, the user assigned will be swapped into source_slot_id
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_SLOT
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
            &#34;source_slot_id&#34;: source_slot_id,
        }

        if destination_slot_id != &#34;&#34;:
            data[&#34;destination_slot_id&#34;] = destination_slot_id

        requests.patch(url, headers=headers, data=data)

    def delete_guest_star_slot(
        self,
        broadcaster_id: str,
        moderator_id: str,
        session_id: str,
        guest_id: str,
        slot_id: str,
        should_reinvite_guest: str = &#34;&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;
        Allows a caller to remove a slot assignment from a user participating in an active Guest Star session

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user ID in the user access token
            session_id (str): The ID of the Guest Star session in which to remove the slot assignment
            guest_id (str): The Twitch User ID corresponding to the guest to remove from the session
            slot_id (str): The slot ID representing the slot assignment to remove from the session
            should_reinvite_guest (str): Flag signaling that the guest should be reinvited to the session, sending them back to the invite queue
        &#34;&#34;&#34;

        url = ENDPOINT_GUEST_STAR_SLOT
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
            &#34;guest_id&#34;: guest_id,
            &#34;slot_id&#34;: slot_id,
        }

        if should_reinvite_guest != &#34;&#34;:
            data[&#34;should_reinvite_guest&#34;] = should_reinvite_guest

        requests.delete(url, headers=headers, data=data)

    def update_guest_star_slot_settings(
        self,
        broadcaster_id: str,
        moderator_id: str,
        session_id: str,
        slot_id: str,
        is_audio_enabled: bool = None,
        is_video_enabled: bool = None,
        is_live: bool = None,
        volume: int = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Allows a user to update slot settings for a particular guest within a Guest Star session, such as allowing the user to share audio or video within the call as a host

        Args:
            broadcaster_id (str): The ID of the broadcaster running the Guest Star session
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user ID in the user access token
            session_id (str): The ID of the Guest Star session in which to update a slot’s settings
            slot_id (str): The slot assignment that has previously been assigned to a user
            is_audio_enabled (bool): Flag indicating whether the slot is allowed to share their audio with the rest of the session
            is_video_enabled (bool): Flag indicating whether the slot is allowed to share their video with the rest of the session
            is_live (bool): Flag indicating whether the user assigned to this slot is visible/can be heard from any public subscriptions
            volume (int): Value from 0-100 that controls the audio volume for shared views containing the slot
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/guest_star/slot_settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;session_id&#34;: session_id,
            &#34;slot_id&#34;: slot_id,
        }

        if is_audio_enabled is not None:
            data[&#34;is_audio_enabled&#34;] = is_audio_enabled

        if is_video_enabled is not None:
            data[&#34;is_video_enabled&#34;] = is_video_enabled

        if is_live is not None:
            data[&#34;is_live&#34;] = is_live

        if volume is not None:
            data[&#34;volume&#34;] = volume

        requests.patch(url, headers=headers, data=data)

    def get_hype_train_events(
        self, broadcaster_id: str, first: int = 1
    ) -&gt; list[HypeTrainEvent]:
        &#34;&#34;&#34;
        Gets the information of the most recent Hype Train of the given channel ID
        When there is currently an active Hype Train, it returns information about that Hype Train
        When there is currently no active Hype Train, it returns information about the most recent Hype Train
        After 5 days, if no Hype Train has been active, the endpoint will return an empty response

        Args:
            broadcaster_id (str): User ID of the broadcaster
                Must match the User ID in the Bearer token if User Token is used
            first (int, optional): Maximum number of objects to return
                Default: 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[HypeTrainEvent]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/hypetrain/events&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        cursor = &#34;&#34;
        calls = math.ceil(first / 100)
        events = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if cursor != &#34;&#34;:
                params[&#34;cursor&#34;] = cursor

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for event in response[&#34;data&#34;]:
                    events.append(
                        HypeTrainEvent(
                            event[&#34;id&#34;],
                            event[&#34;event_type&#34;],
                            event[&#34;event_timestamp&#34;],
                            event[&#34;version&#34;],
                            event[&#34;event_data&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and response[&#34;pagination&#34;] is not None:
                    cursor = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return events

    def check_automod_status(
        self, broadcaster_id: str, msg_id: str, msg_user: str
    ) -&gt; list[dict]:
        &#34;&#34;&#34;
        Determines whether a string message meets the channel’s AutoMod requirements

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token
            msg_id (str): Developer-generated identifier for mapping messages to results
            msg_user (str): Message text

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[dict]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/enforcements/status&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;data&#34;: [{&#34;msg_id&#34;: msg_id, &#34;msg_user&#34;: msg_user}],
        }

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def manage_held_automod_messages(self, user_id, msg_id, action):
        &#34;&#34;&#34;
        Allow or deny a message that was held for review by AutoMod

        Args:
            user_id (str): The moderator who is approving or rejecting the held message
                           Must match the user_id in the user OAuth token
            msg_id (str): ID of the message to be allowed or denied
            action (str): The action to take for the message
                          Must be &#34;ALLOW&#34; or &#34;DENY&#34;
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/automod/message&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;user_id&#34;: user_id, &#34;msg_id&#34;: msg_id, &#34;action&#34;: action}

        requests.post(url, headers=headers, json=payload)

    def get_automod_settings(self, broadcaster_id, moderator_id):
        &#34;&#34;&#34;
        Gets the broadcaster’s AutoMod settings, which are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster whose AutoMod settings you want to get
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to get their own AutoMod settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/automod/settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_automod_settings(
        self,
        broadcaster_id,
        moderator_id,
        aggression=None,
        bullying=None,
        disability=None,
        misogyny=None,
        overall_level=None,
        race_ethnicity_or_religion=None,
        sex_based_terms=None,
        sexuality_sex_or_gender=None,
        swearing=None,
    ):
        &#34;&#34;&#34;
        Updates the broadcaster’s AutoMod settings, which are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster whose AutoMod settings you want to update
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to update their own AutoMod settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
            aggression (int, optional): The Automod level for hostility involving aggression
            bullying (int, optional): The Automod level for hostility involving name calling or insults
            disability (int, optional): The Automod level for discrimination against disability
            misogyny (int, optional): The Automod level for discrimination against women
            overall_level (int, optional): The default AutoMod level for the broadcaster
            race_ethnicity_or_religion (int, optional): The Automod level for racial discrimination
            sex_based_terms (int, optional): The Automod level for sexual content
            sexuality_sex_or_gender (int, optional): The AutoMod level for discrimination based on sexuality, sex, or gender
            swearing (int, optional): The Automod level for profanity

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/automod/settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        if aggression is not None:
            data[&#34;aggression&#34;] = aggression

        if bullying is not None:
            data[&#34;bullying&#34;] = bullying

        if disability is not None:
            data[&#34;disability&#34;] = disability

        if misogyny is not None:
            data[&#34;misogyny&#34;] = misogyny

        if overall_level is not None:
            data[&#34;overall_level&#34;] = overall_level

        if race_ethnicity_or_religion is not None:
            data[&#34;race_ethnicity_or_religion&#34;] = race_ethnicity_or_religion

        if sex_based_terms is not None:
            data[&#34;sex_based_terms&#34;] = sex_based_terms

        if sexuality_sex_or_gender is not None:
            data[&#34;sexuality_sex_or_gender&#34;] = sexuality_sex_or_gender

        if swearing is not None:
            data[&#34;swearing&#34;] = swearing

        response = requests.put(url, headers=headers, json=data)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_banned_users(self, broadcaster_id, user_id=[], first=20):
        &#34;&#34;&#34;
        Returns all banned and timed-out users in a channel

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token
            user_id (list, optional): Filters the results and only returns a status object for users who are banned in this channel and have a matching user_id
                                     Maximum: 100
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/banned&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(user_id) &gt; 0:
            params[&#34;user_id&#34;] = user_id

        if first != 20:
            params[&#34;first&#34;] = first

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        users = []

        for call in range(calls):
            if first - (100 * call) &gt; 100:
                params[&#34;first&#34;] = 100

            else:
                params[&#34;first&#34;] = first - (100 * call)

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                users.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return users

    def ban_user(self, broadcaster_id, moderator_id, reason, user_id, duration=None):
        &#34;&#34;&#34;
        Bans a user from participating in a broadcaster’s chat room, or puts them in a timeout
        If the user is currently in a timeout, you can use this method to change the duration of the timeout or ban them altogether
        If the user is currently banned, you cannot call this method to put them in a timeout instead

        Args:
            broadcaster_id (str): The ID of the broadcaster whose chat room the user is being banned from
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to ban the user (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
            reason (reason): The reason the user is being banned or put in a timeout
                             The text is user defined and limited to a maximum of 500 characters
            user_id (str): The ID of the user to ban or put in a timeout
            duration (int, optional): To ban a user indefinitely, don’t include this field
                                      To put a user in a timeout, include this field and specify the timeout period, in seconds
                                      The minimum timeout is 1 second and the maximum is 1,209,600 seconds (2 weeks)
                                      To end a user’s timeout early, set this field to 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/bans&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        data = {&#34;reason&#34;: reason, &#34;user_id&#34;: user_id}

        if duration is not None:
            data[&#34;duration&#34;] = duration

        payload[&#34;data&#34;] = data

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def unban_user(self, broadcaster_id, moderator_id, user_id):
        &#34;&#34;&#34;
        Removes the ban or timeout that was placed on the specified user

        Args:
            broadcaster_id (str): The ID of the broadcaster whose chat room the user is banned from chatting in
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to remove the ban (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
            user_id (str): The ID of the user to remove the ban or timeout from

        Raises:
            twitchpy.errors.ClientError
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/bans&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;user_id&#34;: user_id,
        }

        requests.delete(url, headers=headers, data=data)

    def get_blocked_terms(self, broadcaster_id, moderator_id, first=20):
        &#34;&#34;&#34;
        Gets the broadcaster’s list of non-private, blocked words or phrases
        These are the terms that the broadcaster or moderator added manually, or that were denied by AutoMod

        Args:
            broadcaster_id (str): The ID of the broadcaster whose blocked terms you’re getting
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to get their own block terms (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
            first (int, optional): The maximum number of blocked terms to return per page in the response
                                   The minimum page size is 1 blocked term per page and the maximum is 100
                                   The default is 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = ENDPOINT_MODERATION_BLOCKED_TERMS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        if first != 20:
            params[&#34;first&#34;] = first

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        blocked_terms = []

        for call in range(calls):
            if first - (100 * call) &gt; 100:
                params[&#34;first&#34;] = 100

            else:
                params[&#34;first&#34;] = first - (100 * call)

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                blocked_terms.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return blocked_terms

    def add_blocked_term(self, broadcaster_id, moderator_id, text):
        &#34;&#34;&#34;
        Adds a word or phrase to the broadcaster’s list of blocked terms
        These are the terms that broadcasters don’t want used in their chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster that owns the list of blocked terms
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to add the blocked term (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
            text (str): The word or phrase to block from being used in the broadcaster’s chat room
                        The term must contain a minimum of 2 characters and may contain up to a maximum of 500 characters
                        Terms can use a wildcard character (*)
                        The wildcard character must appear at the beginning or end of a word, or set of characters

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = ENDPOINT_MODERATION_BLOCKED_TERMS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;text&#34;: text,
        }

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def remove_blocked_term(self, broadcaster_id, id, moderator_id):
        &#34;&#34;&#34;
        Removes the word or phrase that the broadcaster is blocking users from using in their chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster that owns the list of blocked terms
            id (str): The ID of the blocked term you want to delete
            moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                                This ID must match the user ID associated with the user OAuth token
                                If the broadcaster wants to delete the blocked term (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
        &#34;&#34;&#34;

        url = ENDPOINT_MODERATION_BLOCKED_TERMS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;id&#34;: id,
            &#34;moderator_id&#34;: moderator_id,
        }

        requests.delete(url, headers=headers, data=data)

    def delete_chat_messages(
        self, broadcaster_id: str, moderator_id: str, message_id: str = &#34;&#34;
    ) -&gt; None:
        &#34;&#34;&#34;
        Removes a single chat message or all chat messages from the broadcaster’s chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster that owns the chat room to remove messages from
            moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
                This ID must match the user ID in the user access token
            message_id (str, optional): The ID of the message to remove
                If not specified, the request removes all messages in the broadcaster’s chat room
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/chat&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        if message_id != &#34;&#34;:
            data[&#34;message_id&#34;] = message_id

        requests.delete(url, headers=headers, data=data)

    def get_moderators(self, broadcaster_id, user_id=[], first=20):
        &#34;&#34;&#34;
        Returns all moderators in a channel

        Args:
            broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token
            user_id (list, optional): Filters the results and only returns a status object for users who are moderators in this channel and have a matching user_id
                                      Maximum: 100
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = ENDPOINT_MODERATORS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(user_id) &gt; 0:
            params[&#34;user_id&#34;] = user_id

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        ids = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for user in response[&#34;data&#34;]:
                    ids.append(user[&#34;user_id&#34;])

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return self.get_users(id=ids)

    def add_channel_moderator(self, broadcaster_id: str, user_id: str) -&gt; None:
        &#34;&#34;&#34;
        Adds a moderator to the broadcaster’s chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster that owns the chat room
                This ID must match the user ID in the access token
            user_id (str): The ID of the user to add as a moderator in the broadcaster’s chat room
        &#34;&#34;&#34;

        url = ENDPOINT_MODERATORS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;user_id&#34;: user_id}

        requests.post(url, headers=headers, json=payload)

    def remove_channel_moderator(self, broadcaster_id: str, user_id: str) -&gt; None:
        &#34;&#34;&#34;
        Removes a moderator from the broadcaster’s chat room

        Args:
            broadcaster_id (str): The ID of the broadcaster that owns the chat room
                This ID must match the user ID in the access token
            user_id (str): The ID of the user to remove as a moderator from the broadcaster’s chat room
        &#34;&#34;&#34;

        url = ENDPOINT_MODERATORS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;user_id&#34;: user_id}

        requests.delete(url, headers=headers, data=data)

    def get_vips(
        self, broadcaster_id: str, user_id: list[str] = [], first: int = 20
    ) -&gt; list[User]:
        &#34;&#34;&#34;
        Gets a list of the broadcaster’s VIPs

        Args:
            broadcaster_id (str): The ID of the broadcaster whose list of VIPs you want to get
                This ID must match the user ID in the access token
            user_id (list[str]): Filters the list for specific VIPs
                Maximum: 100
            first (int): The number of items to return
                Minimum: 1
                Maximum: 100

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[User]
        &#34;&#34;&#34;

        url = ENDPOINT_VIPS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(user_id) &gt; 0:
            params[&#34;user_id&#34;] = user_id

        after = &#34;&#34;
        calls = math.ceil(first / 20)
        users = []

        for call in range(calls):
            params[&#34;first&#34;] = min(20, first - (20 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                if response[&#34;data&#34;] is not None:
                    users.append(
                        self.get_users(
                            id=[user[&#34;user_id&#34;] for user in response[&#34;data&#34;]]
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return users

    def add_channel_vip(self, user_id: str, broadcaster_id: str) -&gt; None:
        &#34;&#34;&#34;
        Adds the specified user as a VIP in the broadcaster’s channel

        Args:
            user_id (str): The ID of the user to give VIP status to
            broadcaster_id (str): The ID of the broadcaster that’s adding the user as a VIP
                This ID must match the user ID in the access token
        &#34;&#34;&#34;

        url = ENDPOINT_VIPS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {&#34;user_id&#34;: user_id, &#34;broadcaster_id&#34;: broadcaster_id}

        requests.post(url, headers=headers, json=payload)

    def remove_channel_vip(self, user_id: str, broadcaster_id: str) -&gt; None:
        &#34;&#34;&#34;
        Removes the specified user as a VIP in the broadcaster’s channel

        Args:
            user_id (str): The ID of the user to remove VIP status from
            broadcaster_id (str): The ID of the user to remove VIP status from
        &#34;&#34;&#34;

        url = ENDPOINT_VIPS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;user_id&#34;: user_id, &#34;broadcaster_id&#34;: broadcaster_id}

        requests.delete(url, headers=headers, data=data)

    def update_shield_mode_status(
        self, broadcaster_id: str, moderator_id: str, is_active: bool
    ) -&gt; dict:
        &#34;&#34;&#34;
        Activates or deactivates the broadcaster’s Shield Mode

        Args:
            broadcaster_id (str): The ID of the broadcaster whose Shield Mode you want to activate or deactivate
            moderator_id (str): The ID of the broadcaster or a user that is one of the broadcaster’s moderators
                This ID must match the user ID in the access token
            is_active (bool): A Boolean value that determines whether to activate Shield Mode

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/shield_mode&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        data = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;moderator_id&#34;: moderator_id,
            &#34;is_active&#34;: is_active,
        }

        response = requests.put(url, headers=headers, data=data)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_shield_mode_status(self, broadcaster_id: str, moderator_id: str) -&gt; dict:
        &#34;&#34;&#34;
        Gets the broadcaster’s Shield Mode activation status

        Args:
            broadcaster_id (str): The ID of the broadcaster whose Shield Mode activation status you want to get
            moderator_id (str): The ID of the broadcaster or a user that is one of the broadcaster’s moderators
                This ID must match the user ID in the access token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/moderation/shield_mode&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_polls(self, broadcaster_id, id=[], first=20):
        &#34;&#34;&#34;
        Get information about all polls or specific polls for a Twitch channel
        Poll information is available for 90 days

        Args:
            broadcaster_id (str): The broadcaster running polls
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (list, optional): ID of a poll
                                 Maximum: 100
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = ENDPOINT_POLLS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        after = &#34;&#34;
        calls = math.ceil(first / 20)
        polls = []

        for call in range(calls):
            params[&#34;first&#34;] = min(20, first - (20 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                if response[&#34;data&#34;] is not None:
                    for poll in response[&#34;data&#34;]:
                        polls.append(
                            Poll(
                                poll[&#34;id&#34;],
                                poll[&#34;broadcaster_id&#34;],
                                poll[&#34;broadcaster_name&#34;],
                                poll[&#34;broadcaster_login&#34;],
                                poll[&#34;title&#34;],
                                poll[&#34;choices&#34;],
                                poll[&#34;bits_voting_enabled&#34;],
                                poll[&#34;bits_per_vote&#34;],
                                poll[&#34;channel_points_voting_enabled&#34;],
                                poll[&#34;channel_points_per_vote&#34;],
                                poll[&#34;status&#34;],
                                poll[&#34;duration&#34;],
                                poll[&#34;started_at&#34;],
                            )
                        )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return polls

    def create_poll(
        self,
        broadcaster_id: str,
        title: str,
        choices: list[str],
        duration: int,
        channel_points_voting_enabled: bool = False,
        channel_points_per_vote: int = 0,
    ) -&gt; Poll:
        &#34;&#34;&#34;
        Create a poll for a specific Twitch channel

        Args:
            broadcaster_id (str): The broadcaster running polls
                Provided broadcaster_id must match the user_id in the user OAuth token
            title (str): Question displayed for the poll
                Maximum: 60 characters
            choices (list): Array of the poll choices
                Minimum: 2 choices
                Maximum: 5 choices
            duration (int): Total duration for the poll (in seconds)
                Minimum: 15
                Maximum: 1800
            channel_points_voting_enabled (bool, optional): Indicates if Channel Points can be used for voting
                Default: false
            channel_points_per_vote (int, optional): Number of Channel Points required to vote once with Channel Points
                Minimum: 0
                Maximum: 1000000

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Poll
        &#34;&#34;&#34;

        url = ENDPOINT_POLLS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }

        choices_dicts = []

        for choice in choices:
            choices_dicts.append({&#34;title&#34;: choice})

        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;title&#34;: title,
            &#34;choices&#34;: choices_dicts,
            &#34;duration&#34;: duration,
        }

        if channel_points_voting_enabled is not False:
            payload[&#34;channel_points_voting_enabled&#34;] = channel_points_voting_enabled

        if channel_points_per_vote != 0:
            payload[&#34;channel_points_per_vote&#34;] = channel_points_per_vote

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            poll = response.json()[&#34;data&#34;][0]
            poll = Poll(
                poll[&#34;id&#34;],
                poll[&#34;broadcaster_id&#34;],
                poll[&#34;broadcaster_name&#34;],
                poll[&#34;broadcaster_login&#34;],
                poll[&#34;title&#34;],
                poll[&#34;choices&#34;],
                poll[&#34;channel_points_voting_enabled&#34;],
                poll[&#34;channel_points_per_vote&#34;],
                poll[&#34;status&#34;],
                poll[&#34;duration&#34;],
                poll[&#34;started_at&#34;],
            )

            return poll

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def end_poll(self, broadcaster_id, id, status):
        &#34;&#34;&#34;
        End a poll that is currently active

        Args:
            broadcaster_id (str): The broadcaster running polls
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (str): ID of the poll
            status (str): The poll status to be set
                          Valid values: &#34;TERMINATED&#34;, &#34;ARCHIVED&#34;

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Poll
        &#34;&#34;&#34;

        url = ENDPOINT_POLLS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id, &#34;status&#34;: status}

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            poll = response.json()[&#34;data&#34;][0]
            poll = Poll(
                poll[&#34;id&#34;],
                poll[&#34;broadcaster_id&#34;],
                poll[&#34;broadcaster_name&#34;],
                poll[&#34;broadcaster_login&#34;],
                poll[&#34;title&#34;],
                poll[&#34;choices&#34;],
                poll[&#34;bits_voting_enabled&#34;],
                poll[&#34;bits_per_vote&#34;],
                poll[&#34;channel_points_voting_enabled&#34;],
                poll[&#34;channel_points_per_vote&#34;],
                poll[&#34;status&#34;],
                poll[&#34;duration&#34;],
                poll[&#34;started_at&#34;],
            )

            return poll

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_predictions(self, broadcaster_id, id=[], first=20):
        &#34;&#34;&#34;
        Get information about all Channel Points Predictions or specific Channel Points Predictions for a Twitch channel

        Args:
            broadcaster_id (str): The broadcaster running Predictions
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (str, optional): ID of a Prediction
                                Maximum: 100
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = ENDPOINT_PREDICTIONS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        after = &#34;&#34;
        calls = math.ceil(first / 20)
        predictions = []

        for call in range(calls):
            params[&#34;first&#34;] = min(20, first - (20 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for prediction in response[&#34;data&#34;]:
                    predictions.append(
                        Prediction(
                            prediction[&#34;id&#34;],
                            prediction[&#34;broadcaster_id&#34;],
                            prediction[&#34;broadcaster_name&#34;],
                            prediction[&#34;broadcaster_login&#34;],
                            prediction[&#34;title&#34;],
                            prediction[&#34;winning_outcome_id&#34;],
                            prediction[&#34;outcomes&#34;],
                            prediction[&#34;prediction_window&#34;],
                            prediction[&#34;status&#34;],
                            prediction[&#34;created_at&#34;],
                            prediction[&#34;ended_at&#34;],
                            prediction[&#34;locked_at&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return predictions

    def create_prediction(
        self,
        broadcaster_id: str,
        title: str,
        outcomes: list[str],
        prediction_window: int,
    ) -&gt; Prediction:
        &#34;&#34;&#34;
        Create a Channel Points Prediction for a specific Twitch channel

        Args:
            broadcaster_id (str): The broadcaster running Predictions
                Provided broadcaster_id must match the user_id in the user OAuth token
            title (str): Title for the Prediction
                Maximum: 45 characters
            outcomes (list[str]): The list of possible outcomes that the viewers may choose from
                Minimum: 2
                Maximum: 10
            prediction_window (int): Total duration for the Prediction (in seconds)
                Minimum: 1
                Maximum: 1800

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Prediction
        &#34;&#34;&#34;

        url = ENDPOINT_PREDICTIONS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;title&#34;: title,
            &#34;prediction_window&#34;: prediction_window,
        }

        outcomes_payload = []

        for outcome in outcomes:
            outcomes_payload.append({&#34;title&#34;: outcome})

        payload[&#34;outcomes&#34;] = outcomes_payload

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            prediction = response.json()[&#34;data&#34;][0]
            prediction = Prediction(
                prediction[&#34;id&#34;],
                prediction[&#34;broadcaster_id&#34;],
                prediction[&#34;broadcaster_name&#34;],
                prediction[&#34;broadcaster_login&#34;],
                prediction[&#34;title&#34;],
                prediction[&#34;winning_outcome_id&#34;],
                prediction[&#34;outcomes&#34;],
                prediction[&#34;prediction_window&#34;],
                prediction[&#34;status&#34;],
                prediction[&#34;created_at&#34;],
                prediction[&#34;ended_at&#34;],
                prediction[&#34;locked_at&#34;],
            )

            return prediction

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def end_prediction(self, broadcaster_id, id, status, winning_outcome_id=&#34;&#34;):
        &#34;&#34;&#34;
        Lock, resolve, or cancel a Channel Points Prediction
        Active Predictions can be updated to be &#34;locked&#34;, &#34;resolved&#34;, or &#34;canceled&#34;
        Locked Predictions can be updated to be &#34;resolved&#34; or &#34;canceled&#34;

        Args:
            broadcaster_id (str): The broadcaster running prediction events
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (str): ID of the Prediction
            status (str): The Prediction status to be set
                          Valid values: &#34;RESOLVED&#34;, &#34;CANCELED&#34;, &#34;LOCKED&#34;
            winning_outcome_id (str, optional): ID of the winning outcome for the Prediction
                                                This parameter is required if status is being set to RESOLVED

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Prediction
        &#34;&#34;&#34;

        url = ENDPOINT_PREDICTIONS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id, &#34;status&#34;: status}

        if winning_outcome_id != &#34;&#34;:
            data[&#34;winning_outcome_id&#34;] = winning_outcome_id

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            prediction = response.json()[&#34;data&#34;][0]
            prediction = Prediction(
                prediction[&#34;id&#34;],
                prediction[&#34;broadcaster_id&#34;],
                prediction[&#34;broadcaster_name&#34;],
                prediction[&#34;broadcaster_login&#34;],
                prediction[&#34;title&#34;],
                prediction[&#34;winning_outcome_id&#34;],
                prediction[&#34;outcomes&#34;],
                prediction[&#34;prediction_window&#34;],
                prediction[&#34;status&#34;],
                prediction[&#34;created_at&#34;],
                prediction[&#34;ended_at&#34;],
                prediction[&#34;locked_at&#34;],
            )

            return prediction

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def start_raid(self, from_broadcaster_id: str, to_broadcaster_id: str) -&gt; dict:
        &#34;&#34;&#34;
        Raid another channel by sending the broadcaster’s viewers to the targeted channel

        Args:
            from_broadcaster_id (str): The ID of the broadcaster that’s sending the raiding party
                This ID must match the user ID in the user access token
            to_broadcaster_id (str): The ID of the broadcaster to raid

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/raids&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;from_broadcaster_id&#34;: from_broadcaster_id,
            &#34;to_broadcaster_id&#34;: to_broadcaster_id,
        }

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def cancel_raid(self, broadcaster_id: str) -&gt; None:
        &#34;&#34;&#34;
        Cancel a pending raid

        Args:
            broadcaster_id (str): The ID of the broadcaster that initiated the raid
                This ID must match the user ID in the user access token
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/raids&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id}

        requests.delete(url, headers=headers, data=data)

    def get_channel_stream_schedule(
        self, broadcaster_id, id=[], start_time=&#34;&#34;, utc_offset=&#34;0&#34;, first=20
    ):
        &#34;&#34;&#34;
        Gets all scheduled broadcasts or specific scheduled broadcasts from a channel’s stream schedule
        Scheduled broadcasts are defined as &#34;stream segments&#34;

        Args:
            broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (str, optional): The ID of the stream segment to return
                                Maximum: 100
            start_time (str, optional): A timestamp in RFC3339 format to start returning stream segments from
                                        If not specified, the current date and time is used
            utc_offset (str, optional): A timezone offset for the requester specified in minutes
                                        If not specified, &#34;0&#34; is used for GMT
            first (int, optional): Maximum number of stream segments to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/schedule&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if start_time != &#34;&#34;:
            params[&#34;start_time&#34;] = start_time

        if utc_offset != &#34;0&#34;:
            params[&#34;utc_offset&#34;] = utc_offset

        after = &#34;&#34;
        calls = math.ceil(first / 25)
        schedules = []

        for call in range(calls):
            params[&#34;first&#34;] = min(25, first - (25 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for schedule in response[&#34;data&#34;]:
                    schedules.append(
                        StreamSchedule(
                            schedule[&#34;segments&#34;],
                            schedule[&#34;broadcaster_id&#34;],
                            schedule[&#34;broadcaster_name&#34;],
                            schedule[&#34;broadcaster_login&#34;],
                            schedule[&#34;vacation&#34;],
                        )
                    )

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return schedules

    def get_channel_icalendar(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets all scheduled broadcasts from a channel’s stream schedule as an iCalendar

        Args:
            broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule

        Returns:
            str
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/schedule/icalendar&#34;
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, params=params)

        if response.ok:
            return response.text

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_channel_stream_schedule(
        self,
        broadcaster_id,
        is_vacation_enabled=False,
        vacation_start_time=&#34;&#34;,
        vacation_end_time=&#34;&#34;,
        timezone=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Update the settings for a channel’s stream schedule
        This can be used for setting vacation details

        Args:
            broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            is_vacation_enabled (bool, optional): Indicates if Vacation Mode is enabled
                                                  Set to true to add a vacation or false to remove vacation from the channel streaming schedule
            vacation_start_time (str, optional): Start time for vacation specified in RFC3339 format
                                                 Required if is_vacation_enabled is set to true
            vacation_end_time (str, optional): End time for vacation specified in RFC3339 format
                                               Required if is_vacation_enabled is set to true
            timezone (str, optional): The timezone for when the vacation is being scheduled using the IANA time zone database format
                                      Required if is_vacation_enabled is set to true

        Raises:
            twitchpy.errors.ClientError
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/schedule/settings&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id}

        if is_vacation_enabled:
            data[&#34;is_vacation_enabled&#34;] = True

        if vacation_start_time != &#34;&#34;:
            data[&#34;vacation_start_time&#34;] = vacation_start_time

        if vacation_end_time != &#34;&#34;:
            data[&#34;vacation_end_time&#34;] = vacation_end_time

        if timezone != &#34;&#34;:
            data[&#34;timezone&#34;] = timezone

        requests.patch(url, headers=headers, data=data)

    def create_channel_stream_schedule_segment(
        self,
        broadcaster_id,
        start_time,
        timezone,
        is_recurring,
        duration=240,
        category_id=&#34;&#34;,
        title=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Create a single scheduled broadcast or a recurring scheduled broadcast for a channel’s stream schedule

        Args:
            broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            start_time (str): Start time for the scheduled broadcast specified in RFC3339 format
            timezone (str): The timezone of the application creating the scheduled broadcast using the IANA time zone database format
            is_recurring (bool): Indicates if the scheduled broadcast is recurring weekly
            duration (int, optional): Duration of the scheduled broadcast in minutes from the start_time
                                      Default: 240
            category_id (str, optional): Game/Category ID for the scheduled broadcast
            title (str, optional): Title for the scheduled broadcast
                                   Maximum: 140 characters

        Raises:
            twitchpy.errors.ClientError

        Returns:
            StreamSchedule
        &#34;&#34;&#34;

        url = ENDPOINT_SCHEDULE_SEGMENT
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        payload = {
            &#34;broadcaster_id&#34;: broadcaster_id,
            &#34;start_time&#34;: start_time,
            &#34;timezone&#34;: timezone,
            &#34;is_recurring&#34;: is_recurring,
        }

        if duration != 240:
            payload[&#34;duration&#34;] = duration

        if category_id != &#34;&#34;:
            payload[&#34;category_id&#34;] = category_id

        if title != &#34;&#34;:
            payload[&#34;title&#34;] = title

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            schedule = response.json()[&#34;data&#34;][0]
            schedule = StreamSchedule(
                schedule[&#34;segments&#34;],
                schedule[&#34;broadcaster_id&#34;],
                schedule[&#34;broadcaster_name&#34;],
                schedule[&#34;broadcaster_login&#34;],
                schedule[&#34;vacation&#34;],
            )

            return schedule

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_channel_stream_schedule_segment(
        self,
        broadcaster_id,
        id,
        start_time=&#34;&#34;,
        duration=240,
        category_id=&#34;&#34;,
        title=&#34;&#34;,
        is_canceled=False,
        timezone=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Update a single scheduled broadcast or a recurring scheduled broadcast for a channel’s stream schedule

        Args:
            broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (str): The ID of the streaming segment to update
            start_time (str, optional): Start time for the scheduled broadcast specified in RFC3339 format
            duration (int, optional): Duration of the scheduled broadcast in minutes from the start_time
                                      Default: 240
            category_id (str, optional): Game/Category ID for the scheduled broadcast
            title (str, optional): Title for the scheduled broadcast
                                   Maximum: 140 characters
            is_canceled (bool, optional): Indicated if the scheduled broadcast is canceled
            timezone (str, optional): The timezone of the application creating the scheduled broadcast using the IANA time zone database format

        Raises:
            twitchpy.errors.ClientError

        Returns:
            StreamSchedule
        &#34;&#34;&#34;

        url = ENDPOINT_SCHEDULE_SEGMENT
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id}

        if start_time != &#34;&#34;:
            data[&#34;start_time&#34;] = start_time

        if duration != 240:
            data[&#34;duration&#34;] = duration

        if category_id != &#34;&#34;:
            data[&#34;category_id&#34;] = category_id

        if title != &#34;&#34;:
            data[&#34;title&#34;] = title

        if is_canceled is not False:
            data[&#34;is_canceled&#34;] = is_canceled

        if timezone != &#34;&#34;:
            data[&#34;timezone&#34;] = timezone

        response = requests.patch(url, headers=headers, data=data)

        if response.ok:
            schedule = response.json()[&#34;data&#34;][0]
            schedule = StreamSchedule(
                schedule[&#34;segments&#34;],
                schedule[&#34;broadcaster_id&#34;],
                schedule[&#34;broadcaster_name&#34;],
                schedule[&#34;broadcaster_login&#34;],
                schedule[&#34;vacation&#34;],
            )

            return schedule

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def delete_channel_stream_schedule_segment(self, broadcaster_id, id):
        &#34;&#34;&#34;
        Delete a single scheduled broadcast or a recurring scheduled broadcast for a channel’s stream schedule

        Args:
            broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                                  Provided broadcaster_id must match the user_id in the user OAuth token
            id (str): The ID of the streaming segment to delete
        &#34;&#34;&#34;

        url = ENDPOINT_SCHEDULE_SEGMENT
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id}

        requests.delete(url, headers=headers, data=data)

    def search_categories(self, query, first=20):
        &#34;&#34;&#34;
        Returns a list of games or categories that match the query via name either entirely or partially

        Args:
            query (str): URI encoded search query
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/search/categories&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;query&#34;: query}

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        games = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for game in response[&#34;data&#34;]:
                    games.append(
                        Game(game[&#34;id&#34;], game[&#34;name&#34;], box_art_url=game[&#34;box_art_url&#34;])
                    )

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return games

    def search_channels(
        self, query: str, first: int = 20, live_only: bool = False
    ) -&gt; list[Channel]:
        &#34;&#34;&#34;
        Gets the channels that match the specified query and have streamed content within the past 6 months
        To match, the beginning of the broadcaster’s name or category must match the query string

        Args:
            query (str): The URI-encoded search string
            first (int): The maximum number of items to return
                Minimum: 1
            live_only (bool): A Boolean value that determines whether the response includes only channels that are currently streaming live

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Channel]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/search/channels&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;query&#34;: query}

        if live_only is not False:
            params[&#34;live_only&#34;] = live_only

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        channels = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for channel in response[&#34;data&#34;]:
                    channels.append(
                        Channel(
                            channel[&#34;id&#34;],
                            channel[&#34;broadcaster_login&#34;],
                            channel[&#34;display_name&#34;],
                            channel[&#34;game_id&#34;],
                            channel[&#34;game_name&#34;],
                            channel[&#34;title&#34;],
                            broadcaster_language=channel[&#34;broadcaster_language&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return channels

    def get_stream_key(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets the channel stream key for a user

        Args:
            broadcaster_id (str): User ID of the broadcaster

        Raises:
            twitchpy.errors.ClientError

        Returns:
            str
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/streams/key&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0][&#34;stream_key&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_streams(
        self,
        user_id: str | list[str] = &#34;&#34;,
        user_login: str | list[str] = &#34;&#34;,
        game_id: str | list[str] = &#34;&#34;,
        type: str = &#34;all&#34;,
        language: str | list[str] = &#34;&#34;,
        first: int = 20,
    ) -&gt; list[Stream]:
        &#34;&#34;&#34;
        Gets a list of all streams
        The list is in descending order by the number of viewers watching the stream

        Args:
            user_id (str | list[str]): A user ID used to filter the list of streams
                Maximum: 100
            user_login (str | list[str]): A user login name used to filter the list of streams
                Maximum: 100
            game_id (str | list[str]): A game (category) ID used to filter the list of streams
                Maximum: 100
            type (str): The type of stream to filter the list of streams by
                Possible values: all, live
            language (str | list[str]): A language code used to filter the list of streams
                Maximum: 100
            first (int): The maximum number of items to return
                Minimum: 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Stream]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/streams&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        if user_login != &#34;&#34;:
            params[&#34;user_login&#34;] = user_login

        if game_id != &#34;&#34;:
            params[&#34;game_id&#34;] = game_id

        if type != &#34;all&#34;:
            params[&#34;type&#34;] = type

        if language != &#34;&#34;:
            params[&#34;language&#34;] = language

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        streams = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for stream in response[&#34;data&#34;]:
                    streams.append(
                        Stream(
                            stream[&#34;id&#34;],
                            stream[&#34;user_id&#34;],
                            stream[&#34;user_login&#34;],
                            stream[&#34;user_name&#34;],
                            stream[&#34;game_id&#34;],
                            stream[&#34;game_name&#34;],
                            stream[&#34;type&#34;],
                            stream[&#34;title&#34;],
                            stream[&#34;tags&#34;],
                            stream[&#34;viewer_count&#34;],
                            stream[&#34;started_at&#34;],
                            stream[&#34;language&#34;],
                            stream[&#34;thumbnail_url&#34;],
                            stream[&#34;is_mature&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return streams

    def get_followed_streams(self, user_id: str, first: int = 100) -&gt; list[Stream]:
        &#34;&#34;&#34;
        Gets the list of broadcasters that the user follows and that are streaming live

        Args:
            user_id (str): The ID of the user whose list of followed streams you want to get
                This ID must match the user ID in the access token
            first (int): The maximum number of items to return
                Minimum: 1

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list[Stream]
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/streams/followed&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;user_id&#34;: user_id}

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        streams = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for stream in response[&#34;data&#34;]:
                    streams.append(
                        Stream(
                            stream[&#34;id&#34;],
                            stream[&#34;user_id&#34;],
                            stream[&#34;user_login&#34;],
                            stream[&#34;user_name&#34;],
                            stream[&#34;game_id&#34;],
                            stream[&#34;game_name&#34;],
                            stream[&#34;type&#34;],
                            stream[&#34;title&#34;],
                            stream[&#34;tags&#34;],
                            stream[&#34;viewer_count&#34;],
                            stream[&#34;started_at&#34;],
                            stream[&#34;language&#34;],
                            stream[&#34;thumbnail_url&#34;],
                            stream[&#34;is_mature&#34;],
                        )
                    )

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return streams

    def create_stream_marker(self, user_id, description=&#34;&#34;):
        &#34;&#34;&#34;
        Creates a marker in the stream of a user specified by user ID
        A marker is an arbitrary point in a stream that the broadcaster wants to mark; e.g., to easily return to later
        The marker is created at the current timestamp in the live broadcast when the request is processed

        Args:
            user_id (str): ID of the broadcaster in whose live stream the marker is created
            description (str, optional): Description of or comments on the marker
                                         Max length is 140 characters

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/streams/markers&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {&#34;user_id&#34;: user_id}

        if description != &#34;&#34;:
            payload[&#34;description&#34;] = description

        response = requests.post(url, headers=headers, json=payload)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_stream_markers(self, user_id=&#34;&#34;, video_id=&#34;&#34;, first=20):
        &#34;&#34;&#34;
        Gets a list of markers for either a specified user’s most recent stream or a specified VOD/video (stream)
        A marker is an arbitrary point in a stream that the broadcaster wants to mark; e.g., to easily return to later
        The only markers returned are those created by the user identified by the Bearer token
        Only one of user_id and video_id must be specified

        Args:
            user_id (str, optional): ID of the broadcaster from whose stream markers are returned
            video_id (str, optional): ID of the VOD/video whose stream markers are returned
            first (int, optional): Number of values to be returned when getting videos by user or game ID
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/streams/markers&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        if video_id != &#34;&#34;:
            params[&#34;video_id&#34;] = video_id

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        markers = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                markers.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return markers

    def get_broadcaster_subscriptions(self, broadcaster_id, user_id=[], first=20):
        &#34;&#34;&#34;
        Get all of a broadcaster’s subscriptions

        Args:
            broadcaster_id (str): User ID of the broadcaster
                                  Must match the User ID in the Bearer token
            user_id (list, optional): Filters results to only include potential subscriptions made by the provided user ID
                                      Accepts up to 100 values
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/subscriptions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if len(user_id) &gt; 0:
            params[&#34;user_id&#34;] = user_id

        if first != 20:
            params[&#34;first&#34;] = first

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        subscriptions = []

        for call in range(calls):
            if first - (100 * call) &gt; 100:
                params[&#34;first&#34;] = 100

            else:
                params[&#34;first&#34;] = first - (100 * call)

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                subscriptions.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return subscriptions

    def check_user_subscription(self, broadcaster_id, user_id):
        &#34;&#34;&#34;
        Checks if a specific user (user_id) is subscribed to a specific channel (broadcaster_id)

        Args:
            broadcaster_id (str): User ID of an Affiliate or Partner broadcaster
            user_id (str): User ID of a Twitch viewer

        Raises:
            twitchpy.errors.ClientError

        Returns:
            dict
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/subscriptions/user&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;user_id&#34;: user_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;][0]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_all_stream_tags(self, first=20, tag_id=[]):
        &#34;&#34;&#34;
        Gets the list of all stream tags defined by Twitch

        Args:
            first (int, optional): Maximum number of objects to return
                                   Default: 20
            tag_id (list, optional): ID of a tag

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/tags/streams&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if len(tag_id) &gt; 0:
            params[&#34;tag_id&#34;] = tag_id

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        tags = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for tag in response[&#34;data&#34;]:
                    tags.append(
                        Tag(
                            tag[&#34;tag_id&#34;],
                            tag[&#34;is_auto&#34;],
                            tag[&#34;localization_names&#34;],
                            tag[&#34;localization_descriptions&#34;],
                        )
                    )

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return tags

    def get_stream_tags(self, broadcaster_id):
        &#34;&#34;&#34;
        Gets the list of current stream tags that have been set for a channel

        Args:
            broadcaster_id (str): User ID of the channel to get tags

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/streams/tags&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()
            tags = []

            for tag in response[&#34;data&#34;]:
                tags.append(
                    Tag(
                        tag[&#34;tag_id&#34;],
                        tag[&#34;is_auto&#34;],
                        tag[&#34;localization_names&#34;],
                        tag[&#34;localization_descriptions&#34;],
                    )
                )

            return tags

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_channel_teams(self, broadcaster_id):
        &#34;&#34;&#34;
        Retrieves a list of Twitch Teams of which the specified channel/broadcaster is a member

        Args:
            broadcaster_id (str): User ID for a Twitch user

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/teams/channel&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            teams = []

            for team in response.json()[&#34;data&#34;]:
                teams.append(self.get_teams(id=team[&#34;id&#34;]))

            return teams

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_teams(self, name=&#34;&#34;, id=&#34;&#34;):
        &#34;&#34;&#34;
        Gets information for a specific Twitch Team
        One of the two optional query parameters must be specified to return Team information

        Args:
            name (str, optional): Team name
            id (str, optional): Team ID

        Raises:
            twitchpy.errors.ClientError

        Returns:
            Team
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/teams&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if name != &#34;&#34;:
            params[&#34;name&#34;] = name

        if id != &#34;&#34;:
            params[&#34;id&#34;] = id

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            team = response.json()[&#34;data&#34;][0]
            users = []

            for user in team[&#34;users&#34;]:
                users.append(
                    User(user[&#34;user_id&#34;], user[&#34;user_login&#34;], user[&#34;user_name&#34;])
                )

            team = Team(
                users,
                team[&#34;background_image_url&#34;],
                team[&#34;banner&#34;],
                team[&#34;created_at&#34;],
                team[&#34;updated_at&#34;],
                team[&#34;info&#34;],
                team[&#34;thumbnail_url&#34;],
                team[&#34;team_name&#34;],
                team[&#34;team_display_name&#34;],
                team[&#34;id&#34;],
            )

            return team

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_users(self, id=[], login=[]):
        &#34;&#34;&#34;
        Gets an user
        Users are identified by optional user IDs and/or login name
        If neither a user ID nor a login name is specified, the user is looked up by Bearer token

        Args:
            id (list, optional): User ID
                                 Limit: 100
            login (list, optional): User login name
                                    Limit: 100

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/users&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if len(login) &gt; 0:
            aux = []

            for i in range(len(login)):
                aux.append(login[i].replace(&#34;@&#34;, &#34;&#34;).lower())

            params[&#34;login&#34;] = aux

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            users = []

            for user in response.json()[&#34;data&#34;]:
                users.append(
                    User(
                        user[&#34;id&#34;],
                        user[&#34;login&#34;],
                        user[&#34;display_name&#34;],
                        user[&#34;type&#34;],
                        user[&#34;broadcaster_type&#34;],
                        user[&#34;description&#34;],
                        user[&#34;profile_image_url&#34;],
                        user[&#34;offline_image_url&#34;],
                        user[&#34;view_count&#34;],
                    )
                )

            return users

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_user(self, description=&#34;&#34;):
        &#34;&#34;&#34;
        Updates the description of a user specified by the bearer token
        If the description parameter is not provided, no update will occur and the current user data is returned

        Args:
            description (str, optional): User’s account description

        Raises:
            twitchpy.errors.ClientError

        Returns:
            User
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/users&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {}

        if description != &#34;&#34;:
            data = {&#34;description&#34;: description}

        response = requests.put(url, headers=headers, data=data)

        if response.ok:
            user = response.json()[&#34;data&#34;][0]
            user = User(
                user[&#34;id&#34;],
                user[&#34;login&#34;],
                user[&#34;display_name&#34;],
                user[&#34;type&#34;],
                user[&#34;broadcaster_type&#34;],
                user[&#34;description&#34;],
                user[&#34;profile_image_url&#34;],
                user[&#34;offline_image_url&#34;],
                user[&#34;view_count&#34;],
            )

            return user

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_user_block_list(self, broadcaster_id, first=20):
        &#34;&#34;&#34;
        Gets a specified user’s block list

        Args:
            broadcaster_id (str): User ID for a Twitch user
            first (int, optional): Maximum number of objects to return
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = ENDPOINT_USER_BLOCKS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

        if first != 20:
            params[&#34;first&#34;] = first

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        ids = []

        for call in range(calls):
            if first - (100 * call) &gt; 100:
                params[&#34;first&#34;] = 100

            else:
                params[&#34;first&#34;] = first - (100 * call)

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                for user in response.json()[&#34;data&#34;]:
                    ids.append(user[&#34;user_id&#34;])

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return self.get_users(id=ids)

    def block_user(self, target_user_id, source_context=&#34;&#34;, reason=&#34;&#34;):
        &#34;&#34;&#34;
        Blocks the specified user on behalf of the authenticated user

        Args:
            target_user_id (str): User ID of the user to be blocked
            source_context (str, optional): Source context for blocking the user
                                            Valid values: &#34;chat&#34;, &#34;whisper&#34;
            reason (str, optional): Reason for blocking the user
                                    Valid values: &#34;spam&#34;, &#34;harassment&#34;, or &#34;other&#34;
        &#34;&#34;&#34;

        url = ENDPOINT_USER_BLOCKS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;target_user_id&#34;: target_user_id}

        if source_context != &#34;&#34;:
            data[&#34;source_context&#34;] = source_context

        if reason != &#34;&#34;:
            data[&#34;reason&#34;] = reason

        requests.put(url, headers=headers, data=data)

    def unblock_user(self, target_user_id):
        &#34;&#34;&#34;
        Unblocks the specified user on behalf of the authenticated user

        Args:
            target_user_id (str): User ID of the user to be unblocked
        &#34;&#34;&#34;

        url = ENDPOINT_USER_BLOCKS
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;target_user_id&#34;: target_user_id}

        requests.delete(url, headers=headers, data=data)

    def get_user_extensions(self):
        &#34;&#34;&#34;
        Gets a list of all extensions (both active and inactive) for a specified user, identified by a Bearer token

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/users/extensions/list&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }

        response = requests.get(url, headers=headers)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_user_active_extensions(self, user_id=&#34;&#34;):
        &#34;&#34;&#34;
        Gets information about active extensions installed by a specified user, identified by a user ID or Bearer token

        Args:
            user_id (str, optional): ID of the user whose installed extensions will be returned

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/users/extensions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if user_id != &#34;&#34;:
            params = {&#34;user_id&#34;: user_id}

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def update_user_extensions(self):
        &#34;&#34;&#34;
        Updates the activation state, extension ID, and/or version number of installed extensions for a specified user, identified by a Bearer token
        If you try to activate a given extension under multiple extension types, the last write wins (and there is no guarantee of write order)

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/users/extensions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }

        response = requests.put(url, headers=headers)

        if response.ok:
            return response.json()[&#34;data&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    def get_videos(
        self,
        id=[],
        user_id=&#34;&#34;,
        game_id=&#34;&#34;,
        first=20,
        language=&#34;&#34;,
        period=&#34;all&#34;,
        sort=&#34;time&#34;,
        type=&#34;all&#34;,
    ):
        &#34;&#34;&#34;
        Gets video information by video ID, user ID, or game ID
        Each request must specify one video id, one user_id, or one game_id

        Args:
            id (list): ID of the video being queried
                       Limit: 100
                       If this is specified, you cannot use first, language, period, sort and type
            user_id (str): ID of the user who owns the video
            game_id (str): ID of the game the video is of
            first (int, optional): Number of values to be returned when getting videos by user or game ID
                                   Default: 20
            language (str, optional): Language of the video being queried
                                      A language value must be either the ISO 639-1 two-letter code for a supported stream language or &#34;other&#34;
            period (str, optional): Period during which the video was created
                                    Valid values: &#34;all&#34;, &#34;day&#34;, &#34;week&#34;, &#34;month&#34;
            sort (str, optional): Sort order of the videos
                                  Valid values: &#34;time&#34;, &#34;trending&#34;, &#34;views&#34;
                                  Default: &#34;time&#34;
            type (str, optional): Type of video
                                  Valid values: &#34;all&#34;, &#34;upload&#34;, &#34;archive&#34;, &#34;highlight&#34;
                                  Default: &#34;all&#34;

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/videos&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if len(id) &gt; 0:
            params[&#34;id&#34;] = id

        if user_id != &#34;&#34;:
            params[&#34;user_id&#34;] = user_id

        if game_id != &#34;&#34;:
            params[&#34;game_id&#34;] = game_id

        if language != &#34;&#34;:
            params[&#34;language&#34;] = language

        if period != &#34;all&#34;:
            params[&#34;period&#34;] = period

        if sort != &#34;time&#34;:
            params[&#34;sort&#34;] = sort

        if type != &#34;all&#34;:
            params[&#34;type&#34;] = type

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        videos = []

        for call in range(calls):
            params[&#34;first&#34;] = min(100, first - (100 * call))

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()

                for video in response[&#34;data&#34;]:
                    videos.append(
                        Video(
                            video[&#34;id&#34;],
                            video[&#34;user_id&#34;],
                            video[&#34;user_name&#34;],
                            video[&#34;title&#34;],
                            video[&#34;description&#34;],
                            video[&#34;created_at&#34;],
                            video[&#34;published_at&#34;],
                            video[&#34;url&#34;],
                            video[&#34;thumbnail_url&#34;],
                            video[&#34;viewable&#34;],
                            video[&#34;view_count&#34;],
                            video[&#34;language&#34;],
                            video[&#34;type&#34;],
                            video[&#34;duration&#34;],
                        )
                    )

                if &#34;pagination&#34; in response:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return videos

    def delete_video(self, id):
        &#34;&#34;&#34;
        Deletes a video
        Videos are past broadcasts, Highlights, or uploads

        Args:
            id (str): ID of the video(s) to be deleted
                      Limit: 5
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/videos&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        data = {&#34;id&#34;: id}

        requests.delete(url, headers=headers, data=data)

    def send_whisper(self, from_user_id: str, to_user_id: str, message: str) -&gt; None:
        &#34;&#34;&#34;
        Sends a whisper message to the specified use

        Args:
            from_user_id (str): The ID of the user sending the whisper
                This user must have a verified phone number
                This ID must match the user ID in the user access token
            to_user_id (str): The ID of the user to receive the whisper
            message (str): The whisper message to send
                Maximum length: 500 characters if the user you&#39;re sending the message to hasn&#39;t whispered you before or 10,000 characters if the user you&#39;re sending the message to has whispered you before
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/whispers&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
            &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
        }
        payload = {
            &#34;from_user_id&#34;: from_user_id,
            &#34;to_user_id&#34;: to_user_id,
            &#34;message&#34;: message,
        }

        requests.post(url, headers=headers, json=payload)

    def get_webhook_subscriptions(self, first=20):
        &#34;&#34;&#34;
        Gets the Webhook subscriptions of an application identified by a Bearer token, in order of expiration

        Args:
            first (int, optional): Number of values to be returned
                                   Default: 20

        Raises:
            twitchpy.errors.ClientError

        Returns:
            list
        &#34;&#34;&#34;

        url = &#34;https://api.twitch.tv/helix/webhooks/subscriptions&#34;
        headers = {
            &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
            &#34;Client-Id&#34;: self.client_id,
        }
        params = {}

        if first != 20:
            params = {&#34;first&#34;: first}

        after = &#34;&#34;
        calls = math.ceil(first / 100)
        subscriptions = []

        for call in range(calls):
            if first - (100 * call) &gt; 100:
                params[&#34;first&#34;] = 100

            else:
                params[&#34;first&#34;] = first - (100 * call)

            if after != &#34;&#34;:
                params[&#34;after&#34;] = after

            response = requests.get(url, headers=headers, params=params)

            if response.ok:
                response = response.json()
                subscriptions.extend(response[&#34;data&#34;])

                if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                    after = response[&#34;pagination&#34;][&#34;cursor&#34;]

            else:
                raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

        return subscriptions</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="twitchpy.client.Client.add_blocked_term"><code class="name flex">
<span>def <span class="ident">add_blocked_term</span></span>(<span>self, broadcaster_id, moderator_id, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a word or phrase to the broadcaster’s list of blocked terms
These are the terms that broadcasters don’t want used in their chat room</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that owns the list of blocked terms</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID associated with the user OAuth token
If the broadcaster wants to add the blocked term (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The word or phrase to block from being used in the broadcaster’s chat room
The term must contain a minimum of 2 characters and may contain up to a maximum of 500 characters
Terms can use a wildcard character (*)
The wildcard character must appear at the beginning or end of a word, or set of characters</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_blocked_term(self, broadcaster_id, moderator_id, text):
    &#34;&#34;&#34;
    Adds a word or phrase to the broadcaster’s list of blocked terms
    These are the terms that broadcasters don’t want used in their chat room

    Args:
        broadcaster_id (str): The ID of the broadcaster that owns the list of blocked terms
        moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                            This ID must match the user ID associated with the user OAuth token
                            If the broadcaster wants to add the blocked term (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
        text (str): The word or phrase to block from being used in the broadcaster’s chat room
                    The term must contain a minimum of 2 characters and may contain up to a maximum of 500 characters
                    Terms can use a wildcard character (*)
                    The wildcard character must appear at the beginning or end of a word, or set of characters

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = ENDPOINT_MODERATION_BLOCKED_TERMS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
        &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
    }
    payload = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;moderator_id&#34;: moderator_id,
        &#34;text&#34;: text,
    }

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.add_channel_moderator"><code class="name flex">
<span>def <span class="ident">add_channel_moderator</span></span>(<span>self, broadcaster_id: str, user_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a moderator to the broadcaster’s chat room</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that owns the chat room
This ID must match the user ID in the access token</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user to add as a moderator in the broadcaster’s chat room</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_channel_moderator(self, broadcaster_id: str, user_id: str) -&gt; None:
    &#34;&#34;&#34;
    Adds a moderator to the broadcaster’s chat room

    Args:
        broadcaster_id (str): The ID of the broadcaster that owns the chat room
            This ID must match the user ID in the access token
        user_id (str): The ID of the user to add as a moderator in the broadcaster’s chat room
    &#34;&#34;&#34;

    url = ENDPOINT_MODERATORS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;user_id&#34;: user_id}

    requests.post(url, headers=headers, json=payload)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.add_channel_vip"><code class="name flex">
<span>def <span class="ident">add_channel_vip</span></span>(<span>self, user_id: str, broadcaster_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the specified user as a VIP in the broadcaster’s channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user to give VIP status to</dd>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that’s adding the user as a VIP
This ID must match the user ID in the access token</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_channel_vip(self, user_id: str, broadcaster_id: str) -&gt; None:
    &#34;&#34;&#34;
    Adds the specified user as a VIP in the broadcaster’s channel

    Args:
        user_id (str): The ID of the user to give VIP status to
        broadcaster_id (str): The ID of the broadcaster that’s adding the user as a VIP
            This ID must match the user ID in the access token
    &#34;&#34;&#34;

    url = ENDPOINT_VIPS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {&#34;user_id&#34;: user_id, &#34;broadcaster_id&#34;: broadcaster_id}

    requests.post(url, headers=headers, json=payload)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.assign_guest_star_slot"><code class="name flex">
<span>def <span class="ident">assign_guest_star_slot</span></span>(<span>self, broadcaster_id: str, moderator_id: str, session_id: str, guest_id: str, slot_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Allows a previously invited user to be assigned a slot within the active Guest Star session, once that guest has indicated they are ready to join</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster running the Guest Star session</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
This ID must match the user_id in the user access token</dd>
<dt><strong><code>session_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the Guest Star session in which to assign the slot</dd>
<dt><strong><code>guest_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The Twitch User ID corresponding to the guest to assign a slot in the session
This user must already have an invite to this session, and have indicated that they are ready to join</dd>
<dt><strong><code>slot_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The slot assignment to give to the user</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_guest_star_slot(
    self,
    broadcaster_id: str,
    moderator_id: str,
    session_id: str,
    guest_id: str,
    slot_id: str,
) -&gt; None:
    &#34;&#34;&#34;
    Allows a previously invited user to be assigned a slot within the active Guest Star session, once that guest has indicated they are ready to join

    Args:
        broadcaster_id (str): The ID of the broadcaster running the Guest Star session
        moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
            This ID must match the user_id in the user access token
        session_id (str): The ID of the Guest Star session in which to assign the slot
        guest_id (str): The Twitch User ID corresponding to the guest to assign a slot in the session
            This user must already have an invite to this session, and have indicated that they are ready to join
        slot_id (str): The slot assignment to give to the user
    &#34;&#34;&#34;

    url = ENDPOINT_GUEST_STAR_SLOT
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;moderator_id&#34;: moderator_id,
        &#34;session_id&#34;: session_id,
        &#34;guest_id&#34;: guest_id,
        &#34;slot_id&#34;: slot_id,
    }

    requests.post(url, headers=headers, json=payload)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.ban_user"><code class="name flex">
<span>def <span class="ident">ban_user</span></span>(<span>self, broadcaster_id, moderator_id, reason, user_id, duration=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Bans a user from participating in a broadcaster’s chat room, or puts them in a timeout
If the user is currently in a timeout, you can use this method to change the duration of the timeout or ban them altogether
If the user is currently banned, you cannot call this method to put them in a timeout instead</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster whose chat room the user is being banned from</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID associated with the user OAuth token
If the broadcaster wants to ban the user (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code>reason</code></dt>
<dd>The reason the user is being banned or put in a timeout
The text is user defined and limited to a maximum of 500 characters</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user to ban or put in a timeout</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>To ban a user indefinitely, don’t include this field
To put a user in a timeout, include this field and specify the timeout period, in seconds
The minimum timeout is 1 second and the maximum is 1,209,600 seconds (2 weeks)
To end a user’s timeout early, set this field to 1</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ban_user(self, broadcaster_id, moderator_id, reason, user_id, duration=None):
    &#34;&#34;&#34;
    Bans a user from participating in a broadcaster’s chat room, or puts them in a timeout
    If the user is currently in a timeout, you can use this method to change the duration of the timeout or ban them altogether
    If the user is currently banned, you cannot call this method to put them in a timeout instead

    Args:
        broadcaster_id (str): The ID of the broadcaster whose chat room the user is being banned from
        moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                            This ID must match the user ID associated with the user OAuth token
                            If the broadcaster wants to ban the user (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
        reason (reason): The reason the user is being banned or put in a timeout
                         The text is user defined and limited to a maximum of 500 characters
        user_id (str): The ID of the user to ban or put in a timeout
        duration (int, optional): To ban a user indefinitely, don’t include this field
                                  To put a user in a timeout, include this field and specify the timeout period, in seconds
                                  The minimum timeout is 1 second and the maximum is 1,209,600 seconds (2 weeks)
                                  To end a user’s timeout early, set this field to 1

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/moderation/bans&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

    data = {&#34;reason&#34;: reason, &#34;user_id&#34;: user_id}

    if duration is not None:
        data[&#34;duration&#34;] = duration

    payload[&#34;data&#34;] = data

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.block_user"><code class="name flex">
<span>def <span class="ident">block_user</span></span>(<span>self, target_user_id, source_context='', reason='')</span>
</code></dt>
<dd>
<div class="desc"><p>Blocks the specified user on behalf of the authenticated user</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the user to be blocked</dd>
<dt><strong><code>source_context</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Source context for blocking the user
Valid values: "chat", "whisper"</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Reason for blocking the user
Valid values: "spam", "harassment", or "other"</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_user(self, target_user_id, source_context=&#34;&#34;, reason=&#34;&#34;):
    &#34;&#34;&#34;
    Blocks the specified user on behalf of the authenticated user

    Args:
        target_user_id (str): User ID of the user to be blocked
        source_context (str, optional): Source context for blocking the user
                                        Valid values: &#34;chat&#34;, &#34;whisper&#34;
        reason (str, optional): Reason for blocking the user
                                Valid values: &#34;spam&#34;, &#34;harassment&#34;, or &#34;other&#34;
    &#34;&#34;&#34;

    url = ENDPOINT_USER_BLOCKS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;target_user_id&#34;: target_user_id}

    if source_context != &#34;&#34;:
        data[&#34;source_context&#34;] = source_context

    if reason != &#34;&#34;:
        data[&#34;reason&#34;] = reason

    requests.put(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.cancel_raid"><code class="name flex">
<span>def <span class="ident">cancel_raid</span></span>(<span>self, broadcaster_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Cancel a pending raid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that initiated the raid
This ID must match the user ID in the user access token</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_raid(self, broadcaster_id: str) -&gt; None:
    &#34;&#34;&#34;
    Cancel a pending raid

    Args:
        broadcaster_id (str): The ID of the broadcaster that initiated the raid
            This ID must match the user ID in the user access token
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/raids&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id}

    requests.delete(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.check_automod_status"><code class="name flex">
<span>def <span class="ident">check_automod_status</span></span>(<span>self, broadcaster_id: str, msg_id: str, msg_user: str) ‑> list[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether a string message meets the channel’s AutoMod requirements</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Provided broadcaster_id must match the user_id in the auth token</dd>
<dt><strong><code>msg_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Developer-generated identifier for mapping messages to results</dd>
<dt><strong><code>msg_user</code></strong> :&ensp;<code>str</code></dt>
<dd>Message text</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[dict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_automod_status(
    self, broadcaster_id: str, msg_id: str, msg_user: str
) -&gt; list[dict]:
    &#34;&#34;&#34;
    Determines whether a string message meets the channel’s AutoMod requirements

    Args:
        broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token
        msg_id (str): Developer-generated identifier for mapping messages to results
        msg_user (str): Message text

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[dict]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/moderation/enforcements/status&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;data&#34;: [{&#34;msg_id&#34;: msg_id, &#34;msg_user&#34;: msg_user}],
    }

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.check_user_subscription"><code class="name flex">
<span>def <span class="ident">check_user_subscription</span></span>(<span>self, broadcaster_id, user_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a specific user (user_id) is subscribed to a specific channel (broadcaster_id)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of an Affiliate or Partner broadcaster</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of a Twitch viewer</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_user_subscription(self, broadcaster_id, user_id):
    &#34;&#34;&#34;
    Checks if a specific user (user_id) is subscribed to a specific channel (broadcaster_id)

    Args:
        broadcaster_id (str): User ID of an Affiliate or Partner broadcaster
        user_id (str): User ID of a Twitch viewer

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/subscriptions/user&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;user_id&#34;: user_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.create_channel_stream_schedule_segment"><code class="name flex">
<span>def <span class="ident">create_channel_stream_schedule_segment</span></span>(<span>self, broadcaster_id, start_time, timezone, is_recurring, duration=240, category_id='', title='')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a single scheduled broadcast or a recurring scheduled broadcast for a channel’s stream schedule</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the broadcaster who owns the channel streaming schedule
Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>start_time</code></strong> :&ensp;<code>str</code></dt>
<dd>Start time for the scheduled broadcast specified in RFC3339 format</dd>
<dt><strong><code>timezone</code></strong> :&ensp;<code>str</code></dt>
<dd>The timezone of the application creating the scheduled broadcast using the IANA time zone database format</dd>
<dt><strong><code>is_recurring</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the scheduled broadcast is recurring weekly</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Duration of the scheduled broadcast in minutes from the start_time
Default: 240</dd>
<dt><strong><code>category_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Game/Category ID for the scheduled broadcast</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Title for the scheduled broadcast
Maximum: 140 characters</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>StreamSchedule</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_channel_stream_schedule_segment(
    self,
    broadcaster_id,
    start_time,
    timezone,
    is_recurring,
    duration=240,
    category_id=&#34;&#34;,
    title=&#34;&#34;,
):
    &#34;&#34;&#34;
    Create a single scheduled broadcast or a recurring scheduled broadcast for a channel’s stream schedule

    Args:
        broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                              Provided broadcaster_id must match the user_id in the user OAuth token
        start_time (str): Start time for the scheduled broadcast specified in RFC3339 format
        timezone (str): The timezone of the application creating the scheduled broadcast using the IANA time zone database format
        is_recurring (bool): Indicates if the scheduled broadcast is recurring weekly
        duration (int, optional): Duration of the scheduled broadcast in minutes from the start_time
                                  Default: 240
        category_id (str, optional): Game/Category ID for the scheduled broadcast
        title (str, optional): Title for the scheduled broadcast
                               Maximum: 140 characters

    Raises:
        twitchpy.errors.ClientError

    Returns:
        StreamSchedule
    &#34;&#34;&#34;

    url = ENDPOINT_SCHEDULE_SEGMENT
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;start_time&#34;: start_time,
        &#34;timezone&#34;: timezone,
        &#34;is_recurring&#34;: is_recurring,
    }

    if duration != 240:
        payload[&#34;duration&#34;] = duration

    if category_id != &#34;&#34;:
        payload[&#34;category_id&#34;] = category_id

    if title != &#34;&#34;:
        payload[&#34;title&#34;] = title

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        schedule = response.json()[&#34;data&#34;][0]
        schedule = StreamSchedule(
            schedule[&#34;segments&#34;],
            schedule[&#34;broadcaster_id&#34;],
            schedule[&#34;broadcaster_name&#34;],
            schedule[&#34;broadcaster_login&#34;],
            schedule[&#34;vacation&#34;],
        )

        return schedule

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.create_clip"><code class="name flex">
<span>def <span class="ident">create_clip</span></span>(<span>self, broadcaster_id, has_delay=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This returns both an ID and an edit URL for a new clip</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the stream from which the clip will be made</dd>
<dt><strong><code>has_delay</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If false, the clip is captured from the live stream when the API is called; otherwise, a delay is added before the clip is captured (to account for the brief delay between the broadcaster’s stream and the viewer’s experience of that stream)
Default: false</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_clip(self, broadcaster_id, has_delay=False):
    &#34;&#34;&#34;
    This returns both an ID and an edit URL for a new clip

    Args:
        broadcaster_id (str): ID of the stream from which the clip will be made
        has_delay (bool, optional): If false, the clip is captured from the live stream when the API is called; otherwise, a delay is added before the clip is captured (to account for the brief delay between the broadcaster’s stream and the viewer’s experience of that stream)
                                    Default: false

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/clips&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {&#34;broadcaster_id&#34;: broadcaster_id}

    if has_delay is not False:
        payload[&#34;has_delay&#34;] = has_delay

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.create_conduits"><code class="name flex">
<span>def <span class="ident">create_conduits</span></span>(<span>self, shard_count: int) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new conduit</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shard_count</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of shards to create for this conduit</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_conduits(self, shard_count: int) -&gt; dict:
    &#34;&#34;&#34;
    Creates a new conduit

    Args:
        shard_count (int): The number of shards to create for this conduit

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/eventsub/conduits&#34;
    headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id, &#34;Content-Type&#34;: &#34;application/json&#34;}
    payload = {&#34;shard_count&#34;, shard_count}

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.create_custom_reward"><code class="name flex">
<span>def <span class="ident">create_custom_reward</span></span>(<span>self, broadcaster_id, title, cost, prompt='', is_enabled=True, background_color='', is_user_input_required=False, is_max_per_stream_enabled=False, max_per_stream=None, is_max_per_user_per_stream_enabled=False, max_per_user_per_stream=None, is_global_cooldown_enabled=False, global_cooldown_seconds=None, should_redemptions_skip_request_queue=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Custom Reward on a channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the channel creating a reward</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title of the reward</dd>
<dt><strong><code>cost</code></strong> :&ensp;<code>int</code></dt>
<dd>The cost of the reward</dd>
<dt><strong><code>prompt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The prompt for the viewer when they are redeeming the reward</dd>
<dt><strong><code>is_enabled</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Is the reward currently enabled, if false the reward won’t show up to viewers
Default: true</dd>
<dt><strong><code>background_color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Custom background color for the reward
Format: Hex with # prefix</dd>
<dt><strong><code>is_user_input_required</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Does the user need to enter information when redeeming the reward
Default: false</dd>
<dt><strong><code>is_max_per_stream_enabled</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether a maximum per stream is enabled
Default: false</dd>
<dt><strong><code>max_per_stream</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum number per stream if enabled
Required when any value of is_max_per_stream_enabled is included</dd>
<dt><strong><code>is_max_per_user_per_stream_enabled</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether a maximum per user per stream is enabled
Default: false</dd>
<dt><strong><code>max_per_user_per_stream</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum number per user per stream if enabled
Required when any value of is_max_per_user_per_stream_enabled is included</dd>
<dt><strong><code>is_global_cooldown_enabled</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether a cooldown is enabled
Default: false</dd>
<dt><strong><code>global_cooldown_seconds</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The cooldown in seconds if enabled
Required when any value of is_global_cooldown_enabled is included</dd>
<dt><strong><code>should_redemptions_skip_request_queue</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should redemptions be set to FULFILLED status immediately when redeemed and skip the request queue instead of the normal UNFULFILLED status
Default: false</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>Reward</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_custom_reward(
    self,
    broadcaster_id,
    title,
    cost,
    prompt=&#34;&#34;,
    is_enabled=True,
    background_color=&#34;&#34;,
    is_user_input_required=False,
    is_max_per_stream_enabled=False,
    max_per_stream=None,
    is_max_per_user_per_stream_enabled=False,
    max_per_user_per_stream=None,
    is_global_cooldown_enabled=False,
    global_cooldown_seconds=None,
    should_redemptions_skip_request_queue=False,
):
    &#34;&#34;&#34;
    Creates a Custom Reward on a channel

    Args:
        broadcaster_id (str): ID of the channel creating a reward
        title (str): The title of the reward
        cost (int): The cost of the reward
        prompt (str, optional): The prompt for the viewer when they are redeeming the reward
        is_enabled (bool, optional): Is the reward currently enabled, if false the reward won’t show up to viewers
                                     Default: true
        background_color (str, optional): Custom background color for the reward
                                          Format: Hex with # prefix
        is_user_input_required (bool, optional): Does the user need to enter information when redeeming the reward
                                                 Default: false
        is_max_per_stream_enabled (bool, optional): Whether a maximum per stream is enabled
                                                    Default: false
        max_per_stream (int, optional): The maximum number per stream if enabled
                                        Required when any value of is_max_per_stream_enabled is included
        is_max_per_user_per_stream_enabled (bool, optional): Whether a maximum per user per stream is enabled
                                                             Default: false
        max_per_user_per_stream (int, optional): The maximum number per user per stream if enabled
                                                 Required when any value of is_max_per_user_per_stream_enabled is included
        is_global_cooldown_enabled (bool, optional): Whether a cooldown is enabled
                                                     Default: false
        global_cooldown_seconds (int, optional): The cooldown in seconds if enabled
                                                 Required when any value of is_global_cooldown_enabled is included
        should_redemptions_skip_request_queue (bool, optional): Should redemptions be set to FULFILLED status immediately when redeemed and skip the request queue instead of the normal UNFULFILLED status
                                                                Default: false

    Raises:
        twitchpy.errors.ClientError

    Returns:
        Reward
    &#34;&#34;&#34;

    url = ENDPOINT_CUSTOM_REWARDS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;title&#34;: title, &#34;cost&#34;: cost}

    if prompt != &#34;&#34;:
        params[&#34;prompt&#34;] = prompt

    if is_enabled is not True:
        params[&#34;is_enabled&#34;] = is_enabled

    if background_color != &#34;&#34;:
        params[&#34;background_color&#34;] = background_color

    if is_user_input_required is not False:
        params[&#34;is_user_input_required&#34;] = is_user_input_required

    if is_max_per_stream_enabled is not False:
        params[&#34;is_max_per_stream_enabled&#34;] = is_max_per_stream_enabled

    if max_per_stream is not None:
        params[&#34;max_per_stream&#34;] = max_per_stream

    if is_max_per_user_per_stream_enabled is not False:
        params[
            &#34;is_max_per_user_per_stream_enabled&#34;
        ] = is_max_per_user_per_stream_enabled

    if max_per_user_per_stream is not None:
        params[&#34;max_per_user_per_stream&#34;] = max_per_user_per_stream

    if is_global_cooldown_enabled is not False:
        params[&#34;is_global_cooldown_enabled&#34;] = is_global_cooldown_enabled

    if global_cooldown_seconds is not None:
        params[&#34;global_cooldown_seconds&#34;] = global_cooldown_seconds

    if should_redemptions_skip_request_queue is not False:
        params[
            &#34;should_redemptions_skip_request_queue&#34;
        ] = should_redemptions_skip_request_queue

    response = requests.post(url, headers=headers, params=params)

    if response.ok:
        reward = response.json()[&#34;data&#34;][0]
        reward = Reward(
            reward[&#34;broadcaster_name&#34;],
            reward[&#34;broadcaster_id&#34;],
            reward[&#34;id&#34;],
            image=reward[&#34;image&#34;],
            background_color=reward[&#34;background_color&#34;],
            is_enabled=reward[&#34;is_enabled&#34;],
            cost=reward[&#34;cost&#34;],
            title=reward[&#34;title&#34;],
            prompt=reward[&#34;prompt&#34;],
            is_user_input_required=reward[&#34;is_user_input_required&#34;],
            max_per_stream_setting=reward[&#34;max_per_stream_setting&#34;],
            max_per_user_per_stream_setting=reward[
                &#34;max_per_user_per_stream_setting&#34;
            ],
            global_cooldown_setting=reward[&#34;global_cooldown_setting&#34;],
            is_paused=reward[&#34;is_paused&#34;],
            is_in_stock=reward[&#34;is_in_stock&#34;],
            default_image=reward[&#34;default_image&#34;],
            should_redemptions_skip_request_queue=reward[
                &#34;should_redemptions_skip_request_queue&#34;
            ],
            redemptions_redeemed_current_stream=reward[
                &#34;redemptions_redeemed_current_stream&#34;
            ],
            cooldown_expires_at=reward[&#34;cooldown_expires_at&#34;],
        )

        return reward

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.create_eventsub_subscription"><code class="name flex">
<span>def <span class="ident">create_eventsub_subscription</span></span>(<span>self, type, version, condition, transport)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an EventSub subscription</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>The category of the subscription that is being created
Valid values: "channel.update", "channel.follow", "channel.subscribe", "channel.subscription.end", "channel.subscription.gift","channel.subscription.message", "channel.cheer", "channel.raid", "channel.ban", "channel.unban", "channel.moderator.add", "channel.moderator.remove", "channel.channel_points_custom_reward.add", "channel.channel_points_custom_reward.update", "channel.channel_points_custom_reward.remove", "channel.channel_points_custom_reward_redemption.add", "channel.channel_points_custom_reward_redemption.update", "channel.poll.begin", "channel.poll.progress", "channel.poll.end", "channel.prediction.begin", "channel.prediction.progress", "channel.prediction.lock", "channel.prediction.end", "drop.entitlement.grant", "extension.bits_transaction.create", "channel.hype_train.begin", "channel.hype_train.progress", "channel.hype_train.end", "stream.online", "stream.offline", "user.authorization.grant", "user.authorization.revoke", "user.update"</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code></dt>
<dd>The version of the subscription type that is being created
Each subscription type has independent versioning</dd>
<dt><strong><code>condition</code></strong> :&ensp;<code>dict</code></dt>
<dd>Custom parameters for the subscription</dd>
<dt><strong><code>transport</code></strong> :&ensp;<code>dict</code></dt>
<dd>Notification delivery specific configuration including a method string
Valid transport methods include: webhook
In addition to the method string, a webhook transport must include the callback and secret information</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>EventSubSubscription</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_eventsub_subscription(self, type, version, condition, transport):
    &#34;&#34;&#34;
    Creates an EventSub subscription

    Args:
        type (str): The category of the subscription that is being created
                    Valid values: &#34;channel.update&#34;, &#34;channel.follow&#34;, &#34;channel.subscribe&#34;, &#34;channel.subscription.end&#34;, &#34;channel.subscription.gift&#34;,&#34;channel.subscription.message&#34;, &#34;channel.cheer&#34;, &#34;channel.raid&#34;, &#34;channel.ban&#34;, &#34;channel.unban&#34;, &#34;channel.moderator.add&#34;, &#34;channel.moderator.remove&#34;, &#34;channel.channel_points_custom_reward.add&#34;, &#34;channel.channel_points_custom_reward.update&#34;, &#34;channel.channel_points_custom_reward.remove&#34;, &#34;channel.channel_points_custom_reward_redemption.add&#34;, &#34;channel.channel_points_custom_reward_redemption.update&#34;, &#34;channel.poll.begin&#34;, &#34;channel.poll.progress&#34;, &#34;channel.poll.end&#34;, &#34;channel.prediction.begin&#34;, &#34;channel.prediction.progress&#34;, &#34;channel.prediction.lock&#34;, &#34;channel.prediction.end&#34;, &#34;drop.entitlement.grant&#34;, &#34;extension.bits_transaction.create&#34;, &#34;channel.hype_train.begin&#34;, &#34;channel.hype_train.progress&#34;, &#34;channel.hype_train.end&#34;, &#34;stream.online&#34;, &#34;stream.offline&#34;, &#34;user.authorization.grant&#34;, &#34;user.authorization.revoke&#34;, &#34;user.update&#34;
        version (str): The version of the subscription type that is being created
                       Each subscription type has independent versioning
        condition (dict): Custom parameters for the subscription
        transport (dict): Notification delivery specific configuration including a method string
                          Valid transport methods include: webhook
                          In addition to the method string, a webhook transport must include the callback and secret information

    Raises:
        twitchpy.errors.ClientError

    Returns:
        EventSubSubscription
    &#34;&#34;&#34;

    url = ENDPOINT_EVENTSUB_SUBSCRIPTION
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
        &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
    }
    payload = {
        &#34;type&#34;: type,
        &#34;version&#34;: version,
        &#34;condition&#34;: condition,
        &#34;transport&#34;: transport,
    }

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        subscription = response.json()[&#34;data&#34;][0]
        subscription = EventSubSubscription(
            subscription[&#34;id&#34;],
            subscription[&#34;status&#34;],
            subscription[&#34;type&#34;],
            subscription[&#34;version&#34;],
            subscription[&#34;condition&#34;],
            subscription[&#34;created_at&#34;],
            subscription[&#34;transport&#34;],
            subscription[&#34;cost&#34;],
        )

        return subscription

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.create_extension_secret"><code class="name flex">
<span>def <span class="ident">create_extension_secret</span></span>(<span>self, delay=300)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a JWT signing secret for a specific Extension
Also rotates any current secrets out of service, with enough time for instances of the Extension to gracefully switch over to the new secret</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delay</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>JWT signing activation delay for the newly created secret in seconds
Minimum: 300
Default: 300</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_extension_secret(self, delay=300):
    &#34;&#34;&#34;
    Creates a JWT signing secret for a specific Extension
    Also rotates any current secrets out of service, with enough time for instances of the Extension to gracefully switch over to the new secret

    Args:
        delay (int, optional): JWT signing activation delay for the newly created secret in seconds
                               Minimum: 300
                               Default: 300

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/extensions/jwt/secrets&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {}

    if delay != 300:
        payload[&#34;delay&#34;] = delay

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.create_guest_star_session"><code class="name flex">
<span>def <span class="ident">create_guest_star_session</span></span>(<span>self, broadcaster_id: str) ‑> <a title="twitchpy.guest_star_session.GuestStarSession" href="guest_star_session.html#twitchpy.guest_star_session.GuestStarSession">GuestStarSession</a></span>
</code></dt>
<dd>
<div class="desc"><p>Programmatically creates a Guest Star session on behalf of the broadcaster</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster you want to create a Guest Star session for
Provided broadcaster_id must match the user_id in the auth token</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>GuestStarSession</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_guest_star_session(self, broadcaster_id: str) -&gt; GuestStarSession:
    &#34;&#34;&#34;
    Programmatically creates a Guest Star session on behalf of the broadcaster

    Args:
        broadcaster_id (str): The ID of the broadcaster you want to create a Guest Star session for
            Provided broadcaster_id must match the user_id in the auth token

    Raises:
        twitchpy.errors.ClientError

    Returns:
        GuestStarSession
    &#34;&#34;&#34;

    url = ENDPOINT_GUEST_STAR_SESSION
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        response = response.json()[&#34;data&#34;][0]

        return GuestStarSession(response[&#34;id&#34;], response[&#34;guests&#34;])

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;data&#34;][&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.create_poll"><code class="name flex">
<span>def <span class="ident">create_poll</span></span>(<span>self, broadcaster_id: str, title: str, choices: list[str], duration: int, channel_points_voting_enabled: bool = False, channel_points_per_vote: int = 0) ‑> <a title="twitchpy.poll.Poll" href="poll.html#twitchpy.poll.Poll">Poll</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a poll for a specific Twitch channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The broadcaster running polls
Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>Question displayed for the poll
Maximum: 60 characters</dd>
<dt><strong><code>choices</code></strong> :&ensp;<code>list</code></dt>
<dd>Array of the poll choices
Minimum: 2 choices
Maximum: 5 choices</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>int</code></dt>
<dd>Total duration for the poll (in seconds)
Minimum: 15
Maximum: 1800</dd>
<dt><strong><code>channel_points_voting_enabled</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates if Channel Points can be used for voting
Default: false</dd>
<dt><strong><code>channel_points_per_vote</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of Channel Points required to vote once with Channel Points
Minimum: 0
Maximum: 1000000</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>Poll</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_poll(
    self,
    broadcaster_id: str,
    title: str,
    choices: list[str],
    duration: int,
    channel_points_voting_enabled: bool = False,
    channel_points_per_vote: int = 0,
) -&gt; Poll:
    &#34;&#34;&#34;
    Create a poll for a specific Twitch channel

    Args:
        broadcaster_id (str): The broadcaster running polls
            Provided broadcaster_id must match the user_id in the user OAuth token
        title (str): Question displayed for the poll
            Maximum: 60 characters
        choices (list): Array of the poll choices
            Minimum: 2 choices
            Maximum: 5 choices
        duration (int): Total duration for the poll (in seconds)
            Minimum: 15
            Maximum: 1800
        channel_points_voting_enabled (bool, optional): Indicates if Channel Points can be used for voting
            Default: false
        channel_points_per_vote (int, optional): Number of Channel Points required to vote once with Channel Points
            Minimum: 0
            Maximum: 1000000

    Raises:
        twitchpy.errors.ClientError

    Returns:
        Poll
    &#34;&#34;&#34;

    url = ENDPOINT_POLLS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
        &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
    }

    choices_dicts = []

    for choice in choices:
        choices_dicts.append({&#34;title&#34;: choice})

    payload = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;title&#34;: title,
        &#34;choices&#34;: choices_dicts,
        &#34;duration&#34;: duration,
    }

    if channel_points_voting_enabled is not False:
        payload[&#34;channel_points_voting_enabled&#34;] = channel_points_voting_enabled

    if channel_points_per_vote != 0:
        payload[&#34;channel_points_per_vote&#34;] = channel_points_per_vote

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        poll = response.json()[&#34;data&#34;][0]
        poll = Poll(
            poll[&#34;id&#34;],
            poll[&#34;broadcaster_id&#34;],
            poll[&#34;broadcaster_name&#34;],
            poll[&#34;broadcaster_login&#34;],
            poll[&#34;title&#34;],
            poll[&#34;choices&#34;],
            poll[&#34;channel_points_voting_enabled&#34;],
            poll[&#34;channel_points_per_vote&#34;],
            poll[&#34;status&#34;],
            poll[&#34;duration&#34;],
            poll[&#34;started_at&#34;],
        )

        return poll

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.create_prediction"><code class="name flex">
<span>def <span class="ident">create_prediction</span></span>(<span>self, broadcaster_id: str, title: str, outcomes: list[str], prediction_window: int) ‑> <a title="twitchpy.prediction.Prediction" href="prediction.html#twitchpy.prediction.Prediction">Prediction</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a Channel Points Prediction for a specific Twitch channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The broadcaster running Predictions
Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>Title for the Prediction
Maximum: 45 characters</dd>
<dt><strong><code>outcomes</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The list of possible outcomes that the viewers may choose from
Minimum: 2
Maximum: 10</dd>
<dt><strong><code>prediction_window</code></strong> :&ensp;<code>int</code></dt>
<dd>Total duration for the Prediction (in seconds)
Minimum: 1
Maximum: 1800</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>Prediction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_prediction(
    self,
    broadcaster_id: str,
    title: str,
    outcomes: list[str],
    prediction_window: int,
) -&gt; Prediction:
    &#34;&#34;&#34;
    Create a Channel Points Prediction for a specific Twitch channel

    Args:
        broadcaster_id (str): The broadcaster running Predictions
            Provided broadcaster_id must match the user_id in the user OAuth token
        title (str): Title for the Prediction
            Maximum: 45 characters
        outcomes (list[str]): The list of possible outcomes that the viewers may choose from
            Minimum: 2
            Maximum: 10
        prediction_window (int): Total duration for the Prediction (in seconds)
            Minimum: 1
            Maximum: 1800

    Raises:
        twitchpy.errors.ClientError

    Returns:
        Prediction
    &#34;&#34;&#34;

    url = ENDPOINT_PREDICTIONS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
        &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
    }
    payload = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;title&#34;: title,
        &#34;prediction_window&#34;: prediction_window,
    }

    outcomes_payload = []

    for outcome in outcomes:
        outcomes_payload.append({&#34;title&#34;: outcome})

    payload[&#34;outcomes&#34;] = outcomes_payload

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        prediction = response.json()[&#34;data&#34;][0]
        prediction = Prediction(
            prediction[&#34;id&#34;],
            prediction[&#34;broadcaster_id&#34;],
            prediction[&#34;broadcaster_name&#34;],
            prediction[&#34;broadcaster_login&#34;],
            prediction[&#34;title&#34;],
            prediction[&#34;winning_outcome_id&#34;],
            prediction[&#34;outcomes&#34;],
            prediction[&#34;prediction_window&#34;],
            prediction[&#34;status&#34;],
            prediction[&#34;created_at&#34;],
            prediction[&#34;ended_at&#34;],
            prediction[&#34;locked_at&#34;],
        )

        return prediction

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.create_stream_marker"><code class="name flex">
<span>def <span class="ident">create_stream_marker</span></span>(<span>self, user_id, description='')</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a marker in the stream of a user specified by user ID
A marker is an arbitrary point in a stream that the broadcaster wants to mark; e.g., to easily return to later
The marker is created at the current timestamp in the live broadcast when the request is processed</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the broadcaster in whose live stream the marker is created</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Description of or comments on the marker
Max length is 140 characters</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_stream_marker(self, user_id, description=&#34;&#34;):
    &#34;&#34;&#34;
    Creates a marker in the stream of a user specified by user ID
    A marker is an arbitrary point in a stream that the broadcaster wants to mark; e.g., to easily return to later
    The marker is created at the current timestamp in the live broadcast when the request is processed

    Args:
        user_id (str): ID of the broadcaster in whose live stream the marker is created
        description (str, optional): Description of or comments on the marker
                                     Max length is 140 characters

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/streams/markers&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
        &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
    }
    payload = {&#34;user_id&#34;: user_id}

    if description != &#34;&#34;:
        payload[&#34;description&#34;] = description

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.delete_channel_stream_schedule_segment"><code class="name flex">
<span>def <span class="ident">delete_channel_stream_schedule_segment</span></span>(<span>self, broadcaster_id, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a single scheduled broadcast or a recurring scheduled broadcast for a channel’s stream schedule</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the broadcaster who owns the channel streaming schedule
Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the streaming segment to delete</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_channel_stream_schedule_segment(self, broadcaster_id, id):
    &#34;&#34;&#34;
    Delete a single scheduled broadcast or a recurring scheduled broadcast for a channel’s stream schedule

    Args:
        broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                              Provided broadcaster_id must match the user_id in the user OAuth token
        id (str): The ID of the streaming segment to delete
    &#34;&#34;&#34;

    url = ENDPOINT_SCHEDULE_SEGMENT
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id}

    requests.delete(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.delete_chat_messages"><code class="name flex">
<span>def <span class="ident">delete_chat_messages</span></span>(<span>self, broadcaster_id: str, moderator_id: str, message_id: str = '') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a single chat message or all chat messages from the broadcaster’s chat room</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that owns the chat room to remove messages from</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID in the user access token</dd>
<dt><strong><code>message_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The ID of the message to remove
If not specified, the request removes all messages in the broadcaster’s chat room</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_chat_messages(
    self, broadcaster_id: str, moderator_id: str, message_id: str = &#34;&#34;
) -&gt; None:
    &#34;&#34;&#34;
    Removes a single chat message or all chat messages from the broadcaster’s chat room

    Args:
        broadcaster_id (str): The ID of the broadcaster that owns the chat room to remove messages from
        moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
            This ID must match the user ID in the user access token
        message_id (str, optional): The ID of the message to remove
            If not specified, the request removes all messages in the broadcaster’s chat room
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/moderation/chat&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

    if message_id != &#34;&#34;:
        data[&#34;message_id&#34;] = message_id

    requests.delete(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.delete_conduit"><code class="name flex">
<span>def <span class="ident">delete_conduit</span></span>(<span>self, id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a specified conduit</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>Conduit ID</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_conduit(self, id: str) -&gt; None:
    &#34;&#34;&#34;
    Deletes a specified conduit

    Args:
        id (str): Conduit ID

    Raises:
        twitchpy.errors.ClientError
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/eventsub/conduits&#34;
    headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id}
    data = {&#34;id&#34;: id}

    response = requests.delete(url, headers=headers, data=data)

    if not response.ok:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.delete_custom_reward"><code class="name flex">
<span>def <span class="ident">delete_custom_reward</span></span>(<span>self, broadcaster_id, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a Custom Reward on a channel
The Custom Reward specified by id must have been created by the client_id attached to the OAuth token in order to be deleted
Any UNFULFILLED Custom Reward Redemptions of the deleted Custom Reward will be updated to the FULFILLED status</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the Custom Reward to delete
Must match a Custom Reward on broadcaster_id’s channel</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_custom_reward(self, broadcaster_id, id):
    &#34;&#34;&#34;
    Deletes a Custom Reward on a channel
    The Custom Reward specified by id must have been created by the client_id attached to the OAuth token in order to be deleted
    Any UNFULFILLED Custom Reward Redemptions of the deleted Custom Reward will be updated to the FULFILLED status

    Args:
        broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
        id (str): ID of the Custom Reward to delete
                  Must match a Custom Reward on broadcaster_id’s channel
    &#34;&#34;&#34;

    url = ENDPOINT_CUSTOM_REWARDS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id}

    requests.delete(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.delete_eventsub_subscription"><code class="name flex">
<span>def <span class="ident">delete_eventsub_subscription</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete an EventSub subscription</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>The subscription ID for the subscription to delete</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_eventsub_subscription(self, id):
    &#34;&#34;&#34;
    Delete an EventSub subscription

    Args:
        id (str): The subscription ID for the subscription to delete
    &#34;&#34;&#34;

    url = ENDPOINT_EVENTSUB_SUBSCRIPTION
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;id&#34;: id}

    requests.delete(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.delete_guest_star_invite"><code class="name flex">
<span>def <span class="ident">delete_guest_star_invite</span></span>(<span>self, broadcaster_id: str, moderator_id: str, session_id: str, guest_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Revokes a previously sent invite for a Guest Star session</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster running the Guest Star session</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
This ID must match the user_id in the user access token</dd>
<dt><strong><code>session_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the session for the invite to be revoked on behalf of the broadcaster</dd>
<dt><strong><code>guest_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Twitch User ID for the guest to revoke the Guest Star session invite from</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_guest_star_invite(
    self, broadcaster_id: str, moderator_id: str, session_id: str, guest_id: str
) -&gt; None:
    &#34;&#34;&#34;
    Revokes a previously sent invite for a Guest Star session

    Args:
        broadcaster_id (str): The ID of the broadcaster running the Guest Star session
        moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
            This ID must match the user_id in the user access token
        session_id (str): The ID of the session for the invite to be revoked on behalf of the broadcaster
        guest_id (str): Twitch User ID for the guest to revoke the Guest Star session invite from
    &#34;&#34;&#34;

    url = ENDPOINT_GUEST_STAR_INVITES
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;moderator_id&#34;: moderator_id,
        &#34;session_id&#34;: session_id,
        &#34;guest_id&#34;: guest_id,
    }

    requests.delete(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.delete_guest_star_slot"><code class="name flex">
<span>def <span class="ident">delete_guest_star_slot</span></span>(<span>self, broadcaster_id: str, moderator_id: str, session_id: str, guest_id: str, slot_id: str, should_reinvite_guest: str = '') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Allows a caller to remove a slot assignment from a user participating in an active Guest Star session</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster running the Guest Star session</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID in the user access token</dd>
<dt><strong><code>session_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the Guest Star session in which to remove the slot assignment</dd>
<dt><strong><code>guest_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The Twitch User ID corresponding to the guest to remove from the session</dd>
<dt><strong><code>slot_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The slot ID representing the slot assignment to remove from the session</dd>
<dt><strong><code>should_reinvite_guest</code></strong> :&ensp;<code>str</code></dt>
<dd>Flag signaling that the guest should be reinvited to the session, sending them back to the invite queue</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_guest_star_slot(
    self,
    broadcaster_id: str,
    moderator_id: str,
    session_id: str,
    guest_id: str,
    slot_id: str,
    should_reinvite_guest: str = &#34;&#34;,
) -&gt; None:
    &#34;&#34;&#34;
    Allows a caller to remove a slot assignment from a user participating in an active Guest Star session

    Args:
        broadcaster_id (str): The ID of the broadcaster running the Guest Star session
        moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
            This ID must match the user ID in the user access token
        session_id (str): The ID of the Guest Star session in which to remove the slot assignment
        guest_id (str): The Twitch User ID corresponding to the guest to remove from the session
        slot_id (str): The slot ID representing the slot assignment to remove from the session
        should_reinvite_guest (str): Flag signaling that the guest should be reinvited to the session, sending them back to the invite queue
    &#34;&#34;&#34;

    url = ENDPOINT_GUEST_STAR_SLOT
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;moderator_id&#34;: moderator_id,
        &#34;session_id&#34;: session_id,
        &#34;guest_id&#34;: guest_id,
        &#34;slot_id&#34;: slot_id,
    }

    if should_reinvite_guest != &#34;&#34;:
        data[&#34;should_reinvite_guest&#34;] = should_reinvite_guest

    requests.delete(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.delete_video"><code class="name flex">
<span>def <span class="ident">delete_video</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a video
Videos are past broadcasts, Highlights, or uploads</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the video(s) to be deleted
Limit: 5</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_video(self, id):
    &#34;&#34;&#34;
    Deletes a video
    Videos are past broadcasts, Highlights, or uploads

    Args:
        id (str): ID of the video(s) to be deleted
                  Limit: 5
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/videos&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;id&#34;: id}

    requests.delete(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.end_guest_star_session"><code class="name flex">
<span>def <span class="ident">end_guest_star_session</span></span>(<span>self, broadcaster_id: str, session_id: str) ‑> <a title="twitchpy.guest_star_session.GuestStarSession" href="guest_star_session.html#twitchpy.guest_star_session.GuestStarSession">GuestStarSession</a></span>
</code></dt>
<dd>
<div class="desc"><p>Programmatically ends a Guest Star session on behalf of the broadcaster</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster you want to end a Guest Star session for
Provided broadcaster_id must match the user_id in the auth token</dd>
<dt><strong><code>session_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID for the session to end on behalf of the broadcaster</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>GuestStarSession</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_guest_star_session(
    self, broadcaster_id: str, session_id: str
) -&gt; GuestStarSession:
    &#34;&#34;&#34;
    Programmatically ends a Guest Star session on behalf of the broadcaster

    Args:
        broadcaster_id (str): The ID of the broadcaster you want to end a Guest Star session for
            Provided broadcaster_id must match the user_id in the auth token
        session_id (str): ID for the session to end on behalf of the broadcaster

    Raises:
        twitchpy.errors.ClientError

    Returns:
        GuestStarSession
    &#34;&#34;&#34;

    url = ENDPOINT_GUEST_STAR_SESSION
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;session_id&#34;: session_id}

    response = requests.delete(url, headers=headers, data=data)

    if response.ok:
        response = response.json()[&#34;data&#34;][0]

        return GuestStarSession(response[&#34;id&#34;], response[&#34;guests&#34;])

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;data&#34;][&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.end_poll"><code class="name flex">
<span>def <span class="ident">end_poll</span></span>(<span>self, broadcaster_id, id, status)</span>
</code></dt>
<dd>
<div class="desc"><p>End a poll that is currently active</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The broadcaster running polls
Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the poll</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>str</code></dt>
<dd>The poll status to be set
Valid values: "TERMINATED", "ARCHIVED"</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>Poll</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_poll(self, broadcaster_id, id, status):
    &#34;&#34;&#34;
    End a poll that is currently active

    Args:
        broadcaster_id (str): The broadcaster running polls
                              Provided broadcaster_id must match the user_id in the user OAuth token
        id (str): ID of the poll
        status (str): The poll status to be set
                      Valid values: &#34;TERMINATED&#34;, &#34;ARCHIVED&#34;

    Raises:
        twitchpy.errors.ClientError

    Returns:
        Poll
    &#34;&#34;&#34;

    url = ENDPOINT_POLLS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id, &#34;status&#34;: status}

    response = requests.patch(url, headers=headers, data=data)

    if response.ok:
        poll = response.json()[&#34;data&#34;][0]
        poll = Poll(
            poll[&#34;id&#34;],
            poll[&#34;broadcaster_id&#34;],
            poll[&#34;broadcaster_name&#34;],
            poll[&#34;broadcaster_login&#34;],
            poll[&#34;title&#34;],
            poll[&#34;choices&#34;],
            poll[&#34;bits_voting_enabled&#34;],
            poll[&#34;bits_per_vote&#34;],
            poll[&#34;channel_points_voting_enabled&#34;],
            poll[&#34;channel_points_per_vote&#34;],
            poll[&#34;status&#34;],
            poll[&#34;duration&#34;],
            poll[&#34;started_at&#34;],
        )

        return poll

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.end_prediction"><code class="name flex">
<span>def <span class="ident">end_prediction</span></span>(<span>self, broadcaster_id, id, status, winning_outcome_id='')</span>
</code></dt>
<dd>
<div class="desc"><p>Lock, resolve, or cancel a Channel Points Prediction
Active Predictions can be updated to be "locked", "resolved", or "canceled"
Locked Predictions can be updated to be "resolved" or "canceled"</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The broadcaster running prediction events
Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the Prediction</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>str</code></dt>
<dd>The Prediction status to be set
Valid values: "RESOLVED", "CANCELED", "LOCKED"</dd>
<dt><strong><code>winning_outcome_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the winning outcome for the Prediction
This parameter is required if status is being set to RESOLVED</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>Prediction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_prediction(self, broadcaster_id, id, status, winning_outcome_id=&#34;&#34;):
    &#34;&#34;&#34;
    Lock, resolve, or cancel a Channel Points Prediction
    Active Predictions can be updated to be &#34;locked&#34;, &#34;resolved&#34;, or &#34;canceled&#34;
    Locked Predictions can be updated to be &#34;resolved&#34; or &#34;canceled&#34;

    Args:
        broadcaster_id (str): The broadcaster running prediction events
                              Provided broadcaster_id must match the user_id in the user OAuth token
        id (str): ID of the Prediction
        status (str): The Prediction status to be set
                      Valid values: &#34;RESOLVED&#34;, &#34;CANCELED&#34;, &#34;LOCKED&#34;
        winning_outcome_id (str, optional): ID of the winning outcome for the Prediction
                                            This parameter is required if status is being set to RESOLVED

    Raises:
        twitchpy.errors.ClientError

    Returns:
        Prediction
    &#34;&#34;&#34;

    url = ENDPOINT_PREDICTIONS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id, &#34;status&#34;: status}

    if winning_outcome_id != &#34;&#34;:
        data[&#34;winning_outcome_id&#34;] = winning_outcome_id

    response = requests.patch(url, headers=headers, data=data)

    if response.ok:
        prediction = response.json()[&#34;data&#34;][0]
        prediction = Prediction(
            prediction[&#34;id&#34;],
            prediction[&#34;broadcaster_id&#34;],
            prediction[&#34;broadcaster_name&#34;],
            prediction[&#34;broadcaster_login&#34;],
            prediction[&#34;title&#34;],
            prediction[&#34;winning_outcome_id&#34;],
            prediction[&#34;outcomes&#34;],
            prediction[&#34;prediction_window&#34;],
            prediction[&#34;status&#34;],
            prediction[&#34;created_at&#34;],
            prediction[&#34;ended_at&#34;],
            prediction[&#34;locked_at&#34;],
        )

        return prediction

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_ad_schedule"><code class="name flex">
<span>def <span class="ident">get_ad_schedule</span></span>(<span>self, broadcaster_id: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns ad schedule related information, including snooze, when the last ad was run, when the next ad is scheduled, and if the channel is currently in pre-roll free time</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Provided broadcaster_id must match the user_id in the auth token</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ad_schedule(self, broadcaster_id: str) -&gt; dict:
    &#34;&#34;&#34;
    Returns ad schedule related information, including snooze, when the last ad was run, when the next ad is scheduled, and if the channel is currently in pre-roll free time

    Args:
        broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/channels/ads&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_all_stream_tags"><code class="name flex">
<span>def <span class="ident">get_all_stream_tags</span></span>(<span>self, first=20, tag_id=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the list of all stream tags defined by Twitch</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 20</dd>
<dt><strong><code>tag_id</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>ID of a tag</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_stream_tags(self, first=20, tag_id=[]):
    &#34;&#34;&#34;
    Gets the list of all stream tags defined by Twitch

    Args:
        first (int, optional): Maximum number of objects to return
                               Default: 20
        tag_id (list, optional): ID of a tag

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/tags/streams&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if len(tag_id) &gt; 0:
        params[&#34;tag_id&#34;] = tag_id

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    tags = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for tag in response[&#34;data&#34;]:
                tags.append(
                    Tag(
                        tag[&#34;tag_id&#34;],
                        tag[&#34;is_auto&#34;],
                        tag[&#34;localization_names&#34;],
                        tag[&#34;localization_descriptions&#34;],
                    )
                )

            if &#34;pagination&#34; in response:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return tags</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_automod_settings"><code class="name flex">
<span>def <span class="ident">get_automod_settings</span></span>(<span>self, broadcaster_id, moderator_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the broadcaster’s AutoMod settings, which are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster whose AutoMod settings you want to get</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID associated with the user OAuth token
If the broadcaster wants to get their own AutoMod settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_automod_settings(self, broadcaster_id, moderator_id):
    &#34;&#34;&#34;
    Gets the broadcaster’s AutoMod settings, which are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room

    Args:
        broadcaster_id (str): The ID of the broadcaster whose AutoMod settings you want to get
        moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                            This ID must match the user ID associated with the user OAuth token
                            If the broadcaster wants to get their own AutoMod settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/moderation/automod/settings&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_banned_users"><code class="name flex">
<span>def <span class="ident">get_banned_users</span></span>(<span>self, broadcaster_id, user_id=[], first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all banned and timed-out users in a channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Provided broadcaster_id must match the user_id in the auth token</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Filters the results and only returns a status object for users who are banned in this channel and have a matching user_id
Maximum: 100</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_banned_users(self, broadcaster_id, user_id=[], first=20):
    &#34;&#34;&#34;
    Returns all banned and timed-out users in a channel

    Args:
        broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token
        user_id (list, optional): Filters the results and only returns a status object for users who are banned in this channel and have a matching user_id
                                 Maximum: 100
        first (int, optional): Maximum number of objects to return
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/moderation/banned&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    if len(user_id) &gt; 0:
        params[&#34;user_id&#34;] = user_id

    if first != 20:
        params[&#34;first&#34;] = first

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    users = []

    for call in range(calls):
        if first - (100 * call) &gt; 100:
            params[&#34;first&#34;] = 100

        else:
            params[&#34;first&#34;] = first - (100 * call)

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()
            users.extend(response[&#34;data&#34;])

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return users</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_bits_leaderboard"><code class="name flex">
<span>def <span class="ident">get_bits_leaderboard</span></span>(<span>self, count=10, period='all', started_at='', user_id='')</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a ranked list of Bits leaderboard information for a broadcaster</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of results to be returned
Maximum: 100
Default: 10</dd>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Time period over which data is aggregated (PST time zone)
This parameter interacts with started_at
Default: "all"
Valid values: "day", "week", "month", "year", "all"</dd>
<dt><strong><code>started_at</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Timestamp for the period over which the returned data is aggregated
Must be in RFC 3339 format
This value is ignored if period is "all"</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the user whose results are returned
As long as count is greater than 1, the returned data includes additional users, with Bits amounts above and below the user specified</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bits_leaderboard(self, count=10, period=&#34;all&#34;, started_at=&#34;&#34;, user_id=&#34;&#34;):
    &#34;&#34;&#34;
    Gets a ranked list of Bits leaderboard information for a broadcaster

    Args:
        count (int, optional): Number of results to be returned
                               Maximum: 100
                               Default: 10
        period (str, optional): Time period over which data is aggregated (PST time zone)
                                This parameter interacts with started_at
                                Default: &#34;all&#34;
                                Valid values: &#34;day&#34;, &#34;week&#34;, &#34;month&#34;, &#34;year&#34;, &#34;all&#34;
        started_at (str, optional): Timestamp for the period over which the returned data is aggregated
                                    Must be in RFC 3339 format
                                    This value is ignored if period is &#34;all&#34;
        user_id (str, optional): ID of the user whose results are returned
                                 As long as count is greater than 1, the returned data includes additional users, with Bits amounts above and below the user specified

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/bits/leaderboard&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if count != 10:
        params[&#34;count&#34;] = count

    if period != &#34;all&#34;:
        params[&#34;period&#34;] = period

    if started_at != &#34;&#34;:
        params[&#34;started_at&#34;] = started_at

    if user_id != &#34;&#34;:
        params[&#34;user_id&#34;] = user_id

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_blocked_terms"><code class="name flex">
<span>def <span class="ident">get_blocked_terms</span></span>(<span>self, broadcaster_id, moderator_id, first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the broadcaster’s list of non-private, blocked words or phrases
These are the terms that the broadcaster or moderator added manually, or that were denied by AutoMod</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster whose blocked terms you’re getting</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID associated with the user OAuth token
If the broadcaster wants to get their own block terms (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum number of blocked terms to return per page in the response
The minimum page size is 1 blocked term per page and the maximum is 100
The default is 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_blocked_terms(self, broadcaster_id, moderator_id, first=20):
    &#34;&#34;&#34;
    Gets the broadcaster’s list of non-private, blocked words or phrases
    These are the terms that the broadcaster or moderator added manually, or that were denied by AutoMod

    Args:
        broadcaster_id (str): The ID of the broadcaster whose blocked terms you’re getting
        moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                            This ID must match the user ID associated with the user OAuth token
                            If the broadcaster wants to get their own block terms (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
        first (int, optional): The maximum number of blocked terms to return per page in the response
                               The minimum page size is 1 blocked term per page and the maximum is 100
                               The default is 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = ENDPOINT_MODERATION_BLOCKED_TERMS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

    if first != 20:
        params[&#34;first&#34;] = first

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    blocked_terms = []

    for call in range(calls):
        if first - (100 * call) &gt; 100:
            params[&#34;first&#34;] = 100

        else:
            params[&#34;first&#34;] = first - (100 * call)

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()
            blocked_terms.extend(response[&#34;data&#34;])

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return blocked_terms</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_broadcaster_subscriptions"><code class="name flex">
<span>def <span class="ident">get_broadcaster_subscriptions</span></span>(<span>self, broadcaster_id, user_id=[], first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all of a broadcaster’s subscriptions</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the broadcaster
Must match the User ID in the Bearer token</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Filters results to only include potential subscriptions made by the provided user ID
Accepts up to 100 values</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_broadcaster_subscriptions(self, broadcaster_id, user_id=[], first=20):
    &#34;&#34;&#34;
    Get all of a broadcaster’s subscriptions

    Args:
        broadcaster_id (str): User ID of the broadcaster
                              Must match the User ID in the Bearer token
        user_id (list, optional): Filters results to only include potential subscriptions made by the provided user ID
                                  Accepts up to 100 values
        first (int, optional): Maximum number of objects to return
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/subscriptions&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    if len(user_id) &gt; 0:
        params[&#34;user_id&#34;] = user_id

    if first != 20:
        params[&#34;first&#34;] = first

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    subscriptions = []

    for call in range(calls):
        if first - (100 * call) &gt; 100:
            params[&#34;first&#34;] = 100

        else:
            params[&#34;first&#34;] = first - (100 * call)

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()
            subscriptions.extend(response[&#34;data&#34;])

            if &#34;pagination&#34; in response:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return subscriptions</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_channel"><code class="name flex">
<span>def <span class="ident">get_channel</span></span>(<span>self, broadcaster_id: str | list[str]) ‑> <a title="twitchpy.channel.Channel" href="channel.html#twitchpy.channel.Channel">Channel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets one or more channels</p>
<h2 id="args">Args</h2>
<p>broadcaster_id (str | list[str]): The ID of the broadcaster whose channel you want to get
Maximum: 100</p>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>Channel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel(self, broadcaster_id: str | list[str]) -&gt; Channel:
    &#34;&#34;&#34;
    Gets one or more channels

    Args:
        broadcaster_id (str | list[str]): The ID of the broadcaster whose channel you want to get
            Maximum: 100

    Raises:
        twitchpy.errors.ClientError

    Returns:
        Channel
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/channels&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token if self.__user_token != &#39;&#39; else self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        channel = response.json()[&#34;data&#34;][0]
        channel = Channel(
            channel[&#34;broadcaster_id&#34;],
            channel[&#34;broadcaster_login&#34;],
            channel[&#34;broadcaster_name&#34;],
            channel[&#34;broadcaster_language&#34;],
            channel[&#34;game_name&#34;],
            channel[&#34;game_id&#34;],
            channel[&#34;title&#34;],
            channel[&#34;delay&#34;],
            channel[&#34;tags&#34;],
            channel[&#34;content_classification_labels&#34;],
            channel[&#34;is_branded_content&#34;],
        )

        return channel

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_channel_chat_badges"><code class="name flex">
<span>def <span class="ident">get_channel_chat_badges</span></span>(<span>self, broadcaster_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of custom chat badges that can be used in chat for the specified channel
This includes subscriber badges and Bit badges</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The broadcaster whose chat badges are being requested
Provided broadcaster_id must match the user_id in the user OAuth token</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel_chat_badges(self, broadcaster_id):
    &#34;&#34;&#34;
    Gets a list of custom chat badges that can be used in chat for the specified channel
    This includes subscriber badges and Bit badges

    Args:
        broadcaster_id (str): The broadcaster whose chat badges are being requested
                              Provided broadcaster_id must match the user_id in the user OAuth token

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/chat/badges&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        badges = []

        for badge in response.json()[&#34;data&#34;]:
            badges.append(Badge(badge[&#34;set_id&#34;], badge[&#34;versions&#34;]))

        return badges

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_channel_editors"><code class="name flex">
<span>def <span class="ident">get_channel_editors</span></span>(<span>self, broadcaster_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of users who have editor permissions for a specific channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Broadcaster’s user ID associated with the channel</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel_editors(self, broadcaster_id):
    &#34;&#34;&#34;
    Gets a list of users who have editor permissions for a specific channel

    Args:
        broadcaster_id (str): Broadcaster’s user ID associated with the channel

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/channels/editors&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        ids = []

        for user in response.json()[&#34;data&#34;]:
            ids.append(user[&#34;user_id&#34;])

        users = self.get_users(id=ids)

        return users

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_channel_emotes"><code class="name flex">
<span>def <span class="ident">get_channel_emotes</span></span>(<span>self, broadcaster_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all custom emotes for a specific Twitch channel including subscriber emotes, Bits tier emotes, and follower emotes
Custom channel emotes are custom emoticons that viewers may use in Twitch chat once they are subscribed to, cheered in, or followed the channel that owns the emotes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The broadcaster whose emotes are being requested</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel_emotes(self, broadcaster_id):
    &#34;&#34;&#34;
    Gets all custom emotes for a specific Twitch channel including subscriber emotes, Bits tier emotes, and follower emotes
    Custom channel emotes are custom emoticons that viewers may use in Twitch chat once they are subscribed to, cheered in, or followed the channel that owns the emotes

    Args:
        broadcaster_id (str): The broadcaster whose emotes are being requested

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/chat/emotes&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        emotes = []

        for emote in response.json()[&#34;data&#34;]:
            emotes.append(
                Emote(
                    emote[&#34;id&#34;],
                    emote[&#34;name&#34;],
                    emote[&#34;images&#34;],
                    emote[&#34;format&#34;],
                    emote[&#34;scale&#34;],
                    emote[&#34;theme_mode&#34;],
                    emote[&#34;tier&#34;],
                    emote[&#34;emote_type&#34;],
                    emote[&#34;emote_set_id&#34;],
                )
            )

        return emotes

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_channel_followers"><code class="name flex">
<span>def <span class="ident">get_channel_followers</span></span>(<span>self, broadcaster_id: str, user_id: str = '', first: int = 20) ‑> list[<a title="twitchpy.channel.Channel" href="channel.html#twitchpy.channel.Channel">Channel</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code>get_channel_followers</code> retrieves a list of channels that are following a specific
broadcaster on Twitch.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The broadcaster’s ID
Returns the list of users that follow this broadcaster</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>A user’s ID
Use this parameter to see whether the user follows this broadcaster</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of items to return
Default: 20
Minimum: 1</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[Channel]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel_followers(
    self, broadcaster_id: str, user_id: str = &#34;&#34;, first: int = 20
) -&gt; list[Channel]:
    &#34;&#34;&#34;
    The function `get_channel_followers` retrieves a list of channels that are following a specific
    broadcaster on Twitch.

    Args:
        broadcaster_id (str): The broadcaster’s ID
            Returns the list of users that follow this broadcaster
        user_id (str): A user’s ID
            Use this parameter to see whether the user follows this broadcaster
        first (int): The maximum number of items to return
            Default: 20
            Minimum: 1

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[Channel]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/channels/followers&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    if user_id != &#34;&#34;:
        params[&#34;user_id&#34;] = user_id

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    channels = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            channels.append(
                self.get_channel(
                    [channel[&#34;user_id&#34;] for channel in response[&#34;data&#34;]]
                )
            )

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return channels</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_channel_guest_star_settings"><code class="name flex">
<span>def <span class="ident">get_channel_guest_star_settings</span></span>(<span>self, broadcaster_id: str, moderator_id: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the channel settings for configuration of the Guest Star feature for a particular host</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster you want to get guest star settings for</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID in the user access token</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel_guest_star_settings(
    self, broadcaster_id: str, moderator_id: str
) -&gt; dict:
    &#34;&#34;&#34;
    Gets the channel settings for configuration of the Guest Star feature for a particular host

    Args:
        broadcaster_id (str): The ID of the broadcaster you want to get guest star settings for
        moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
            This ID must match the user ID in the user access token

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/guest_star/channel_settings&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_channel_icalendar"><code class="name flex">
<span>def <span class="ident">get_channel_icalendar</span></span>(<span>self, broadcaster_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all scheduled broadcasts from a channel’s stream schedule as an iCalendar</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the broadcaster who owns the channel streaming schedule</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel_icalendar(self, broadcaster_id):
    &#34;&#34;&#34;
    Gets all scheduled broadcasts from a channel’s stream schedule as an iCalendar

    Args:
        broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule

    Returns:
        str
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/schedule/icalendar&#34;
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.get(url, params=params)

    if response.ok:
        return response.text

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_channel_stream_schedule"><code class="name flex">
<span>def <span class="ident">get_channel_stream_schedule</span></span>(<span>self, broadcaster_id, id=[], start_time='', utc_offset='0', first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all scheduled broadcasts or specific scheduled broadcasts from a channel’s stream schedule
Scheduled broadcasts are defined as "stream segments"</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the broadcaster who owns the channel streaming schedule
Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The ID of the stream segment to return
Maximum: 100</dd>
<dt><strong><code>start_time</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A timestamp in RFC3339 format to start returning stream segments from
If not specified, the current date and time is used</dd>
<dt><strong><code>utc_offset</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A timezone offset for the requester specified in minutes
If not specified, "0" is used for GMT</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of stream segments to return
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel_stream_schedule(
    self, broadcaster_id, id=[], start_time=&#34;&#34;, utc_offset=&#34;0&#34;, first=20
):
    &#34;&#34;&#34;
    Gets all scheduled broadcasts or specific scheduled broadcasts from a channel’s stream schedule
    Scheduled broadcasts are defined as &#34;stream segments&#34;

    Args:
        broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                              Provided broadcaster_id must match the user_id in the user OAuth token
        id (str, optional): The ID of the stream segment to return
                            Maximum: 100
        start_time (str, optional): A timestamp in RFC3339 format to start returning stream segments from
                                    If not specified, the current date and time is used
        utc_offset (str, optional): A timezone offset for the requester specified in minutes
                                    If not specified, &#34;0&#34; is used for GMT
        first (int, optional): Maximum number of stream segments to return
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/schedule&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    if len(id) &gt; 0:
        params[&#34;id&#34;] = id

    if start_time != &#34;&#34;:
        params[&#34;start_time&#34;] = start_time

    if utc_offset != &#34;0&#34;:
        params[&#34;utc_offset&#34;] = utc_offset

    after = &#34;&#34;
    calls = math.ceil(first / 25)
    schedules = []

    for call in range(calls):
        params[&#34;first&#34;] = min(25, first - (25 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for schedule in response[&#34;data&#34;]:
                schedules.append(
                    StreamSchedule(
                        schedule[&#34;segments&#34;],
                        schedule[&#34;broadcaster_id&#34;],
                        schedule[&#34;broadcaster_name&#34;],
                        schedule[&#34;broadcaster_login&#34;],
                        schedule[&#34;vacation&#34;],
                    )
                )

            if &#34;pagination&#34; in response:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return schedules</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_channel_teams"><code class="name flex">
<span>def <span class="ident">get_channel_teams</span></span>(<span>self, broadcaster_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a list of Twitch Teams of which the specified channel/broadcaster is a member</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID for a Twitch user</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel_teams(self, broadcaster_id):
    &#34;&#34;&#34;
    Retrieves a list of Twitch Teams of which the specified channel/broadcaster is a member

    Args:
        broadcaster_id (str): User ID for a Twitch user

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/teams/channel&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        teams = []

        for team in response.json()[&#34;data&#34;]:
            teams.append(self.get_teams(id=team[&#34;id&#34;]))

        return teams

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_charity_campaign"><code class="name flex">
<span>def <span class="ident">get_charity_campaign</span></span>(<span>self, broadcaster_id: str) ‑> <a title="twitchpy.charity_campaign.CharityCampaign" href="charity_campaign.html#twitchpy.charity_campaign.CharityCampaign">CharityCampaign</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about the charity campaign that a broadcaster is running</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that’s currently running a charity campaign
This ID must match the user ID in the access token</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>CharityCampaign</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_charity_campaign(self, broadcaster_id: str) -&gt; CharityCampaign:
    &#34;&#34;&#34;
    Gets information about the charity campaign that a broadcaster is running

    Args:
        broadcaster_id (str): The ID of the broadcaster that’s currently running a charity campaign
            This ID must match the user ID in the access token

    Raises:
        twitchpy.errors.ClientError

    Returns:
        CharityCampaign
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/charity/campaigns&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return CharityCampaign(
            response.json()[&#34;data&#34;][0][&#34;id&#34;],
            response.json()[&#34;data&#34;][0][&#34;broadcaster_id&#34;],
            response.json()[&#34;data&#34;][0][&#34;broadcaster_name&#34;],
            response.json()[&#34;data&#34;][0][&#34;broadcaster_login&#34;],
            response.json()[&#34;data&#34;][0][&#34;charity_name&#34;],
            response.json()[&#34;data&#34;][0][&#34;charity_description&#34;],
            response.json()[&#34;data&#34;][0][&#34;charity_logo&#34;],
            response.json()[&#34;data&#34;][0][&#34;charity_website&#34;],
            response.json()[&#34;data&#34;][0][&#34;current_amount&#34;],
            response.json()[&#34;data&#34;][0][&#34;target_amount&#34;],
        )

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_charity_campaign_donations"><code class="name flex">
<span>def <span class="ident">get_charity_campaign_donations</span></span>(<span>self, broadcaster_id: str, first: int = 20) ‑> list[<a title="twitchpy.charity_campaign_donation.CharityCampaignDonation" href="charity_campaign_donation.html#twitchpy.charity_campaign_donation.CharityCampaignDonation">CharityCampaignDonation</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the list of donations that users have made to the broadcaster’s active charity campaign</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that’s currently running a charity campaign
This ID must match the user ID in the access token</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of items to return
Default: 20
Minimum: 1</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[CharityCampaignDonation]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_charity_campaign_donations(
    self, broadcaster_id: str, first: int = 20
) -&gt; list[CharityCampaignDonation]:
    &#34;&#34;&#34;
    Gets the list of donations that users have made to the broadcaster’s active charity campaign

    Args:
        broadcaster_id (str): The ID of the broadcaster that’s currently running a charity campaign
            This ID must match the user ID in the access token
        first (int): The maximum number of items to return
            Default: 20
            Minimum: 1

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[CharityCampaignDonation]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/charity/donations&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    after = &#34;&#34;
    calls = math.ceil(first / 20)
    donations = []

    for call in range(calls):
        params[&#34;first&#34;] = min(20, first - (20 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for donation in response[&#34;data&#34;]:
                donations.append(
                    CharityCampaignDonation(
                        donation[&#34;id&#34;],
                        donation[&#34;campaign_id&#34;],
                        donation[&#34;user_id&#34;],
                        donation[&#34;user_login&#34;],
                        donation[&#34;user_name&#34;],
                        donation[&#34;amount&#34;],
                    )
                )

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return donations</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_chat_settings"><code class="name flex">
<span>def <span class="ident">get_chat_settings</span></span>(<span>self, broadcaster_id, moderator_id='')</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the broadcaster’s chat settings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster whose chat settings you want to get</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Required only to access the non_moderator_chat_delay or non_moderator_chat_delay_duration settings
The ID of a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID associated with the user OAuth token
If the broadcaster wants to get their own settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chat_settings(self, broadcaster_id, moderator_id=&#34;&#34;):
    &#34;&#34;&#34;
    Gets the broadcaster’s chat settings

    Args:
        broadcaster_id (str): The ID of the broadcaster whose chat settings you want to get
        moderator_id (str, optional): Required only to access the non_moderator_chat_delay or non_moderator_chat_delay_duration settings
                                      The ID of a user that has permission to moderate the broadcaster’s chat room
                                      This ID must match the user ID associated with the user OAuth token
                                      If the broadcaster wants to get their own settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/chat/settings&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_chatters"><code class="name flex">
<span>def <span class="ident">get_chatters</span></span>(<span>self, broadcaster_id: str, moderator_id: str, first: int = 100) ‑> list[<a title="twitchpy.user.User" href="user.html#twitchpy.user.User">User</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the list of users that are connected to the broadcaster’s chat session</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster whose list of chatters you want to get</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or one of the broadcaster’s moderators
This ID must match the user ID in the user access token</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of items to return
Default: 100
Minimum: 1
Maximum: 1000</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[User]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chatters(
    self, broadcaster_id: str, moderator_id: str, first: int = 100
) -&gt; list[User]:
    &#34;&#34;&#34;
    Gets the list of users that are connected to the broadcaster’s chat session

    Args:
        broadcaster_id (str): The ID of the broadcaster whose list of chatters you want to get
        moderator_id (str): The ID of the broadcaster or one of the broadcaster’s moderators
            This ID must match the user ID in the user access token
        first (int): The maximum number of items to return
            Default: 100
            Minimum: 1
            Maximum: 1000

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[User]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/chat/chatters&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    users = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            users.extend(
                self.get_users([user[&#34;user_id&#34;] for user in response[&#34;data&#34;]])
            )

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return users</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_cheermotes"><code class="name flex">
<span>def <span class="ident">get_cheermotes</span></span>(<span>self, broadcaster_id='')</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the list of available Cheermotes
Cheermotes returned are available throughout Twitch, in all Bits-enabled channels</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID for the broadcaster who might own specialized Cheermotes</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cheermotes(self, broadcaster_id=&#34;&#34;):
    &#34;&#34;&#34;
    Retrieves the list of available Cheermotes
    Cheermotes returned are available throughout Twitch, in all Bits-enabled channels

    Args:
        broadcaster_id (str, optional): ID for the broadcaster who might own specialized Cheermotes

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/bits/cheermotes&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if broadcaster_id != &#34;&#34;:
        params = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_clips"><code class="name flex">
<span>def <span class="ident">get_clips</span></span>(<span>self, broadcaster_id: str = '', game_id: str = '', id: list[str] = [], started_at: str = '', ended_at: str = '', first: int = 20, is_featured: bool = False) ‑> list[<a title="twitchpy.clip.Clip" href="clip.html#twitchpy.clip.Clip">Clip</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets one or more video clips that were captured from streams
The id, game_id, and broadcaster_id query parameters are mutually exclusive</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>An ID that identifies the broadcaster whose video clips you want to get</dd>
<dt><strong><code>game_id</code></strong> :&ensp;<code>str</code></dt>
<dd>An ID that identifies the game whose clips you want to get</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>An ID that identifies the clip to get</dd>
<dt><strong><code>started_at</code></strong> :&ensp;<code>str</code></dt>
<dd>The start date used to filter clips</dd>
<dt><strong><code>ended_at</code></strong> :&ensp;<code>str</code></dt>
<dd>The end date used to filter clips</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of clips to return
Minimum: 1</dd>
<dt><strong><code>is_featured</code></strong> :&ensp;<code>bool</code></dt>
<dd>A Boolean value that determines whether the response includes featured clips</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[Clip]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_clips(
    self,
    broadcaster_id: str = &#34;&#34;,
    game_id: str = &#34;&#34;,
    id: list[str] = [],
    started_at: str = &#34;&#34;,
    ended_at: str = &#34;&#34;,
    first: int = 20,
    is_featured: bool = False,
) -&gt; list[Clip]:
    &#34;&#34;&#34;
    Gets one or more video clips that were captured from streams
    The id, game_id, and broadcaster_id query parameters are mutually exclusive

    Args:
        broadcaster_id (str): An ID that identifies the broadcaster whose video clips you want to get
        game_id (str): An ID that identifies the game whose clips you want to get
        id (list[str]): An ID that identifies the clip to get
        started_at (str): The start date used to filter clips
        ended_at (str): The end date used to filter clips
        first (int): The maximum number of clips to return
            Minimum: 1
        is_featured (bool): A Boolean value that determines whether the response includes featured clips

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[Clip]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/clips&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if broadcaster_id != &#34;&#34;:
        params[&#34;broadcaster_id&#34;] = broadcaster_id

    if game_id != &#34;&#34;:
        params[&#34;game_id&#34;] = game_id

    if len(id) &gt; 0:
        params[&#34;id&#34;] = id

    if started_at != &#34;&#34;:
        params[&#34;started_at&#34;] = started_at

    if ended_at != &#34;&#34;:
        params[&#34;ended_at&#34;] = ended_at

    if is_featured is not False:
        params[&#34;is_featured&#34;] = is_featured

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    clips = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for clip in response[&#34;data&#34;]:
                clips.append(
                    Clip(
                        clip[&#34;id&#34;],
                        clip[&#34;url&#34;],
                        clip[&#34;embed_url&#34;],
                        clip[&#34;broadcaster_id&#34;],
                        clip[&#34;broadcaster_name&#34;],
                        clip[&#34;creator_id&#34;],
                        clip[&#34;creator_name&#34;],
                        clip[&#34;video_id&#34;],
                        clip[&#34;game_id&#34;],
                        clip[&#34;language&#34;],
                        clip[&#34;title&#34;],
                        clip[&#34;view_count&#34;],
                        clip[&#34;created_at&#34;],
                        clip[&#34;thumbnail_url&#34;],
                        clip[&#34;duration&#34;],
                        clip[&#34;vod_offset&#34;],
                        clip[&#34;is_featured&#34;],
                    )
                )

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return clips</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_conduit_shards"><code class="name flex">
<span>def <span class="ident">get_conduit_shards</span></span>(<span>self, conduit_id: str, status: str = '') ‑> list[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a lists of all shards for a conduit</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conduit_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Conduit ID</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>str</code></dt>
<dd>Status to filter by</dd>
</dl>
<h2 id="raise">Raise</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[dict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_conduit_shards(self, conduit_id: str, status: str = &#34;&#34;) -&gt; list[dict]:
    &#34;&#34;&#34;
    Gets a lists of all shards for a conduit

    Args:
        conduit_id (str): Conduit ID
        status (str): Status to filter by

    Raise:
        twitchpy.errors.ClientError

    Returns:
        list[dict]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/eventsub/conduits/shards&#34;
    headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id}
    params = {&#34;conduit_id&#34;: conduit_id}

    if status != &#34;&#34;:
        params[&#34;status&#34;] = status

    response = requests.get(url, headers=headers, params=params)

    conduit_shards = []

    while response.ok and &#34;pagination&#34; in response:
        conduit_shards.append(response.json()[&#34;data&#34;])
        params[&#34;after&#34;] = response.json()[&#34;pagination&#34;][&#34;cursor&#34;]

        response = requests.get(url, headers=headers, params=params)

    if not response.ok:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return conduit_shards</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_conduits"><code class="name flex">
<span>def <span class="ident">get_conduits</span></span>(<span>self) ‑> list[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the conduits for a client ID</p>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[dict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_conduits(self) -&gt; list[dict]:
    &#34;&#34;&#34;
    Gets the conduits for a client ID

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[dict]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/eventsub/conduits&#34;
    headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id}

    response = requests.get(url, headers=headers)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_content_classification_labels"><code class="name flex">
<span>def <span class="ident">get_content_classification_labels</span></span>(<span>self, locale: str = 'en-US') ‑> list[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about Twitch content classification labels</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>locale</code></strong> :&ensp;<code>str</code></dt>
<dd>Locale for the Content Classification Labels
Possible values: "bg-BG", "cs-CZ", "da-DK", "da-DK", "de-DE", "el-GR", "en-GB", "en-US", "es-ES", "es-MX", "fi-FI", "fr-FR", "hu-HU", "it-IT", "ja-JP", "ko-KR", "nl-NL", "no-NO", "pl-PL", "pt-BT", "pt-PT", "ro-RO", "ru-RU", "sk-SK", "sv-SE", "th-TH", "tr-TR", "vi-VN", "zh-CN", "zh-TW"</dd>
</dl>
<h2 id="raise">Raise</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[dict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content_classification_labels(self, locale: str = &#34;en-US&#34;) -&gt; list[dict]:
    &#34;&#34;&#34;
    Gets information about Twitch content classification labels

    Args:
        locale (str): Locale for the Content Classification Labels
            Possible values: &#34;bg-BG&#34;, &#34;cs-CZ&#34;, &#34;da-DK&#34;, &#34;da-DK&#34;, &#34;de-DE&#34;, &#34;el-GR&#34;, &#34;en-GB&#34;, &#34;en-US&#34;, &#34;es-ES&#34;, &#34;es-MX&#34;, &#34;fi-FI&#34;, &#34;fr-FR&#34;, &#34;hu-HU&#34;, &#34;it-IT&#34;, &#34;ja-JP&#34;, &#34;ko-KR&#34;, &#34;nl-NL&#34;, &#34;no-NO&#34;, &#34;pl-PL&#34;, &#34;pt-BT&#34;, &#34;pt-PT&#34;, &#34;ro-RO&#34;, &#34;ru-RU&#34;, &#34;sk-SK&#34;, &#34;sv-SE&#34;, &#34;th-TH&#34;, &#34;tr-TR&#34;, &#34;vi-VN&#34;, &#34;zh-CN&#34;, &#34;zh-TW&#34;

    Raise:
        twitchpy.errors.ClientError

    Returns:
        list[dict]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/content_classification_labels&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if locale != &#34;en-US&#34;:
        params[&#34;locale&#34;] = locale

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_creator_goals"><code class="name flex">
<span>def <span class="ident">get_creator_goals</span></span>(<span>self, broadcaster_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the broadcaster’s list of active goals
Use this to get the current progress of each goal</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that created the goals</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_creator_goals(self, broadcaster_id):
    &#34;&#34;&#34;
    Gets the broadcaster’s list of active goals
    Use this to get the current progress of each goal

    Args:
        broadcaster_id (str): The ID of the broadcaster that created the goals

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/goals&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_custom_reward"><code class="name flex">
<span>def <span class="ident">get_custom_reward</span></span>(<span>self, broadcaster_id, id=[], only_manageable_rewards=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of Custom Reward objects for the Custom Rewards on a channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>This parameter filters the results and only returns reward objects for the Custom Rewards with matching ID
Maximum: 50</dd>
<dt><strong><code>only_manageable_rewards</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>When set to true, only returns custom rewards that the calling broadcaster can manage
Default: false</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_custom_reward(self, broadcaster_id, id=[], only_manageable_rewards=False):
    &#34;&#34;&#34;
    Returns a list of Custom Reward objects for the Custom Rewards on a channel

    Args:
        broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
        id (list, optional): This parameter filters the results and only returns reward objects for the Custom Rewards with matching ID
                            Maximum: 50
        only_manageable_rewards (bool, optional): When set to true, only returns custom rewards that the calling broadcaster can manage
                                                  Default: false

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/channel_points/custom_rewards&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    if len(id) &gt; 0:
        params[&#34;id&#34;] = id

    if only_manageable_rewards is not False:
        params[&#34;only_manageable_rewards&#34;] = only_manageable_rewards

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        rewards = []

        for reward in response.json()[&#34;data&#34;]:
            rewards.append(
                Reward(
                    reward[&#34;broadcaster_name&#34;],
                    reward[&#34;broadcaster_id&#34;],
                    reward[&#34;id&#34;],
                    image=reward[&#34;image&#34;],
                    background_color=reward[&#34;background_color&#34;],
                    is_enabled=reward[&#34;is_enabled&#34;],
                    cost=reward[&#34;cost&#34;],
                    title=reward[&#34;title&#34;],
                    prompt=reward[&#34;prompt&#34;],
                    is_user_input_required=reward[&#34;is_user_input_required&#34;],
                    max_per_stream_setting=reward[&#34;max_per_stream_setting&#34;],
                    max_per_user_per_stream_setting=reward[
                        &#34;max_per_user_per_stream_setting&#34;
                    ],
                    global_cooldown_setting=reward[&#34;global_cooldown_setting&#34;],
                    is_paused=reward[&#34;is_paused&#34;],
                    is_in_stock=reward[&#34;is_in_stock&#34;],
                    default_image=reward[&#34;default_image&#34;],
                    should_redemptions_skip_request_queue=reward[
                        &#34;should_redemptions_skip_request_queue&#34;
                    ],
                    redemptions_redeemed_current_stream=reward[
                        &#34;redemptions_redeemed_current_stream&#34;
                    ],
                    cooldown_expires_at=reward[&#34;cooldown_expires_at&#34;],
                )
            )

        return rewards

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_custom_reward_redemption"><code class="name flex">
<span>def <span class="ident">get_custom_reward_redemption</span></span>(<span>self, broadcaster_id, reward_id, id=[], status='', sort='OLDEST', first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns Custom Reward Redemption objects for a Custom Reward on a channel that was created by the same client_id
Developers only have access to get and update redemptions for the rewards created programmatically by the same client_id</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>reward_id</code></strong> :&ensp;<code>str</code></dt>
<dd>When ID is not provided, this parameter returns Custom Reward Redemption objects for redemptions of the Custom Reward with ID reward_id</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>When id is not provided, this param filters the results and only returns Custom Reward Redemption objects for the redemptions with matching ID
Maximum: 50</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>This param filters the Custom Reward Redemption objects for redemptions with the matching status
Can be one of UNFULFILLED, FULFILLED or CANCELED</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Sort order of redemptions returned when getting the Custom Reward Redemption objects for a reward
One of: OLDEST, NEWEST
Default: OLDEST</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of results to be returned when getting the Custom Reward Redemption objects for a reward
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_custom_reward_redemption(
    self, broadcaster_id, reward_id, id=[], status=&#34;&#34;, sort=&#34;OLDEST&#34;, first=20
):
    &#34;&#34;&#34;
    Returns Custom Reward Redemption objects for a Custom Reward on a channel that was created by the same client_id
    Developers only have access to get and update redemptions for the rewards created programmatically by the same client_id

    Args:
        broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
        reward_id (str): When ID is not provided, this parameter returns Custom Reward Redemption objects for redemptions of the Custom Reward with ID reward_id
        id (list, optional): When id is not provided, this param filters the results and only returns Custom Reward Redemption objects for the redemptions with matching ID
                            Maximum: 50
        status (str, optional): This param filters the Custom Reward Redemption objects for redemptions with the matching status
                                Can be one of UNFULFILLED, FULFILLED or CANCELED
        sort (str, optional): Sort order of redemptions returned when getting the Custom Reward Redemption objects for a reward
                              One of: OLDEST, NEWEST
                              Default: OLDEST
        first (int, optional): Number of results to be returned when getting the Custom Reward Redemption objects for a reward
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/channel_points/custom_rewards/redemptions&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;reward_id&#34;: reward_id}

    if len(id) &gt; 0:
        params[&#34;id&#34;] = id

    if status != &#34;&#34;:
        params[&#34;status&#34;] = status

    if sort != &#34;OLDEST&#34;:
        params[&#34;sort&#34;] = sort

    after = &#34;&#34;
    calls = math.ceil(first / 50)
    redemptions = []

    for call in range(calls):
        params[&#34;first&#34;] = min(50, first - (50 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            for redemption in response.json()[&#34;data&#34;]:
                reward = Reward(
                    redemption[&#34;broadcaster_name&#34;],
                    redemption[&#34;broadcaster_id&#34;],
                    redemption[&#34;reward&#34;][&#34;id&#34;],
                    cost=redemption[&#34;reward&#34;][&#34;cost&#34;],
                    title=redemption[&#34;reward&#34;][&#34;title&#34;],
                    prompt=redemption[&#34;reward&#34;][&#34;prompt&#34;],
                )
                redemptions.append(
                    Redemption(
                        redemption[&#34;broadcaster_name&#34;],
                        redemption[&#34;broadcaster_id&#34;],
                        redemption[&#34;id&#34;],
                        redemption[&#34;user_id&#34;],
                        redemption[&#34;user_name&#34;],
                        redemption[&#34;user_input&#34;],
                        redemption[&#34;status&#34;],
                        redemption[&#34;redeemed_at&#34;],
                        reward,
                    )
                )

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return redemptions</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_drops_entitlements"><code class="name flex">
<span>def <span class="ident">get_drops_entitlements</span></span>(<span>self, id='', user_id='', game_id='', fulfillment_status='', first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of entitlements for a given organization that have been granted to a game, user, or both</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the entitlement</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A Twitch User ID</dd>
<dt><strong><code>game_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A Twitch Game ID</dd>
<dt><strong><code>fulfillment_status</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>An optional fulfillment status used to filter entitlements
Valid values are "CLAIMED" or "FULFILLED"</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of entitlements to return
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_drops_entitlements(
    self, id=&#34;&#34;, user_id=&#34;&#34;, game_id=&#34;&#34;, fulfillment_status=&#34;&#34;, first=20
):
    &#34;&#34;&#34;
    Gets a list of entitlements for a given organization that have been granted to a game, user, or both

    Args:
        id (str, optional): ID of the entitlement
        user_id (str, optional): A Twitch User ID
        game_id (str, optional): A Twitch Game ID
        fulfillment_status (str, optional): An optional fulfillment status used to filter entitlements
                                            Valid values are &#34;CLAIMED&#34; or &#34;FULFILLED&#34;
        first (int, optional): Maximum number of entitlements to return
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/entitlements/drops&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if id != &#34;&#34;:
        params[&#34;id&#34;] = id

    if user_id != &#34;&#34;:
        params[&#34;user_id&#34;] = user_id

    if game_id != &#34;&#34;:
        params[&#34;game_id&#34;] = game_id

    if fulfillment_status != &#34;&#34;:
        params[&#34;fulfillment_status&#34;] = fulfillment_status

    after = &#34;&#34;
    calls = math.ceil(first / 1000)
    drops_entitlements = []

    for call in range(calls):
        params[&#34;first&#34;] = min(1000, first - (1000 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()
            drops_entitlements.extend(response[&#34;data&#34;])

            if &#34;pagination&#34; in response:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return drops_entitlements</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_emote_sets"><code class="name flex">
<span>def <span class="ident">get_emote_sets</span></span>(<span>self, emote_set_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all Twitch emotes for one or more specific emote sets</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>emote_set_id</code></strong> :&ensp;<code>list</code></dt>
<dd>ID(s) of the emote set
Maximum: 25</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_emote_sets(self, emote_set_id):
    &#34;&#34;&#34;
    Gets all Twitch emotes for one or more specific emote sets

    Args:
        emote_set_id (list): ID(s) of the emote set
                             Maximum: 25

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/chat/emotes/set&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;emote_set_id&#34;: emote_set_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        emotes = []

        for emote in response.json()[&#34;data&#34;]:
            emotes.append(
                Emote(
                    emote[&#34;id&#34;],
                    emote[&#34;name&#34;],
                    emote[&#34;images&#34;],
                    emote[&#34;format&#34;],
                    emote[&#34;scale&#34;],
                    emote[&#34;theme_mode&#34;],
                    emote_type=emote[&#34;emote_type&#34;],
                    emote_set_id=emote[&#34;emote_set_id&#34;],
                )
            )

        return emotes

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_eventsub_subscriptions"><code class="name flex">
<span>def <span class="ident">get_eventsub_subscriptions</span></span>(<span>self, status: str = '', type: str = '', user_id: str = '') ‑> list[<a title="twitchpy.eventsub_subscription.EventSubSubscription" href="eventsub_subscription.html#twitchpy.eventsub_subscription.EventSubSubscription">EventSubSubscription</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of your EventSub subscriptions
Only include one filter query parameter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filters subscriptions by one status type
Valid values: "enabled", "webhook_callback_verification_pending", "webhook_callback_verification_failed", "notification_failures_exceeded", "authorization_revoked", "moderator_removed", "user_removed", "version_removed", "websocket_disconnected", "websocket_failed_ping_pong", "websocket_received_inbound_traffic", "websocket_connection_unused", "websocket_internal_error", "websocket_network_timeout", "websocket_network_error"</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filters subscriptions by subscription type name</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filter subscriptions by user ID</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[EventSubSubscription]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_eventsub_subscriptions(
    self, status: str = &#34;&#34;, type: str = &#34;&#34;, user_id: str = &#34;&#34;
) -&gt; list[EventSubSubscription]:
    &#34;&#34;&#34;
    Get a list of your EventSub subscriptions
    Only include one filter query parameter

    Args:
        status (str, optional): Filters subscriptions by one status type
            Valid values: &#34;enabled&#34;, &#34;webhook_callback_verification_pending&#34;, &#34;webhook_callback_verification_failed&#34;, &#34;notification_failures_exceeded&#34;, &#34;authorization_revoked&#34;, &#34;moderator_removed&#34;, &#34;user_removed&#34;, &#34;version_removed&#34;, &#34;websocket_disconnected&#34;, &#34;websocket_failed_ping_pong&#34;, &#34;websocket_received_inbound_traffic&#34;, &#34;websocket_connection_unused&#34;, &#34;websocket_internal_error&#34;, &#34;websocket_network_timeout&#34;, &#34;websocket_network_error&#34;
        type (str, optional): Filters subscriptions by subscription type name
        user_id (str, optional): Filter subscriptions by user ID

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[EventSubSubscription]
    &#34;&#34;&#34;

    url = ENDPOINT_EVENTSUB_SUBSCRIPTION
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if status != &#34;&#34;:
        params[&#34;status&#34;] = status

    if type != &#34;&#34;:
        params[&#34;type&#34;] = type

    if user_id != &#34;&#34;:
        params[&#34;user_id&#34;] = user_id

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        subscriptions = []

        for subscription in response.json()[&#34;data&#34;]:
            subscriptions.append(
                EventSubSubscription(
                    subscription[&#34;id&#34;],
                    subscription[&#34;status&#34;],
                    subscription[&#34;type&#34;],
                    subscription[&#34;version&#34;],
                    subscription[&#34;condition&#34;],
                    subscription[&#34;created_at&#34;],
                    subscription[&#34;transport&#34;],
                    subscription[&#34;cost&#34;],
                )
            )

        return subscriptions

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_extension_analytics"><code class="name flex">
<span>def <span class="ident">get_extension_analytics</span></span>(<span>self, ended_at='', extension_id='', first=20, started_at='', type='')</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a URL that Extension developers can use to download analytics reports for their Extensions
The URL is valid for 5 minutes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ended_at</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ending date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
If this is provided, started_at also must be specified</dd>
<dt><strong><code>extension_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Client ID value assigned to the extension when it is created</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 20</dd>
<dt><strong><code>started_at</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Starting date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
This must be on or after January 31, 2018
If this is provided, ended_at also must be specified</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Type of analytics report that is returned
Valid values: "overview_v2"</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extension_analytics(
    self, ended_at=&#34;&#34;, extension_id=&#34;&#34;, first=20, started_at=&#34;&#34;, type=&#34;&#34;
):
    &#34;&#34;&#34;
    Gets a URL that Extension developers can use to download analytics reports for their Extensions
    The URL is valid for 5 minutes

    Args:
        ended_at (str, optional): Ending date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
                                  If this is provided, started_at also must be specified
        extension_id (str, optional): Client ID value assigned to the extension when it is created
        first (int, optional): Maximum number of objects to return
                               Default: 20
        started_at (str, optional): Starting date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
                                    This must be on or after January 31, 2018
                                    If this is provided, ended_at also must be specified
        type (str, optional): Type of analytics report that is returned
                              Valid values: &#34;overview_v2&#34;

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/analytics/extensions&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if ended_at != &#34;&#34;:
        params[&#34;ended_at&#34;] = ended_at

    if extension_id != &#34;&#34;:
        params[&#34;extension_id&#34;] = extension_id

    if started_at != &#34;&#34;:
        params[&#34;started_at&#34;] = started_at

    if type != &#34;&#34;:
        params[&#34;type&#34;] = type

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    extension_analytics = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()
            extension_analytics.extend(response[&#34;data&#34;])

            if &#34;pagination&#34; in response:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return extension_analytics</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_extension_bits_products"><code class="name flex">
<span>def <span class="ident">get_extension_bits_products</span></span>(<span>self, extension_client_id, should_include_all=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of Bits products that belongs to an Extension</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extension_client_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Extension client ID</dd>
<dt><strong><code>should_include_all</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether Bits products that are disabled/expired should be included in the response
Default: false</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extension_bits_products(
    self, extension_client_id, should_include_all=False
):
    &#34;&#34;&#34;
    Gets a list of Bits products that belongs to an Extension

    Args:
        extension_client_id (str): Extension client ID
        should_include_all (bool, optional): Whether Bits products that are disabled/expired should be included in the response
                                             Default: false

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/bits/extensions&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: extension_client_id,
    }
    params = {}

    if should_include_all is not False:
        params[&#34;should_include_all&#34;] = should_include_all

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_extension_configuration_segment"><code class="name flex">
<span>def <span class="ident">get_extension_configuration_segment</span></span>(<span>self, broadcaster_id, extension_id, segment)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the specified configuration segment from the specified extension
You can retrieve each segment a maximum of 20 times per minute</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster for the configuration returned
This parameter is required if you set the segment parameter to "broadcaster" or "developer"
Do not specify this parameter if you set segment to "global"</dd>
<dt><strong><code>extension_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the extension that contains the configuration segment you want to get</dd>
<dt><strong><code>segment</code></strong> :&ensp;<code>list</code></dt>
<dd>The type of configuration segment to get
Valid values are: "broadcaster", "developer", "global"</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extension_configuration_segment(
    self, broadcaster_id, extension_id, segment
):
    &#34;&#34;&#34;
    Gets the specified configuration segment from the specified extension
    You can retrieve each segment a maximum of 20 times per minute

    Args:
        broadcaster_id (str): The ID of the broadcaster for the configuration returned
                              This parameter is required if you set the segment parameter to &#34;broadcaster&#34; or &#34;developer&#34;
                              Do not specify this parameter if you set segment to &#34;global&#34;
        extension_id (str): The ID of the extension that contains the configuration segment you want to get
        segment (list): The type of configuration segment to get
                       Valid values are: &#34;broadcaster&#34;, &#34;developer&#34;, &#34;global&#34;

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/extensions/configurations&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;extension_id&#34;: extension_id,
        &#34;segment&#34;: segment,
    }

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_extension_live_channels"><code class="name flex">
<span>def <span class="ident">get_extension_live_channels</span></span>(<span>self, extension_id, first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns one page of live channels that have installed or activated a specific Extension, identified by a client ID value assigned to the Extension when it is created
A channel that recently went live may take a few minutes to appear in this list, and a channel may continue to appear on this list for a few minutes after it stops broadcasting</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extension_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the Extension to search for</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extension_live_channels(self, extension_id, first=20):
    &#34;&#34;&#34;
    Returns one page of live channels that have installed or activated a specific Extension, identified by a client ID value assigned to the Extension when it is created
    A channel that recently went live may take a few minutes to appear in this list, and a channel may continue to appear on this list for a few minutes after it stops broadcasting

    Args:
        extension_id (str): ID of the Extension to search for
        first (int, optional): Maximum number of objects to return
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/extensions/live&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: {self.client_id},
    }
    params = {&#34;extension_id&#34;: extension_id}

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    channels = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for channel in response[&#34;data&#34;]:
                channels.append(channel)

            if &#34;pagination&#34; in response:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return channels</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_extension_secrets"><code class="name flex">
<span>def <span class="ident">get_extension_secrets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a specified Extension’s secret data consisting of a version and an array of secret objects
Each secret object contains a base64-encoded secret, a UTC timestamp when the secret becomes active, and a timestamp when the secret expires</p>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extension_secrets(self):
    &#34;&#34;&#34;
    Retrieves a specified Extension’s secret data consisting of a version and an array of secret objects
    Each secret object contains a base64-encoded secret, a UTC timestamp when the secret becomes active, and a timestamp when the secret expires

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/extensions/jwt/secrets&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }

    response = requests.get(url, headers=headers)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_extension_transactions"><code class="name flex">
<span>def <span class="ident">get_extension_transactions</span></span>(<span>self, extension_id, id=[], first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows extension back-end servers to fetch a list of transactions that have occurred for their extension across all of Twitch
A transaction is a record of a user exchanging Bits for an in-Extension digital good</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extension_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the extension to list transactions for</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Transaction IDs to look up
Maximum: 100</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extension_transactions(self, extension_id, id=[], first=20):
    &#34;&#34;&#34;
    Allows extension back-end servers to fetch a list of transactions that have occurred for their extension across all of Twitch
    A transaction is a record of a user exchanging Bits for an in-Extension digital good

    Args:
        extension_id (str): ID of the extension to list transactions for
        id (list, optional): Transaction IDs to look up
                             Maximum: 100
        first (int, optional): Maximum number of objects to return
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/extensions/transactions&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;extension_id&#34;: extension_id}

    if len(id) &gt; 0:
        params[&#34;id&#34;] = id

    if first != 20:
        params[&#34;first&#34;] = first

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    extension_transactions = []

    for call in range(calls):
        if first - (100 * call) &gt; 100:
            params[&#34;first&#34;] = 100

        else:
            params[&#34;first&#34;] = first - (100 * call)

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()
            extension_transactions.extend(response[&#34;data&#34;])

            if &#34;pagination&#34; in response:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return extension_transactions</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_extensions"><code class="name flex">
<span>def <span class="ident">get_extensions</span></span>(<span>self, extension_id, extension_version='')</span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about your Extensions; either the current version or a specified version</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extension_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the Extension</dd>
<dt><strong><code>extension_version</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The specific version of the Extension to return
If not provided, the current version is returned</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extensions(self, extension_id, extension_version=&#34;&#34;):
    &#34;&#34;&#34;
    Gets information about your Extensions; either the current version or a specified version

    Args:
        extension_id (str): ID of the Extension
        extension_version (str, optional): The specific version of the Extension to return
                                           If not provided, the current version is returned

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/extensions&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;extension_id&#34;: extension_id}

    if extension_version != &#34;&#34;:
        params[&#34;extension_version&#34;] = extension_version

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        extensions = []

        for extension in response.json()[&#34;data&#34;]:
            extensions.append(
                Extension(
                    extension[&#34;author_name&#34;],
                    extension[&#34;bits_enables&#34;],
                    extension[&#34;can_install&#34;],
                    extension[&#34;configuration_location&#34;],
                    extension[&#34;description&#34;],
                    extension[&#34;eula_tos_url&#34;],
                    extension[&#34;has_chat_support&#34;],
                    extension[&#34;icon_url&#34;],
                    extension[&#34;icon_urls&#34;],
                    extension[&#34;id&#34;],
                    extension[&#34;name&#34;],
                    extension[&#34;privacy_policy_url&#34;],
                    extension[&#34;request_identity_link&#34;],
                    extension[&#34;screenshot_urls&#34;],
                    extension[&#34;state&#34;],
                    extension[&#34;subscriptions_support_level&#34;],
                    extension[&#34;summary&#34;],
                    extension[&#34;support_email&#34;],
                    extension[&#34;version&#34;],
                    extension[&#34;viewer_summary&#34;],
                    extension[&#34;views&#34;],
                    extension[&#34;allowlisted_config_urls&#34;],
                    extension[&#34;allowlisted_panel_urls&#34;],
                )
            )

        return extensions

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_followed_channels"><code class="name flex">
<span>def <span class="ident">get_followed_channels</span></span>(<span>self, user_id: str, broadcaster_id: str = '', first: int = 20) ‑> list[<a title="twitchpy.channel.Channel" href="channel.html#twitchpy.channel.Channel">Channel</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of broadcasters that the specified user follows</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>A user’s ID
Returns the list of broadcasters that this user follows
This ID must match the user ID in the user OAuth token</dd>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>A broadcaster’s ID
Use this parameter to see whether the user follows this broadcaster</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of items to return
Default: 20
Minimum: 1</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[Channel]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_followed_channels(
    self, user_id: str, broadcaster_id: str = &#34;&#34;, first: int = 20
) -&gt; list[Channel]:
    &#34;&#34;&#34;
    Gets a list of broadcasters that the specified user follows

    Args:
        user_id (str): A user’s ID
            Returns the list of broadcasters that this user follows
            This ID must match the user ID in the user OAuth token
        broadcaster_id (str): A broadcaster’s ID
            Use this parameter to see whether the user follows this broadcaster
        first (int): The maximum number of items to return
            Default: 20
            Minimum: 1

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[Channel]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/channels/followed&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;user_id&#34;: user_id}

    if broadcaster_id != &#34;&#34;:
        params[&#34;broadcaster_id&#34;] = broadcaster_id

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    channels = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            channels.append(
                self.get_channel(
                    [channel[&#34;broadcaster_id&#34;] for channel in response[&#34;data&#34;]]
                )
            )

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return channels</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_followed_streams"><code class="name flex">
<span>def <span class="ident">get_followed_streams</span></span>(<span>self, user_id: str, first: int = 100) ‑> list[<a title="twitchpy.stream.Stream" href="stream.html#twitchpy.stream.Stream">Stream</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the list of broadcasters that the user follows and that are streaming live</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user whose list of followed streams you want to get
This ID must match the user ID in the access token</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of items to return
Minimum: 1</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[Stream]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_followed_streams(self, user_id: str, first: int = 100) -&gt; list[Stream]:
    &#34;&#34;&#34;
    Gets the list of broadcasters that the user follows and that are streaming live

    Args:
        user_id (str): The ID of the user whose list of followed streams you want to get
            This ID must match the user ID in the access token
        first (int): The maximum number of items to return
            Minimum: 1

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[Stream]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/streams/followed&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;user_id&#34;: user_id}

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    streams = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for stream in response[&#34;data&#34;]:
                streams.append(
                    Stream(
                        stream[&#34;id&#34;],
                        stream[&#34;user_id&#34;],
                        stream[&#34;user_login&#34;],
                        stream[&#34;user_name&#34;],
                        stream[&#34;game_id&#34;],
                        stream[&#34;game_name&#34;],
                        stream[&#34;type&#34;],
                        stream[&#34;title&#34;],
                        stream[&#34;tags&#34;],
                        stream[&#34;viewer_count&#34;],
                        stream[&#34;started_at&#34;],
                        stream[&#34;language&#34;],
                        stream[&#34;thumbnail_url&#34;],
                        stream[&#34;is_mature&#34;],
                    )
                )

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return streams</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_game_analytics"><code class="name flex">
<span>def <span class="ident">get_game_analytics</span></span>(<span>self, ended_at='', first=20, game_id='', started_at='', type='')</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a URL that game developers can use to download analytics reports for their games
The URL is valid for 5 minutes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ended_at</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ending date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
If this is provided, started_at also must be specified</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 20</dd>
<dt><strong><code>game_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Game ID</dd>
<dt><strong><code>started_at</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Starting date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
If this is provided, ended_at also must be specified</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Type of analytics report that is returned
Valid values: "overview_v2"</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_game_analytics(
    self, ended_at=&#34;&#34;, first=20, game_id=&#34;&#34;, started_at=&#34;&#34;, type=&#34;&#34;
):
    &#34;&#34;&#34;
    Gets a URL that game developers can use to download analytics reports for their games
    The URL is valid for 5 minutes

    Args:
        ended_at (str, optional): Ending date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
                                  If this is provided, started_at also must be specified
        first (int, optional): Maximum number of objects to return
                               Default: 20
        game_id (str, optional): Game ID
        started_at (str, optional): Starting date/time for returned reports, in RFC3339 format with the hours, minutes, and seconds zeroed out and the UTC timezone: YYYY-MM-DDT00:00:00Z
                                    If this is provided, ended_at also must be specified
        type (str, optional): Type of analytics report that is returned
                              Valid values: &#34;overview_v2&#34;

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/analytics/games&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if ended_at != &#34;&#34;:
        params[&#34;ended_at&#34;] = ended_at

    if game_id != &#34;&#34;:
        params[&#34;game_id&#34;] = game_id

    if started_at != &#34;&#34;:
        params[&#34;started_at&#34;] = started_at

    if type != &#34;&#34;:
        params[&#34;type&#34;] = type

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    game_analytics = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()
            game_analytics.extend(response[&#34;data&#34;])

            if &#34;pagination&#34; in response:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return game_analytics</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_games"><code class="name flex">
<span>def <span class="ident">get_games</span></span>(<span>self, id: list[str] = [], name: list[str] = [], igdb_id: list[str] = []) ‑> list[<a title="twitchpy.game.Game" href="game.html#twitchpy.game.Game">Game</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about specified categories or games</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The ID of the category or game to get
Maximum: 100</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The name of the category or game to get
Maximum: 100</dd>
<dt><strong><code>igdb_id</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The IGDB ID of the game to get
Maximum: 100</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[Game]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_games(
    self, id: list[str] = [], name: list[str] = [], igdb_id: list[str] = []
) -&gt; list[Game]:
    &#34;&#34;&#34;
    Gets information about specified categories or games

    Args:
        id (list[str]): The ID of the category or game to get
            Maximum: 100
        name (list[str]): The name of the category or game to get
            Maximum: 100
        igdb_id (list[str]): The IGDB ID of the game to get
            Maximum: 100

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[Game]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/games&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if len(id) &gt; 0:
        params[&#34;id&#34;] = id

    if len(name) &gt; 0:
        params[&#34;name&#34;] = name

    if len(igdb_id) &gt; 0:
        params[&#34;igdb_id&#34;] = igdb_id

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        games = []

        for game in response.json()[&#34;data&#34;]:
            games.append(
                Game(game[&#34;id&#34;], game[&#34;name&#34;], game[&#34;box_art_url&#34;], game[&#34;igdb_id&#34;])
            )

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return games</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_global_chat_badges"><code class="name flex">
<span>def <span class="ident">get_global_chat_badges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of chat badges that can be used in chat for any channel</p>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_chat_badges(self):
    &#34;&#34;&#34;
    Gets a list of chat badges that can be used in chat for any channel

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/chat/badges/global&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }

    response = requests.get(url, headers=headers)

    if response.ok:
        badges = []

        for badge in response.json()[&#34;data&#34;]:
            badges.append(Badge(badge[&#34;set_id&#34;], badge[&#34;versions&#34;]))

        return badges

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_global_emotes"><code class="name flex">
<span>def <span class="ident">get_global_emotes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all global emotes
Global emotes are Twitch-specific emoticons that every user can use in Twitch chat</p>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_emotes(self):
    &#34;&#34;&#34;
    Gets all global emotes
    Global emotes are Twitch-specific emoticons that every user can use in Twitch chat

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/chat/emotes/global&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }

    response = requests.get(url, headers=headers)

    if response.ok:
        emotes = []

        for emote in response.json()[&#34;data&#34;]:
            emotes.append(
                Emote(
                    emote[&#34;id&#34;],
                    emote[&#34;name&#34;],
                    emote[&#34;images&#34;],
                    emote[&#34;format&#34;],
                    emote[&#34;scale&#34;],
                    emote[&#34;theme_mode&#34;],
                )
            )

        return emotes

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_guest_star_invites"><code class="name flex">
<span>def <span class="ident">get_guest_star_invites</span></span>(<span>self, broadcaster_id: str, moderator_id: str, session_id: str) ‑> list[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Provides a list of pending invites to a Guest Star session, including the invitee’s ready status while joining the waiting room</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster running the Guest Star session</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
This ID must match the user_id in the user access token</dd>
<dt><strong><code>session_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The session ID to query for invite status</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[dict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_guest_star_invites(
    self, broadcaster_id: str, moderator_id: str, session_id: str
) -&gt; list[dict]:
    &#34;&#34;&#34;
    Provides a list of pending invites to a Guest Star session, including the invitee’s ready status while joining the waiting room

    Args:
        broadcaster_id (str): The ID of the broadcaster running the Guest Star session
        moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
            This ID must match the user_id in the user access token
        session_id (str): The session ID to query for invite status

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[dict]
    &#34;&#34;&#34;

    url = ENDPOINT_GUEST_STAR_INVITES
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;moderator_id&#34;: moderator_id,
        &#34;session_id&#34;: session_id,
    }

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_guest_star_session"><code class="name flex">
<span>def <span class="ident">get_guest_star_session</span></span>(<span>self, broadcaster_id: str, moderator_id: str) ‑> <a title="twitchpy.guest_star_session.GuestStarSession" href="guest_star_session.html#twitchpy.guest_star_session.GuestStarSession">GuestStarSession</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about an ongoing Guest Star session for a particular channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID for the user hosting the Guest Star session</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID in the user access token</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>GuestStarSession</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_guest_star_session(
    self, broadcaster_id: str, moderator_id: str
) -&gt; GuestStarSession:
    &#34;&#34;&#34;
    Gets information about an ongoing Guest Star session for a particular channel

    Args:
        broadcaster_id (str): ID for the user hosting the Guest Star session
        moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
            This ID must match the user ID in the user access token

    Raises:
        twitchpy.errors.ClientError

    Returns:
        GuestStarSession
    &#34;&#34;&#34;

    url = ENDPOINT_GUEST_STAR_SESSION
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        response = response.json()[&#34;data&#34;][0]

        return GuestStarSession(response[&#34;id&#34;], response[&#34;guests&#34;])

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;data&#34;][&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_hype_train_events"><code class="name flex">
<span>def <span class="ident">get_hype_train_events</span></span>(<span>self, broadcaster_id: str, first: int = 1) ‑> list[<a title="twitchpy.hypetrain_event.HypeTrainEvent" href="hypetrain_event.html#twitchpy.hypetrain_event.HypeTrainEvent">HypeTrainEvent</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the information of the most recent Hype Train of the given channel ID
When there is currently an active Hype Train, it returns information about that Hype Train
When there is currently no active Hype Train, it returns information about the most recent Hype Train
After 5 days, if no Hype Train has been active, the endpoint will return an empty response</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the broadcaster
Must match the User ID in the Bearer token if User Token is used</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 1</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[HypeTrainEvent]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hype_train_events(
    self, broadcaster_id: str, first: int = 1
) -&gt; list[HypeTrainEvent]:
    &#34;&#34;&#34;
    Gets the information of the most recent Hype Train of the given channel ID
    When there is currently an active Hype Train, it returns information about that Hype Train
    When there is currently no active Hype Train, it returns information about the most recent Hype Train
    After 5 days, if no Hype Train has been active, the endpoint will return an empty response

    Args:
        broadcaster_id (str): User ID of the broadcaster
            Must match the User ID in the Bearer token if User Token is used
        first (int, optional): Maximum number of objects to return
            Default: 1

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[HypeTrainEvent]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/hypetrain/events&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    cursor = &#34;&#34;
    calls = math.ceil(first / 100)
    events = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if cursor != &#34;&#34;:
            params[&#34;cursor&#34;] = cursor

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for event in response[&#34;data&#34;]:
                events.append(
                    HypeTrainEvent(
                        event[&#34;id&#34;],
                        event[&#34;event_type&#34;],
                        event[&#34;event_timestamp&#34;],
                        event[&#34;version&#34;],
                        event[&#34;event_data&#34;],
                    )
                )

            if &#34;pagination&#34; in response and response[&#34;pagination&#34;] is not None:
                cursor = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return events</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_moderators"><code class="name flex">
<span>def <span class="ident">get_moderators</span></span>(<span>self, broadcaster_id, user_id=[], first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all moderators in a channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Provided broadcaster_id must match the user_id in the auth token</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Filters the results and only returns a status object for users who are moderators in this channel and have a matching user_id
Maximum: 100</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_moderators(self, broadcaster_id, user_id=[], first=20):
    &#34;&#34;&#34;
    Returns all moderators in a channel

    Args:
        broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token
        user_id (list, optional): Filters the results and only returns a status object for users who are moderators in this channel and have a matching user_id
                                  Maximum: 100
        first (int, optional): Maximum number of objects to return
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = ENDPOINT_MODERATORS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    if len(user_id) &gt; 0:
        params[&#34;user_id&#34;] = user_id

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    ids = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for user in response[&#34;data&#34;]:
                ids.append(user[&#34;user_id&#34;])

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return self.get_users(id=ids)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_polls"><code class="name flex">
<span>def <span class="ident">get_polls</span></span>(<span>self, broadcaster_id, id=[], first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Get information about all polls or specific polls for a Twitch channel
Poll information is available for 90 days</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The broadcaster running polls
Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>ID of a poll
Maximum: 100</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_polls(self, broadcaster_id, id=[], first=20):
    &#34;&#34;&#34;
    Get information about all polls or specific polls for a Twitch channel
    Poll information is available for 90 days

    Args:
        broadcaster_id (str): The broadcaster running polls
                              Provided broadcaster_id must match the user_id in the user OAuth token
        id (list, optional): ID of a poll
                             Maximum: 100
        first (int, optional): Maximum number of objects to return
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = ENDPOINT_POLLS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    if len(id) &gt; 0:
        params[&#34;id&#34;] = id

    after = &#34;&#34;
    calls = math.ceil(first / 20)
    polls = []

    for call in range(calls):
        params[&#34;first&#34;] = min(20, first - (20 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            if response[&#34;data&#34;] is not None:
                for poll in response[&#34;data&#34;]:
                    polls.append(
                        Poll(
                            poll[&#34;id&#34;],
                            poll[&#34;broadcaster_id&#34;],
                            poll[&#34;broadcaster_name&#34;],
                            poll[&#34;broadcaster_login&#34;],
                            poll[&#34;title&#34;],
                            poll[&#34;choices&#34;],
                            poll[&#34;bits_voting_enabled&#34;],
                            poll[&#34;bits_per_vote&#34;],
                            poll[&#34;channel_points_voting_enabled&#34;],
                            poll[&#34;channel_points_per_vote&#34;],
                            poll[&#34;status&#34;],
                            poll[&#34;duration&#34;],
                            poll[&#34;started_at&#34;],
                        )
                    )

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return polls</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_predictions"><code class="name flex">
<span>def <span class="ident">get_predictions</span></span>(<span>self, broadcaster_id, id=[], first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Get information about all Channel Points Predictions or specific Channel Points Predictions for a Twitch channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The broadcaster running Predictions
Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of a Prediction
Maximum: 100</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_predictions(self, broadcaster_id, id=[], first=20):
    &#34;&#34;&#34;
    Get information about all Channel Points Predictions or specific Channel Points Predictions for a Twitch channel

    Args:
        broadcaster_id (str): The broadcaster running Predictions
                              Provided broadcaster_id must match the user_id in the user OAuth token
        id (str, optional): ID of a Prediction
                            Maximum: 100
        first (int, optional): Maximum number of objects to return
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = ENDPOINT_PREDICTIONS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    if len(id) &gt; 0:
        params[&#34;id&#34;] = id

    after = &#34;&#34;
    calls = math.ceil(first / 20)
    predictions = []

    for call in range(calls):
        params[&#34;first&#34;] = min(20, first - (20 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for prediction in response[&#34;data&#34;]:
                predictions.append(
                    Prediction(
                        prediction[&#34;id&#34;],
                        prediction[&#34;broadcaster_id&#34;],
                        prediction[&#34;broadcaster_name&#34;],
                        prediction[&#34;broadcaster_login&#34;],
                        prediction[&#34;title&#34;],
                        prediction[&#34;winning_outcome_id&#34;],
                        prediction[&#34;outcomes&#34;],
                        prediction[&#34;prediction_window&#34;],
                        prediction[&#34;status&#34;],
                        prediction[&#34;created_at&#34;],
                        prediction[&#34;ended_at&#34;],
                        prediction[&#34;locked_at&#34;],
                    )
                )

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return predictions</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_released_extensions"><code class="name flex">
<span>def <span class="ident">get_released_extensions</span></span>(<span>self, extension_id, extension_version='')</span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about a released Extension; either the current version or a specified version</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extension_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the Extension</dd>
<dt><strong><code>extension_version</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The specific version of the Extension to return
If not provided, the current version is returned</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_released_extensions(self, extension_id, extension_version=&#34;&#34;):
    &#34;&#34;&#34;
    Gets information about a released Extension; either the current version or a specified version

    Args:
        extension_id (str): ID of the Extension
        extension_version (str, optional): The specific version of the Extension to return
                                           If not provided, the current version is returned

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/extensions/released&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;extension_id&#34;: extension_id}

    if extension_version != &#34;&#34;:
        params[&#34;extension_version&#34;] = extension_version

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        extensions = []

        for extension in response.json()[&#34;data&#34;]:
            extensions.append(
                Extension(
                    extension[&#34;author_name&#34;],
                    extension[&#34;bits_enables&#34;],
                    extension[&#34;can_install&#34;],
                    extension[&#34;configuration_location&#34;],
                    extension[&#34;description&#34;],
                    extension[&#34;eula_tos_url&#34;],
                    extension[&#34;has_chat_support&#34;],
                    extension[&#34;icon_url&#34;],
                    extension[&#34;icon_urls&#34;],
                    extension[&#34;id&#34;],
                    extension[&#34;name&#34;],
                    extension[&#34;privacy_policy_url&#34;],
                    extension[&#34;request_identity_link&#34;],
                    extension[&#34;screenshot_urls&#34;],
                    extension[&#34;state&#34;],
                    extension[&#34;subscriptions_support_level&#34;],
                    extension[&#34;summary&#34;],
                    extension[&#34;support_email&#34;],
                    extension[&#34;version&#34;],
                    extension[&#34;viewer_summary&#34;],
                    extension[&#34;views&#34;],
                    extension[&#34;allowlisted_config_urls&#34;],
                    extension[&#34;allowlisted_panel_urls&#34;],
                )
            )

        return extensions

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_shield_mode_status"><code class="name flex">
<span>def <span class="ident">get_shield_mode_status</span></span>(<span>self, broadcaster_id: str, moderator_id: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the broadcaster’s Shield Mode activation status</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster whose Shield Mode activation status you want to get</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or a user that is one of the broadcaster’s moderators
This ID must match the user ID in the access token</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shield_mode_status(self, broadcaster_id: str, moderator_id: str) -&gt; dict:
    &#34;&#34;&#34;
    Gets the broadcaster’s Shield Mode activation status

    Args:
        broadcaster_id (str): The ID of the broadcaster whose Shield Mode activation status you want to get
        moderator_id (str): The ID of the broadcaster or a user that is one of the broadcaster’s moderators
            This ID must match the user ID in the access token

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/moderation/shield_mode&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_stream_key"><code class="name flex">
<span>def <span class="ident">get_stream_key</span></span>(<span>self, broadcaster_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the channel stream key for a user</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the broadcaster</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stream_key(self, broadcaster_id):
    &#34;&#34;&#34;
    Gets the channel stream key for a user

    Args:
        broadcaster_id (str): User ID of the broadcaster

    Raises:
        twitchpy.errors.ClientError

    Returns:
        str
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/streams/key&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;][0][&#34;stream_key&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_stream_markers"><code class="name flex">
<span>def <span class="ident">get_stream_markers</span></span>(<span>self, user_id='', video_id='', first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of markers for either a specified user’s most recent stream or a specified VOD/video (stream)
A marker is an arbitrary point in a stream that the broadcaster wants to mark; e.g., to easily return to later
The only markers returned are those created by the user identified by the Bearer token
Only one of user_id and video_id must be specified</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the broadcaster from whose stream markers are returned</dd>
<dt><strong><code>video_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the VOD/video whose stream markers are returned</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of values to be returned when getting videos by user or game ID
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stream_markers(self, user_id=&#34;&#34;, video_id=&#34;&#34;, first=20):
    &#34;&#34;&#34;
    Gets a list of markers for either a specified user’s most recent stream or a specified VOD/video (stream)
    A marker is an arbitrary point in a stream that the broadcaster wants to mark; e.g., to easily return to later
    The only markers returned are those created by the user identified by the Bearer token
    Only one of user_id and video_id must be specified

    Args:
        user_id (str, optional): ID of the broadcaster from whose stream markers are returned
        video_id (str, optional): ID of the VOD/video whose stream markers are returned
        first (int, optional): Number of values to be returned when getting videos by user or game ID
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/streams/markers&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if user_id != &#34;&#34;:
        params[&#34;user_id&#34;] = user_id

    if video_id != &#34;&#34;:
        params[&#34;video_id&#34;] = video_id

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    markers = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()
            markers.extend(response[&#34;data&#34;])

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return markers</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_stream_tags"><code class="name flex">
<span>def <span class="ident">get_stream_tags</span></span>(<span>self, broadcaster_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the list of current stream tags that have been set for a channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the channel to get tags</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stream_tags(self, broadcaster_id):
    &#34;&#34;&#34;
    Gets the list of current stream tags that have been set for a channel

    Args:
        broadcaster_id (str): User ID of the channel to get tags

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/streams/tags&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        response = response.json()
        tags = []

        for tag in response[&#34;data&#34;]:
            tags.append(
                Tag(
                    tag[&#34;tag_id&#34;],
                    tag[&#34;is_auto&#34;],
                    tag[&#34;localization_names&#34;],
                    tag[&#34;localization_descriptions&#34;],
                )
            )

        return tags

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_streams"><code class="name flex">
<span>def <span class="ident">get_streams</span></span>(<span>self, user_id: str | list[str] = '', user_login: str | list[str] = '', game_id: str | list[str] = '', type: str = 'all', language: str | list[str] = '', first: int = 20) ‑> list[<a title="twitchpy.stream.Stream" href="stream.html#twitchpy.stream.Stream">Stream</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of all streams
The list is in descending order by the number of viewers watching the stream</p>
<h2 id="args">Args</h2>
<dl>
<dt>user_id (str | list[str]): A user ID used to filter the list of streams</dt>
<dt>Maximum: 100</dt>
<dt>user_login (str | list[str]): A user login name used to filter the list of streams</dt>
<dt>Maximum: 100</dt>
<dt>game_id (str | list[str]): A game (category) ID used to filter the list of streams</dt>
<dt>Maximum: 100</dt>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of stream to filter the list of streams by
Possible values: all, live</dd>
<dt>language (str | list[str]): A language code used to filter the list of streams</dt>
<dt>Maximum: 100</dt>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of items to return
Minimum: 1</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[Stream]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_streams(
    self,
    user_id: str | list[str] = &#34;&#34;,
    user_login: str | list[str] = &#34;&#34;,
    game_id: str | list[str] = &#34;&#34;,
    type: str = &#34;all&#34;,
    language: str | list[str] = &#34;&#34;,
    first: int = 20,
) -&gt; list[Stream]:
    &#34;&#34;&#34;
    Gets a list of all streams
    The list is in descending order by the number of viewers watching the stream

    Args:
        user_id (str | list[str]): A user ID used to filter the list of streams
            Maximum: 100
        user_login (str | list[str]): A user login name used to filter the list of streams
            Maximum: 100
        game_id (str | list[str]): A game (category) ID used to filter the list of streams
            Maximum: 100
        type (str): The type of stream to filter the list of streams by
            Possible values: all, live
        language (str | list[str]): A language code used to filter the list of streams
            Maximum: 100
        first (int): The maximum number of items to return
            Minimum: 1

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[Stream]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/streams&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if user_id != &#34;&#34;:
        params[&#34;user_id&#34;] = user_id

    if user_login != &#34;&#34;:
        params[&#34;user_login&#34;] = user_login

    if game_id != &#34;&#34;:
        params[&#34;game_id&#34;] = game_id

    if type != &#34;all&#34;:
        params[&#34;type&#34;] = type

    if language != &#34;&#34;:
        params[&#34;language&#34;] = language

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    streams = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for stream in response[&#34;data&#34;]:
                streams.append(
                    Stream(
                        stream[&#34;id&#34;],
                        stream[&#34;user_id&#34;],
                        stream[&#34;user_login&#34;],
                        stream[&#34;user_name&#34;],
                        stream[&#34;game_id&#34;],
                        stream[&#34;game_name&#34;],
                        stream[&#34;type&#34;],
                        stream[&#34;title&#34;],
                        stream[&#34;tags&#34;],
                        stream[&#34;viewer_count&#34;],
                        stream[&#34;started_at&#34;],
                        stream[&#34;language&#34;],
                        stream[&#34;thumbnail_url&#34;],
                        stream[&#34;is_mature&#34;],
                    )
                )

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return streams</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_teams"><code class="name flex">
<span>def <span class="ident">get_teams</span></span>(<span>self, name='', id='')</span>
</code></dt>
<dd>
<div class="desc"><p>Gets information for a specific Twitch Team
One of the two optional query parameters must be specified to return Team information</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Team name</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Team ID</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>Team</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_teams(self, name=&#34;&#34;, id=&#34;&#34;):
    &#34;&#34;&#34;
    Gets information for a specific Twitch Team
    One of the two optional query parameters must be specified to return Team information

    Args:
        name (str, optional): Team name
        id (str, optional): Team ID

    Raises:
        twitchpy.errors.ClientError

    Returns:
        Team
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/teams&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if name != &#34;&#34;:
        params[&#34;name&#34;] = name

    if id != &#34;&#34;:
        params[&#34;id&#34;] = id

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        team = response.json()[&#34;data&#34;][0]
        users = []

        for user in team[&#34;users&#34;]:
            users.append(
                User(user[&#34;user_id&#34;], user[&#34;user_login&#34;], user[&#34;user_name&#34;])
            )

        team = Team(
            users,
            team[&#34;background_image_url&#34;],
            team[&#34;banner&#34;],
            team[&#34;created_at&#34;],
            team[&#34;updated_at&#34;],
            team[&#34;info&#34;],
            team[&#34;thumbnail_url&#34;],
            team[&#34;team_name&#34;],
            team[&#34;team_display_name&#34;],
            team[&#34;id&#34;],
        )

        return team

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_top_games"><code class="name flex">
<span>def <span class="ident">get_top_games</span></span>(<span>self, first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets games sorted by number of current viewers on Twitch, most popular first</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_top_games(self, first=20):
    &#34;&#34;&#34;
    Gets games sorted by number of current viewers on Twitch, most popular first

    Args:
        first (int, optional): Maximum number of objects to return
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/games/top&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    games = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for game in response[&#34;data&#34;]:
                games.append(
                    Game(
                        game[&#34;id&#34;],
                        game[&#34;name&#34;],
                        game[&#34;box_art_url&#34;],
                        game[&#34;igdb_id&#34;],
                    )
                )

            if &#34;pagination&#34; in response:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return games</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_user_active_extensions"><code class="name flex">
<span>def <span class="ident">get_user_active_extensions</span></span>(<span>self, user_id='')</span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about active extensions installed by a specified user, identified by a user ID or Bearer token</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the user whose installed extensions will be returned</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_active_extensions(self, user_id=&#34;&#34;):
    &#34;&#34;&#34;
    Gets information about active extensions installed by a specified user, identified by a user ID or Bearer token

    Args:
        user_id (str, optional): ID of the user whose installed extensions will be returned

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/users/extensions&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if user_id != &#34;&#34;:
        params = {&#34;user_id&#34;: user_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_user_block_list"><code class="name flex">
<span>def <span class="ident">get_user_block_list</span></span>(<span>self, broadcaster_id, first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a specified user’s block list</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID for a Twitch user</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_block_list(self, broadcaster_id, first=20):
    &#34;&#34;&#34;
    Gets a specified user’s block list

    Args:
        broadcaster_id (str): User ID for a Twitch user
        first (int, optional): Maximum number of objects to return
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = ENDPOINT_USER_BLOCKS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    if first != 20:
        params[&#34;first&#34;] = first

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    ids = []

    for call in range(calls):
        if first - (100 * call) &gt; 100:
            params[&#34;first&#34;] = 100

        else:
            params[&#34;first&#34;] = first - (100 * call)

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            for user in response.json()[&#34;data&#34;]:
                ids.append(user[&#34;user_id&#34;])

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return self.get_users(id=ids)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_user_chat_color"><code class="name flex">
<span>def <span class="ident">get_user_chat_color</span></span>(<span>self, user_id: str | list[str]) ‑> list[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the color used for the user’s name in chat</p>
<h2 id="args">Args</h2>
<p>user_id (str | list[str]): The ID of the user whose username color you want to get
Maximum: 100</p>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[dict]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_chat_color(self, user_id: str | list[str]) -&gt; list[dict]:
    &#34;&#34;&#34;
    Gets the color used for the user’s name in chat

    Args:
        user_id (str | list[str]): The ID of the user whose username color you want to get
            Maximum: 100

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[dict]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/chat/color&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;user_id&#34;: user_id}

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_user_extensions"><code class="name flex">
<span>def <span class="ident">get_user_extensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of all extensions (both active and inactive) for a specified user, identified by a Bearer token</p>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_extensions(self):
    &#34;&#34;&#34;
    Gets a list of all extensions (both active and inactive) for a specified user, identified by a Bearer token

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/users/extensions/list&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }

    response = requests.get(url, headers=headers)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_users"><code class="name flex">
<span>def <span class="ident">get_users</span></span>(<span>self, id=[], login=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Gets an user
Users are identified by optional user IDs and/or login name
If neither a user ID nor a login name is specified, the user is looked up by Bearer token</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>User ID
Limit: 100</dd>
<dt><strong><code>login</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>User login name
Limit: 100</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_users(self, id=[], login=[]):
    &#34;&#34;&#34;
    Gets an user
    Users are identified by optional user IDs and/or login name
    If neither a user ID nor a login name is specified, the user is looked up by Bearer token

    Args:
        id (list, optional): User ID
                             Limit: 100
        login (list, optional): User login name
                                Limit: 100

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/users&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if len(id) &gt; 0:
        params[&#34;id&#34;] = id

    if len(login) &gt; 0:
        aux = []

        for i in range(len(login)):
            aux.append(login[i].replace(&#34;@&#34;, &#34;&#34;).lower())

        params[&#34;login&#34;] = aux

    response = requests.get(url, headers=headers, params=params)

    if response.ok:
        users = []

        for user in response.json()[&#34;data&#34;]:
            users.append(
                User(
                    user[&#34;id&#34;],
                    user[&#34;login&#34;],
                    user[&#34;display_name&#34;],
                    user[&#34;type&#34;],
                    user[&#34;broadcaster_type&#34;],
                    user[&#34;description&#34;],
                    user[&#34;profile_image_url&#34;],
                    user[&#34;offline_image_url&#34;],
                    user[&#34;view_count&#34;],
                )
            )

        return users

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_videos"><code class="name flex">
<span>def <span class="ident">get_videos</span></span>(<span>self, id=[], user_id='', game_id='', first=20, language='', period='all', sort='time', type='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Gets video information by video ID, user ID, or game ID
Each request must specify one video id, one user_id, or one game_id</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>list</code></dt>
<dd>ID of the video being queried
Limit: 100
If this is specified, you cannot use first, language, period, sort and type</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the user who owns the video</dd>
<dt><strong><code>game_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the game the video is of</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of values to be returned when getting videos by user or game ID
Default: 20</dd>
<dt><strong><code>language</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Language of the video being queried
A language value must be either the ISO 639-1 two-letter code for a supported stream language or "other"</dd>
<dt><strong><code>period</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Period during which the video was created
Valid values: "all", "day", "week", "month"</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Sort order of the videos
Valid values: "time", "trending", "views"
Default: "time"</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Type of video
Valid values: "all", "upload", "archive", "highlight"
Default: "all"</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_videos(
    self,
    id=[],
    user_id=&#34;&#34;,
    game_id=&#34;&#34;,
    first=20,
    language=&#34;&#34;,
    period=&#34;all&#34;,
    sort=&#34;time&#34;,
    type=&#34;all&#34;,
):
    &#34;&#34;&#34;
    Gets video information by video ID, user ID, or game ID
    Each request must specify one video id, one user_id, or one game_id

    Args:
        id (list): ID of the video being queried
                   Limit: 100
                   If this is specified, you cannot use first, language, period, sort and type
        user_id (str): ID of the user who owns the video
        game_id (str): ID of the game the video is of
        first (int, optional): Number of values to be returned when getting videos by user or game ID
                               Default: 20
        language (str, optional): Language of the video being queried
                                  A language value must be either the ISO 639-1 two-letter code for a supported stream language or &#34;other&#34;
        period (str, optional): Period during which the video was created
                                Valid values: &#34;all&#34;, &#34;day&#34;, &#34;week&#34;, &#34;month&#34;
        sort (str, optional): Sort order of the videos
                              Valid values: &#34;time&#34;, &#34;trending&#34;, &#34;views&#34;
                              Default: &#34;time&#34;
        type (str, optional): Type of video
                              Valid values: &#34;all&#34;, &#34;upload&#34;, &#34;archive&#34;, &#34;highlight&#34;
                              Default: &#34;all&#34;

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/videos&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if len(id) &gt; 0:
        params[&#34;id&#34;] = id

    if user_id != &#34;&#34;:
        params[&#34;user_id&#34;] = user_id

    if game_id != &#34;&#34;:
        params[&#34;game_id&#34;] = game_id

    if language != &#34;&#34;:
        params[&#34;language&#34;] = language

    if period != &#34;all&#34;:
        params[&#34;period&#34;] = period

    if sort != &#34;time&#34;:
        params[&#34;sort&#34;] = sort

    if type != &#34;all&#34;:
        params[&#34;type&#34;] = type

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    videos = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for video in response[&#34;data&#34;]:
                videos.append(
                    Video(
                        video[&#34;id&#34;],
                        video[&#34;user_id&#34;],
                        video[&#34;user_name&#34;],
                        video[&#34;title&#34;],
                        video[&#34;description&#34;],
                        video[&#34;created_at&#34;],
                        video[&#34;published_at&#34;],
                        video[&#34;url&#34;],
                        video[&#34;thumbnail_url&#34;],
                        video[&#34;viewable&#34;],
                        video[&#34;view_count&#34;],
                        video[&#34;language&#34;],
                        video[&#34;type&#34;],
                        video[&#34;duration&#34;],
                    )
                )

            if &#34;pagination&#34; in response:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return videos</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_vips"><code class="name flex">
<span>def <span class="ident">get_vips</span></span>(<span>self, broadcaster_id: str, user_id: list[str] = [], first: int = 20) ‑> list[<a title="twitchpy.user.User" href="user.html#twitchpy.user.User">User</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of the broadcaster’s VIPs</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster whose list of VIPs you want to get
This ID must match the user ID in the access token</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Filters the list for specific VIPs
Maximum: 100</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of items to return
Minimum: 1
Maximum: 100</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[User]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vips(
    self, broadcaster_id: str, user_id: list[str] = [], first: int = 20
) -&gt; list[User]:
    &#34;&#34;&#34;
    Gets a list of the broadcaster’s VIPs

    Args:
        broadcaster_id (str): The ID of the broadcaster whose list of VIPs you want to get
            This ID must match the user ID in the access token
        user_id (list[str]): Filters the list for specific VIPs
            Maximum: 100
        first (int): The number of items to return
            Minimum: 1
            Maximum: 100

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[User]
    &#34;&#34;&#34;

    url = ENDPOINT_VIPS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;broadcaster_id&#34;: broadcaster_id}

    if len(user_id) &gt; 0:
        params[&#34;user_id&#34;] = user_id

    after = &#34;&#34;
    calls = math.ceil(first / 20)
    users = []

    for call in range(calls):
        params[&#34;first&#34;] = min(20, first - (20 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            if response[&#34;data&#34;] is not None:
                users.append(
                    self.get_users(
                        id=[user[&#34;user_id&#34;] for user in response[&#34;data&#34;]]
                    )
                )

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return users</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.get_webhook_subscriptions"><code class="name flex">
<span>def <span class="ident">get_webhook_subscriptions</span></span>(<span>self, first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the Webhook subscriptions of an application identified by a Bearer token, in order of expiration</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of values to be returned
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_webhook_subscriptions(self, first=20):
    &#34;&#34;&#34;
    Gets the Webhook subscriptions of an application identified by a Bearer token, in order of expiration

    Args:
        first (int, optional): Number of values to be returned
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/webhooks/subscriptions&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {}

    if first != 20:
        params = {&#34;first&#34;: first}

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    subscriptions = []

    for call in range(calls):
        if first - (100 * call) &gt; 100:
            params[&#34;first&#34;] = 100

        else:
            params[&#34;first&#34;] = first - (100 * call)

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()
            subscriptions.extend(response[&#34;data&#34;])

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return subscriptions</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.manage_held_automod_messages"><code class="name flex">
<span>def <span class="ident">manage_held_automod_messages</span></span>(<span>self, user_id, msg_id, action)</span>
</code></dt>
<dd>
<div class="desc"><p>Allow or deny a message that was held for review by AutoMod</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The moderator who is approving or rejecting the held message
Must match the user_id in the user OAuth token</dd>
<dt><strong><code>msg_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the message to be allowed or denied</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>The action to take for the message
Must be "ALLOW" or "DENY"</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def manage_held_automod_messages(self, user_id, msg_id, action):
    &#34;&#34;&#34;
    Allow or deny a message that was held for review by AutoMod

    Args:
        user_id (str): The moderator who is approving or rejecting the held message
                       Must match the user_id in the user OAuth token
        msg_id (str): ID of the message to be allowed or denied
        action (str): The action to take for the message
                      Must be &#34;ALLOW&#34; or &#34;DENY&#34;
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/moderation/automod/message&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {&#34;user_id&#34;: user_id, &#34;msg_id&#34;: msg_id, &#34;action&#34;: action}

    requests.post(url, headers=headers, json=payload)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.modify_channel_information"><code class="name flex">
<span>def <span class="ident">modify_channel_information</span></span>(<span>self, broadcaster_id: str, game_id: str = None, broadcaster_language: str = None, title: str = None, delay: int = None, tags: list[str] = [], content_classification_labels: list[dict] = [], is_branded_content: bool = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates a channel’s properties</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster whose channel you want to update
ID must match the user ID in the user access token</dd>
<dt><strong><code>game_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the game that the user plays</dd>
<dt><strong><code>broadcaster_language</code></strong> :&ensp;<code>str</code></dt>
<dd>The user’s preferred language
Set the value to an ISO 639-1 two-letter language code
Set to “other” if the user’s preferred language is not a Twitch supported language</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title of the user’s stream</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of seconds you want your broadcast buffered before streaming it live
Only users with Partner status may set this field
Maximum: 900 seconds</dd>
<dt><strong><code>tags</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>A list of channel-defined tags to apply to the channel
Maximum: 10</dd>
<dt><strong><code>content_classification_labels</code></strong> :&ensp;<code>list[dict]</code></dt>
<dd>List of labels that should be set as the Channel’s CCLs</dd>
<dt><strong><code>is_branded_content</code></strong> :&ensp;<code>bool</code></dt>
<dd>Boolean flag indicating if the channel has branded content</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modify_channel_information(
    self,
    broadcaster_id: str,
    game_id: str = None,
    broadcaster_language: str = None,
    title: str = None,
    delay: int = None,
    tags: list[str] = [],
    content_classification_labels: list[dict] = [],
    is_branded_content: bool = None,
):
    &#34;&#34;&#34;
    Updates a channel’s properties

    Args:
        broadcaster_id (str): The ID of the broadcaster whose channel you want to update
            ID must match the user ID in the user access token
        game_id (str): The ID of the game that the user plays
        broadcaster_language (str): The user’s preferred language
            Set the value to an ISO 639-1 two-letter language code
            Set to “other” if the user’s preferred language is not a Twitch supported language
        title (str): The title of the user’s stream
        delay (int): The number of seconds you want your broadcast buffered before streaming it live
            Only users with Partner status may set this field
            Maximum: 900 seconds
        tags (list[str]): A list of channel-defined tags to apply to the channel
            Maximum: 10
        content_classification_labels (list[dict]): List of labels that should be set as the Channel’s CCLs
        is_branded_content (bool): Boolean flag indicating if the channel has branded content
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/channels&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id}

    if game_id is not None:
        data[&#34;game_id&#34;] = game_id

    if broadcaster_language is not None:
        data[&#34;broadcaster_language&#34;] = broadcaster_language

    if title is not None:
        data[&#34;title&#34;] = title

    if delay is not None:
        data[&#34;delay&#34;] = delay

    if len(tags) &gt; 0:
        data[&#34;tags&#34;] = tags

    if len(content_classification_labels) &gt; 0:
        data[&#34;content_classification_labels&#34;] = content_classification_labels

    if is_branded_content is not None:
        data[&#34;is_branded_content&#34;] = is_branded_content

    requests.patch(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.remove_blocked_term"><code class="name flex">
<span>def <span class="ident">remove_blocked_term</span></span>(<span>self, broadcaster_id, id, moderator_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the word or phrase that the broadcaster is blocking users from using in their chat room</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that owns the list of blocked terms</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the blocked term you want to delete</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID associated with the user OAuth token
If the broadcaster wants to delete the blocked term (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_blocked_term(self, broadcaster_id, id, moderator_id):
    &#34;&#34;&#34;
    Removes the word or phrase that the broadcaster is blocking users from using in their chat room

    Args:
        broadcaster_id (str): The ID of the broadcaster that owns the list of blocked terms
        id (str): The ID of the blocked term you want to delete
        moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                            This ID must match the user ID associated with the user OAuth token
                            If the broadcaster wants to delete the blocked term (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
    &#34;&#34;&#34;

    url = ENDPOINT_MODERATION_BLOCKED_TERMS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;id&#34;: id,
        &#34;moderator_id&#34;: moderator_id,
    }

    requests.delete(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.remove_channel_moderator"><code class="name flex">
<span>def <span class="ident">remove_channel_moderator</span></span>(<span>self, broadcaster_id: str, user_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a moderator from the broadcaster’s chat room</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that owns the chat room
This ID must match the user ID in the access token</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user to remove as a moderator from the broadcaster’s chat room</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_channel_moderator(self, broadcaster_id: str, user_id: str) -&gt; None:
    &#34;&#34;&#34;
    Removes a moderator from the broadcaster’s chat room

    Args:
        broadcaster_id (str): The ID of the broadcaster that owns the chat room
            This ID must match the user ID in the access token
        user_id (str): The ID of the user to remove as a moderator from the broadcaster’s chat room
    &#34;&#34;&#34;

    url = ENDPOINT_MODERATORS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;user_id&#34;: user_id}

    requests.delete(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.remove_channel_vip"><code class="name flex">
<span>def <span class="ident">remove_channel_vip</span></span>(<span>self, user_id: str, broadcaster_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the specified user as a VIP in the broadcaster’s channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user to remove VIP status from</dd>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user to remove VIP status from</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_channel_vip(self, user_id: str, broadcaster_id: str) -&gt; None:
    &#34;&#34;&#34;
    Removes the specified user as a VIP in the broadcaster’s channel

    Args:
        user_id (str): The ID of the user to remove VIP status from
        broadcaster_id (str): The ID of the user to remove VIP status from
    &#34;&#34;&#34;

    url = ENDPOINT_VIPS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;user_id&#34;: user_id, &#34;broadcaster_id&#34;: broadcaster_id}

    requests.delete(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.search_categories"><code class="name flex">
<span>def <span class="ident">search_categories</span></span>(<span>self, query, first=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of games or categories that match the query via name either entirely or partially</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>query</code></strong> :&ensp;<code>str</code></dt>
<dd>URI encoded search query</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of objects to return
Default: 20</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_categories(self, query, first=20):
    &#34;&#34;&#34;
    Returns a list of games or categories that match the query via name either entirely or partially

    Args:
        query (str): URI encoded search query
        first (int, optional): Maximum number of objects to return
                               Default: 20

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/search/categories&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;query&#34;: query}

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    games = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for game in response[&#34;data&#34;]:
                games.append(
                    Game(game[&#34;id&#34;], game[&#34;name&#34;], box_art_url=game[&#34;box_art_url&#34;])
                )

            if &#34;pagination&#34; in response:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return games</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.search_channels"><code class="name flex">
<span>def <span class="ident">search_channels</span></span>(<span>self, query: str, first: int = 20, live_only: bool = False) ‑> list[<a title="twitchpy.channel.Channel" href="channel.html#twitchpy.channel.Channel">Channel</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the channels that match the specified query and have streamed content within the past 6 months
To match, the beginning of the broadcaster’s name or category must match the query string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>query</code></strong> :&ensp;<code>str</code></dt>
<dd>The URI-encoded search string</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of items to return
Minimum: 1</dd>
<dt><strong><code>live_only</code></strong> :&ensp;<code>bool</code></dt>
<dd>A Boolean value that determines whether the response includes only channels that are currently streaming live</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list[Channel]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_channels(
    self, query: str, first: int = 20, live_only: bool = False
) -&gt; list[Channel]:
    &#34;&#34;&#34;
    Gets the channels that match the specified query and have streamed content within the past 6 months
    To match, the beginning of the broadcaster’s name or category must match the query string

    Args:
        query (str): The URI-encoded search string
        first (int): The maximum number of items to return
            Minimum: 1
        live_only (bool): A Boolean value that determines whether the response includes only channels that are currently streaming live

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list[Channel]
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/search/channels&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    params = {&#34;query&#34;: query}

    if live_only is not False:
        params[&#34;live_only&#34;] = live_only

    after = &#34;&#34;
    calls = math.ceil(first / 100)
    channels = []

    for call in range(calls):
        params[&#34;first&#34;] = min(100, first - (100 * call))

        if after != &#34;&#34;:
            params[&#34;after&#34;] = after

        response = requests.get(url, headers=headers, params=params)

        if response.ok:
            response = response.json()

            for channel in response[&#34;data&#34;]:
                channels.append(
                    Channel(
                        channel[&#34;id&#34;],
                        channel[&#34;broadcaster_login&#34;],
                        channel[&#34;display_name&#34;],
                        channel[&#34;game_id&#34;],
                        channel[&#34;game_name&#34;],
                        channel[&#34;title&#34;],
                        broadcaster_language=channel[&#34;broadcaster_language&#34;],
                    )
                )

            if &#34;pagination&#34; in response and &#34;cursor&#34; in response[&#34;pagination&#34;]:
                after = response[&#34;pagination&#34;][&#34;cursor&#34;]

        else:
            raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])

    return channels</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.send_a_shoutout"><code class="name flex">
<span>def <span class="ident">send_a_shoutout</span></span>(<span>self, from_broadcaster_id: str, to_broadcaster_id: str, moderator_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a Shoutout to the specified broadcaster</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>from_broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that’s sending the Shoutout</dd>
<dt><strong><code>to_broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that’s receiving the Shoutout</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or a user that is one of the broadcaster’s moderators
This ID must match the user ID in the access token</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_a_shoutout(
    self, from_broadcaster_id: str, to_broadcaster_id: str, moderator_id: str
) -&gt; None:
    &#34;&#34;&#34;
    Sends a Shoutout to the specified broadcaster

    Args:
        from_broadcaster_id (str): The ID of the broadcaster that’s sending the Shoutout
        to_broadcaster_id (str): The ID of the broadcaster that’s receiving the Shoutout
        moderator_id (str): The ID of the broadcaster or a user that is one of the broadcaster’s moderators
            This ID must match the user ID in the access token
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/chat/shoutouts&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {
        &#34;from_broadcaster_id&#34;: from_broadcaster_id,
        &#34;to_broadcaster_id&#34;: to_broadcaster_id,
        &#34;moderator_id&#34;: moderator_id,
    }

    requests.post(url, headers=headers, json=payload)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.send_chat_announcement"><code class="name flex">
<span>def <span class="ident">send_chat_announcement</span></span>(<span>self, broadcaster_id: str, moderator_id: str, message: str, color: str = '') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sends an announcement to the broadcaster’s chat room</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that owns the chat room to send the announcement to</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of a user who has permission to moderate the broadcaster’s chat room, or the broadcaster’s ID if they’re sending the announcement
This ID must match the user ID in the user access token</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>The announcement to make in the broadcaster’s chat
Announcements are limited to a maximum of 500 characters</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code></dt>
<dd>Announcements are limited to a maximum of 500 characters
Possible case-sensitive values are: blue, green, orange, purple, primary (default)
If color is set to primary or is not set, the channel’s accent color is used to highlight the announcement</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_chat_announcement(
    self, broadcaster_id: str, moderator_id: str, message: str, color: str = &#34;&#34;
) -&gt; None:
    &#34;&#34;&#34;
    Sends an announcement to the broadcaster’s chat room

    Args:
        broadcaster_id (str): The ID of the broadcaster that owns the chat room to send the announcement to
        moderator_id (str): The ID of a user who has permission to moderate the broadcaster’s chat room, or the broadcaster’s ID if they’re sending the announcement
            This ID must match the user ID in the user access token
        message (str): The announcement to make in the broadcaster’s chat
            Announcements are limited to a maximum of 500 characters
        color (str): Announcements are limited to a maximum of 500 characters
            Possible case-sensitive values are: blue, green, orange, purple, primary (default)
            If color is set to primary or is not set, the channel’s accent color is used to highlight the announcement
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/chat/announcements&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
        &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
    }
    payload = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;moderator_id&#34;: moderator_id,
        &#34;message&#34;: message,
    }

    if color != &#34;&#34;:
        payload[&#34;color&#34;] = color

    requests.post(url, headers=headers, json=payload)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.send_extension_chat_message"><code class="name flex">
<span>def <span class="ident">send_extension_chat_message</span></span>(<span>self, broadcaster_id, text, extension_id, extension_version)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a specified chat message to a specified channel
The message will appear in the channel’s chat as a normal message
The "username" of the message is the Extension name
There is a limit of 12 messages per minute, per channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the broadcaster whose channel has the Extension activated</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Message for Twitch chat
Maximum: 280 characters</dd>
<dt><strong><code>extension_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Client ID associated with the Extension</dd>
<dt><strong><code>extension_version</code></strong> :&ensp;<code>str</code></dt>
<dd>Version of the Extension sending this message</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_extension_chat_message(
    self, broadcaster_id, text, extension_id, extension_version
):
    &#34;&#34;&#34;
    Sends a specified chat message to a specified channel
    The message will appear in the channel’s chat as a normal message
    The &#34;username&#34; of the message is the Extension name
    There is a limit of 12 messages per minute, per channel

    Args:
        broadcaster_id (str): User ID of the broadcaster whose channel has the Extension activated
        text (str): Message for Twitch chat
                    Maximum: 280 characters
        extension_id (str): Client ID associated with the Extension
        extension_version (str): Version of the Extension sending this message
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/extensions/chat&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;text&#34;: text,
        &#34;extension_id&#34;: extension_id,
        &#34;extension_version&#34;: extension_version,
    }

    requests.post(url, headers=headers, json=payload)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.send_extension_pubsub_message"><code class="name flex">
<span>def <span class="ident">send_extension_pubsub_message</span></span>(<span>self, target, broadcaster_id, is_global_broadcast, message)</span>
</code></dt>
<dd>
<div class="desc"><p>A message can be sent to either a specified channel or globally (all channels on which your extension is active)
Extension PubSub has a rate limit of 100 requests per minute for a combination of Extension client ID and broadcaster ID</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong> :&ensp;<code>list</code></dt>
<dd>Array of strings for valid PubSub targets
Valid values: "broadcast", "global", "whisper-<user-id>"</dd>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the broadcaster receiving the payload</dd>
<dt><strong><code>is_global_broadcast</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the message should be sent to all channels where your Extension is active</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>String-encoded JSON message to be sent</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_extension_pubsub_message(
    self, target, broadcaster_id, is_global_broadcast, message
):
    &#34;&#34;&#34;
    A message can be sent to either a specified channel or globally (all channels on which your extension is active)
    Extension PubSub has a rate limit of 100 requests per minute for a combination of Extension client ID and broadcaster ID

    Args:
        target (list): Array of strings for valid PubSub targets
                       Valid values: &#34;broadcast&#34;, &#34;global&#34;, &#34;whisper-&lt;user-id&gt;&#34;
        broadcaster_id (str): ID of the broadcaster receiving the payload
        is_global_broadcast (bool): Indicates if the message should be sent to all channels where your Extension is active
        message (str): String-encoded JSON message to be sent
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/extensions/pubsub&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {
        &#34;target&#34;: target,
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;is_global_broadcast&#34;: is_global_broadcast,
        &#34;message&#34;: message,
    }

    requests.post(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.send_guest_star_invite"><code class="name flex">
<span>def <span class="ident">send_guest_star_invite</span></span>(<span>self, broadcaster_id: str, moderator_id: str, session_id: str, guest_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sends an invite to a specified guest on behalf of the broadcaster for a Guest Star session in progress</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster running the Guest Star session</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
This ID must match the user_id in the user access token</dd>
<dt><strong><code>session_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The session ID for the invite to be sent on behalf of the broadcaster</dd>
<dt><strong><code>guest_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Twitch User ID for the guest to invite to the Guest Star session</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_guest_star_invite(
    self, broadcaster_id: str, moderator_id: str, session_id: str, guest_id: str
) -&gt; None:
    &#34;&#34;&#34;
    Sends an invite to a specified guest on behalf of the broadcaster for a Guest Star session in progress

    Args:
        broadcaster_id (str): The ID of the broadcaster running the Guest Star session
        moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
            This ID must match the user_id in the user access token
        session_id (str): The session ID for the invite to be sent on behalf of the broadcaster
        guest_id (str): Twitch User ID for the guest to invite to the Guest Star session
    &#34;&#34;&#34;

    url = ENDPOINT_GUEST_STAR_INVITES
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;moderator_id&#34;: moderator_id,
        &#34;session_id&#34;: session_id,
        &#34;guest_id&#34;: guest_id,
    }

    requests.post(url, headers=headers, json=payload)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.send_whisper"><code class="name flex">
<span>def <span class="ident">send_whisper</span></span>(<span>self, from_user_id: str, to_user_id: str, message: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a whisper message to the specified use</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>from_user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user sending the whisper
This user must have a verified phone number
This ID must match the user ID in the user access token</dd>
<dt><strong><code>to_user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user to receive the whisper</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>The whisper message to send
Maximum length: 500 characters if the user you're sending the message to hasn't whispered you before or 10,000 characters if the user you're sending the message to has whispered you before</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_whisper(self, from_user_id: str, to_user_id: str, message: str) -&gt; None:
    &#34;&#34;&#34;
    Sends a whisper message to the specified use

    Args:
        from_user_id (str): The ID of the user sending the whisper
            This user must have a verified phone number
            This ID must match the user ID in the user access token
        to_user_id (str): The ID of the user to receive the whisper
        message (str): The whisper message to send
            Maximum length: 500 characters if the user you&#39;re sending the message to hasn&#39;t whispered you before or 10,000 characters if the user you&#39;re sending the message to has whispered you before
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/whispers&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
        &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
    }
    payload = {
        &#34;from_user_id&#34;: from_user_id,
        &#34;to_user_id&#34;: to_user_id,
        &#34;message&#34;: message,
    }

    requests.post(url, headers=headers, json=payload)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.set_extension_configuration_segment"><code class="name flex">
<span>def <span class="ident">set_extension_configuration_segment</span></span>(<span>self, extension_id, segment, broadcaster_id='', content='', version='')</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a single configuration segment of any type
Each segment is limited to 5 KB and can be set at most 20 times per minute
Updates to this data are not delivered to Extensions that have already been rendered</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extension_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID for the Extension which the configuration is for</dd>
<dt><strong><code>segment</code></strong> :&ensp;<code>str</code></dt>
<dd>Configuration type
Valid values are "global", "developer", or "broadcaster"</dd>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>User ID of the broadcaster
Required if the segment type is "developer" or "broadcaster"</dd>
<dt><strong><code>content</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Configuration in a string-encoded format</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Configuration version with the segment type</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_extension_configuration_segment(
    self, extension_id, segment, broadcaster_id=&#34;&#34;, content=&#34;&#34;, version=&#34;&#34;
):
    &#34;&#34;&#34;
    Sets a single configuration segment of any type
    Each segment is limited to 5 KB and can be set at most 20 times per minute
    Updates to this data are not delivered to Extensions that have already been rendered

    Args:
        extension_id (str): ID for the Extension which the configuration is for
        segment (str): Configuration type
                       Valid values are &#34;global&#34;, &#34;developer&#34;, or &#34;broadcaster&#34;
        broadcaster_id (str, optional): User ID of the broadcaster
                                        Required if the segment type is &#34;developer&#34; or &#34;broadcaster&#34;
        content (str, optional): Configuration in a string-encoded format
        version (str, optional): Configuration version with the segment type
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/extensions/configurations&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;extension_id&#34;: extension_id, &#34;segment&#34;: segment}

    if broadcaster_id != &#34;&#34;:
        data[&#34;broadcaster_id&#34;] = broadcaster_id

    if content != &#34;&#34;:
        data[&#34;content&#34;] = content

    if version != &#34;&#34;:
        data[&#34;version&#34;] = version

    requests.put(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.set_extension_required_configuration"><code class="name flex">
<span>def <span class="ident">set_extension_required_configuration</span></span>(<span>self, broadcaster_id, extension_id, extension_version, configuration_version)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable activation of a specified Extension, after any required broadcaster configuration is correct</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the broadcaster who has activated the specified Extension on their channel</dd>
<dt><strong><code>extension_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID for the Extension to activate</dd>
<dt><strong><code>extension_version</code></strong> :&ensp;<code>str</code></dt>
<dd>The version fo the Extension to release</dd>
<dt><strong><code>configuration_version</code></strong> :&ensp;<code>str</code></dt>
<dd>The version of the configuration to use with the Extension</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_extension_required_configuration(
    self, broadcaster_id, extension_id, extension_version, configuration_version
):
    &#34;&#34;&#34;
    Enable activation of a specified Extension, after any required broadcaster configuration is correct

    Args:
        broadcaster_id (str): User ID of the broadcaster who has activated the specified Extension on their channel
        extension_id (str): ID for the Extension to activate
        extension_version (str): The version fo the Extension to release
        configuration_version (str): The version of the configuration to use with the Extension
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/extensions/required_configuration&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__jwt_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;extension_id&#34;: extension_id,
        &#34;extension_version&#34;: extension_version,
        &#34;configuration_version&#34;: configuration_version,
    }

    requests.put(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.snooze_next_ad"><code class="name flex">
<span>def <span class="ident">snooze_next_ad</span></span>(<span>self, broadcaster_id) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>If available, pushes back the timestamp of the upcoming automatic mid-roll ad by 5 minutes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Provided broadcaster_id must match the user_id in the auth token</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def snooze_next_ad(self, broadcaster_id) -&gt; dict:
    &#34;&#34;&#34;
    If available, pushes back the timestamp of the upcoming automatic mid-roll ad by 5 minutes

    Args:
        broadcaster_id (str): Provided broadcaster_id must match the user_id in the auth token

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/channels/ads/schedule/snooze&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {&#34;broadcaster_id&#34;: broadcaster_id}

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.start_commercial"><code class="name flex">
<span>def <span class="ident">start_commercial</span></span>(<span>self, broadcaster_id, length)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts a commercial on a specified channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of the channel requesting a commercial</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>Desired length of the commercial in seconds
Valid options are 30, 60, 90, 120, 150 and 180</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_commercial(self, broadcaster_id, length):
    &#34;&#34;&#34;
    Starts a commercial on a specified channel

    Args:
        broadcaster_id (int): ID of the channel requesting a commercial
        length (int): Desired length of the commercial in seconds
                      Valid options are 30, 60, 90, 120, 150 and 180

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/channels/commercial&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
        &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
    }
    payload = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;length&#34;: length}

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        response = response.json()
        return response[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.start_raid"><code class="name flex">
<span>def <span class="ident">start_raid</span></span>(<span>self, from_broadcaster_id: str, to_broadcaster_id: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Raid another channel by sending the broadcaster’s viewers to the targeted channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>from_broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster that’s sending the raiding party
This ID must match the user ID in the user access token</dd>
<dt><strong><code>to_broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster to raid</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_raid(self, from_broadcaster_id: str, to_broadcaster_id: str) -&gt; dict:
    &#34;&#34;&#34;
    Raid another channel by sending the broadcaster’s viewers to the targeted channel

    Args:
        from_broadcaster_id (str): The ID of the broadcaster that’s sending the raiding party
            This ID must match the user ID in the user access token
        to_broadcaster_id (str): The ID of the broadcaster to raid

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/raids&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    payload = {
        &#34;from_broadcaster_id&#34;: from_broadcaster_id,
        &#34;to_broadcaster_id&#34;: to_broadcaster_id,
    }

    response = requests.post(url, headers=headers, json=payload)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.unban_user"><code class="name flex">
<span>def <span class="ident">unban_user</span></span>(<span>self, broadcaster_id, moderator_id, user_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the ban or timeout that was placed on the specified user</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster whose chat room the user is banned from chatting in</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID associated with the user OAuth token
If the broadcaster wants to remove the ban (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user to remove the ban or timeout from</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unban_user(self, broadcaster_id, moderator_id, user_id):
    &#34;&#34;&#34;
    Removes the ban or timeout that was placed on the specified user

    Args:
        broadcaster_id (str): The ID of the broadcaster whose chat room the user is banned from chatting in
        moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                            This ID must match the user ID associated with the user OAuth token
                            If the broadcaster wants to remove the ban (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
        user_id (str): The ID of the user to remove the ban or timeout from

    Raises:
        twitchpy.errors.ClientError
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/moderation/bans&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;moderator_id&#34;: moderator_id,
        &#34;user_id&#34;: user_id,
    }

    requests.delete(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.unblock_user"><code class="name flex">
<span>def <span class="ident">unblock_user</span></span>(<span>self, target_user_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Unblocks the specified user on behalf of the authenticated user</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the user to be unblocked</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unblock_user(self, target_user_id):
    &#34;&#34;&#34;
    Unblocks the specified user on behalf of the authenticated user

    Args:
        target_user_id (str): User ID of the user to be unblocked
    &#34;&#34;&#34;

    url = ENDPOINT_USER_BLOCKS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;target_user_id&#34;: target_user_id}

    requests.delete(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_automod_settings"><code class="name flex">
<span>def <span class="ident">update_automod_settings</span></span>(<span>self, broadcaster_id, moderator_id, aggression=None, bullying=None, disability=None, misogyny=None, overall_level=None, race_ethnicity_or_religion=None, sex_based_terms=None, sexuality_sex_or_gender=None, swearing=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the broadcaster’s AutoMod settings, which are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster whose AutoMod settings you want to update</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID associated with the user OAuth token
If the broadcaster wants to update their own AutoMod settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too</dd>
<dt><strong><code>aggression</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The Automod level for hostility involving aggression</dd>
<dt><strong><code>bullying</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The Automod level for hostility involving name calling or insults</dd>
<dt><strong><code>disability</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The Automod level for discrimination against disability</dd>
<dt><strong><code>misogyny</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The Automod level for discrimination against women</dd>
<dt><strong><code>overall_level</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The default AutoMod level for the broadcaster</dd>
<dt><strong><code>race_ethnicity_or_religion</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The Automod level for racial discrimination</dd>
<dt><strong><code>sex_based_terms</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The Automod level for sexual content</dd>
<dt><strong><code>sexuality_sex_or_gender</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The AutoMod level for discrimination based on sexuality, sex, or gender</dd>
<dt><strong><code>swearing</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The Automod level for profanity</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_automod_settings(
    self,
    broadcaster_id,
    moderator_id,
    aggression=None,
    bullying=None,
    disability=None,
    misogyny=None,
    overall_level=None,
    race_ethnicity_or_religion=None,
    sex_based_terms=None,
    sexuality_sex_or_gender=None,
    swearing=None,
):
    &#34;&#34;&#34;
    Updates the broadcaster’s AutoMod settings, which are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room

    Args:
        broadcaster_id (str): The ID of the broadcaster whose AutoMod settings you want to update
        moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                            This ID must match the user ID associated with the user OAuth token
                            If the broadcaster wants to update their own AutoMod settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
        aggression (int, optional): The Automod level for hostility involving aggression
        bullying (int, optional): The Automod level for hostility involving name calling or insults
        disability (int, optional): The Automod level for discrimination against disability
        misogyny (int, optional): The Automod level for discrimination against women
        overall_level (int, optional): The default AutoMod level for the broadcaster
        race_ethnicity_or_religion (int, optional): The Automod level for racial discrimination
        sex_based_terms (int, optional): The Automod level for sexual content
        sexuality_sex_or_gender (int, optional): The AutoMod level for discrimination based on sexuality, sex, or gender
        swearing (int, optional): The Automod level for profanity

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/moderation/automod/settings&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
        &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

    if aggression is not None:
        data[&#34;aggression&#34;] = aggression

    if bullying is not None:
        data[&#34;bullying&#34;] = bullying

    if disability is not None:
        data[&#34;disability&#34;] = disability

    if misogyny is not None:
        data[&#34;misogyny&#34;] = misogyny

    if overall_level is not None:
        data[&#34;overall_level&#34;] = overall_level

    if race_ethnicity_or_religion is not None:
        data[&#34;race_ethnicity_or_religion&#34;] = race_ethnicity_or_religion

    if sex_based_terms is not None:
        data[&#34;sex_based_terms&#34;] = sex_based_terms

    if sexuality_sex_or_gender is not None:
        data[&#34;sexuality_sex_or_gender&#34;] = sexuality_sex_or_gender

    if swearing is not None:
        data[&#34;swearing&#34;] = swearing

    response = requests.put(url, headers=headers, json=data)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_channel_guest_star_settings"><code class="name flex">
<span>def <span class="ident">update_channel_guest_star_settings</span></span>(<span>self, broadcaster_id: str, is_moderator_send_live_enabled: bool = None, slot_count: int = None, is_browser_source_audio_enabled: bool = None, group_layout: str = '', regenerate_browser_sources: bool = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Mutates the channel settings for configuration of the Guest Star feature for a particular host</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster you want to update Guest Star settings for</dd>
<dt><strong><code>is_moderator_send_live_enabled</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag determining if Guest Star moderators have access to control whether a guest is live once assigned to a slot</dd>
<dt><strong><code>slot_count</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of slots the Guest Star call interface will allow the host to add to a call.
Required to be between 1 and 6</dd>
<dt><strong><code>is_browser_source_audio_enabled</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag determining if Browser Sources subscribed to sessions on this channel should output audio</dd>
<dt><strong><code>group_layout</code></strong> :&ensp;<code>str</code></dt>
<dd>This setting determines how the guests within a session should be laid out within the browser source
Possible values: TILED_LAYOUT, SCREENSHARE_LAYOUT, HORIZONTAL_LAYOUT, VERTICAL_LAYOUT</dd>
<dt><strong><code>regenerate_browser_sources</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag determining if Guest Star should regenerate the auth token associated with the channel’s browser sources</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_channel_guest_star_settings(
    self,
    broadcaster_id: str,
    is_moderator_send_live_enabled: bool = None,
    slot_count: int = None,
    is_browser_source_audio_enabled: bool = None,
    group_layout: str = &#34;&#34;,
    regenerate_browser_sources: bool = None,
) -&gt; None:
    &#34;&#34;&#34;
    Mutates the channel settings for configuration of the Guest Star feature for a particular host

    Args:
        broadcaster_id (str): The ID of the broadcaster you want to update Guest Star settings for
        is_moderator_send_live_enabled (bool): Flag determining if Guest Star moderators have access to control whether a guest is live once assigned to a slot
        slot_count (int): Number of slots the Guest Star call interface will allow the host to add to a call.
            Required to be between 1 and 6
        is_browser_source_audio_enabled (bool): Flag determining if Browser Sources subscribed to sessions on this channel should output audio
        group_layout (str): This setting determines how the guests within a session should be laid out within the browser source
            Possible values: TILED_LAYOUT, SCREENSHARE_LAYOUT, HORIZONTAL_LAYOUT, VERTICAL_LAYOUT
        regenerate_browser_sources (bool): Flag determining if Guest Star should regenerate the auth token associated with the channel’s browser sources
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/guest_star/channel_settings&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id}

    if is_moderator_send_live_enabled is not None:
        data[&#34;is_moderator_send_live_enabled&#34;] = is_moderator_send_live_enabled

    if slot_count is not None:
        data[&#34;slot_count&#34;] = slot_count

    if is_browser_source_audio_enabled is not None:
        data[&#34;is_browser_source_audio_enabled&#34;] = is_browser_source_audio_enabled

    if group_layout != &#34;&#34;:
        data[&#34;group_layout&#34;] = group_layout

    if regenerate_browser_sources is not None:
        data[&#34;regenerate_browser_sources&#34;] = regenerate_browser_sources

    requests.put(url, headers=headers, json=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_channel_stream_schedule"><code class="name flex">
<span>def <span class="ident">update_channel_stream_schedule</span></span>(<span>self, broadcaster_id, is_vacation_enabled=False, vacation_start_time='', vacation_end_time='', timezone='')</span>
</code></dt>
<dd>
<div class="desc"><p>Update the settings for a channel’s stream schedule
This can be used for setting vacation details</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the broadcaster who owns the channel streaming schedule
Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>is_vacation_enabled</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates if Vacation Mode is enabled
Set to true to add a vacation or false to remove vacation from the channel streaming schedule</dd>
<dt><strong><code>vacation_start_time</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Start time for vacation specified in RFC3339 format
Required if is_vacation_enabled is set to true</dd>
<dt><strong><code>vacation_end_time</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>End time for vacation specified in RFC3339 format
Required if is_vacation_enabled is set to true</dd>
<dt><strong><code>timezone</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The timezone for when the vacation is being scheduled using the IANA time zone database format
Required if is_vacation_enabled is set to true</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_channel_stream_schedule(
    self,
    broadcaster_id,
    is_vacation_enabled=False,
    vacation_start_time=&#34;&#34;,
    vacation_end_time=&#34;&#34;,
    timezone=&#34;&#34;,
):
    &#34;&#34;&#34;
    Update the settings for a channel’s stream schedule
    This can be used for setting vacation details

    Args:
        broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                              Provided broadcaster_id must match the user_id in the user OAuth token
        is_vacation_enabled (bool, optional): Indicates if Vacation Mode is enabled
                                              Set to true to add a vacation or false to remove vacation from the channel streaming schedule
        vacation_start_time (str, optional): Start time for vacation specified in RFC3339 format
                                             Required if is_vacation_enabled is set to true
        vacation_end_time (str, optional): End time for vacation specified in RFC3339 format
                                           Required if is_vacation_enabled is set to true
        timezone (str, optional): The timezone for when the vacation is being scheduled using the IANA time zone database format
                                  Required if is_vacation_enabled is set to true

    Raises:
        twitchpy.errors.ClientError
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/schedule/settings&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id}

    if is_vacation_enabled:
        data[&#34;is_vacation_enabled&#34;] = True

    if vacation_start_time != &#34;&#34;:
        data[&#34;vacation_start_time&#34;] = vacation_start_time

    if vacation_end_time != &#34;&#34;:
        data[&#34;vacation_end_time&#34;] = vacation_end_time

    if timezone != &#34;&#34;:
        data[&#34;timezone&#34;] = timezone

    requests.patch(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_channel_stream_schedule_segment"><code class="name flex">
<span>def <span class="ident">update_channel_stream_schedule_segment</span></span>(<span>self, broadcaster_id, id, start_time='', duration=240, category_id='', title='', is_canceled=False, timezone='')</span>
</code></dt>
<dd>
<div class="desc"><p>Update a single scheduled broadcast or a recurring scheduled broadcast for a channel’s stream schedule</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID of the broadcaster who owns the channel streaming schedule
Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the streaming segment to update</dd>
<dt><strong><code>start_time</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Start time for the scheduled broadcast specified in RFC3339 format</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Duration of the scheduled broadcast in minutes from the start_time
Default: 240</dd>
<dt><strong><code>category_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Game/Category ID for the scheduled broadcast</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Title for the scheduled broadcast
Maximum: 140 characters</dd>
<dt><strong><code>is_canceled</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicated if the scheduled broadcast is canceled</dd>
<dt><strong><code>timezone</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The timezone of the application creating the scheduled broadcast using the IANA time zone database format</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>StreamSchedule</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_channel_stream_schedule_segment(
    self,
    broadcaster_id,
    id,
    start_time=&#34;&#34;,
    duration=240,
    category_id=&#34;&#34;,
    title=&#34;&#34;,
    is_canceled=False,
    timezone=&#34;&#34;,
):
    &#34;&#34;&#34;
    Update a single scheduled broadcast or a recurring scheduled broadcast for a channel’s stream schedule

    Args:
        broadcaster_id (str): User ID of the broadcaster who owns the channel streaming schedule
                              Provided broadcaster_id must match the user_id in the user OAuth token
        id (str): The ID of the streaming segment to update
        start_time (str, optional): Start time for the scheduled broadcast specified in RFC3339 format
        duration (int, optional): Duration of the scheduled broadcast in minutes from the start_time
                                  Default: 240
        category_id (str, optional): Game/Category ID for the scheduled broadcast
        title (str, optional): Title for the scheduled broadcast
                               Maximum: 140 characters
        is_canceled (bool, optional): Indicated if the scheduled broadcast is canceled
        timezone (str, optional): The timezone of the application creating the scheduled broadcast using the IANA time zone database format

    Raises:
        twitchpy.errors.ClientError

    Returns:
        StreamSchedule
    &#34;&#34;&#34;

    url = ENDPOINT_SCHEDULE_SEGMENT
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id}

    if start_time != &#34;&#34;:
        data[&#34;start_time&#34;] = start_time

    if duration != 240:
        data[&#34;duration&#34;] = duration

    if category_id != &#34;&#34;:
        data[&#34;category_id&#34;] = category_id

    if title != &#34;&#34;:
        data[&#34;title&#34;] = title

    if is_canceled is not False:
        data[&#34;is_canceled&#34;] = is_canceled

    if timezone != &#34;&#34;:
        data[&#34;timezone&#34;] = timezone

    response = requests.patch(url, headers=headers, data=data)

    if response.ok:
        schedule = response.json()[&#34;data&#34;][0]
        schedule = StreamSchedule(
            schedule[&#34;segments&#34;],
            schedule[&#34;broadcaster_id&#34;],
            schedule[&#34;broadcaster_name&#34;],
            schedule[&#34;broadcaster_login&#34;],
            schedule[&#34;vacation&#34;],
        )

        return schedule

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_chat_settings"><code class="name flex">
<span>def <span class="ident">update_chat_settings</span></span>(<span>self, broadcaster_id, moderator_id, emote_mode=None, follower_mode=None, follower_mode_duration=0, non_moderator_chat_delay=None, non_moderator_chat_delay_duration=0, slow_mode=None, slow_mode_wait_time=30, subscriber_mode=None, unique_chat_mode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the broadcaster’s chat settings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster whose chat settings you want to update
This ID must match the user ID associated with the user OAuth token</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID associated with the user OAuth token
If the broadcaster wants to update their own settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too</dd>
<dt><strong><code>emote_mode</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>A Boolean value that determines whether chat messages must contain only emotes
Set to true, if only messages that are 100% emotes are allowed; otherwise, false
Default is false</dd>
<dt><strong><code>follower_mode</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>A Boolean value that determines whether the broadcaster restricts the chat room to followers only, based on how long they’ve followed
Set to true, if the broadcaster restricts the chat room to followers only; otherwise, false
Default is false</dd>
<dt><strong><code>follower_mode_duration</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The length of time, in minutes, that the followers must have followed the broadcaster to participate in the chat room
You may specify a value in the range: 0 (no restriction) through 129600 (3 months)
The default is 0</dd>
<dt><strong><code>non_moderator_chat_delay</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>A Boolean value that determines whether the broadcaster adds a short delay before chat messages appear in the chat room
This gives chat moderators and bots a chance to remove them before viewers can see the message
Set to true, if the broadcaster applies a delay; otherwise, false
Default is false</dd>
<dt><strong><code>non_moderator_chat_delay_duration</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The amount of time, in seconds, that messages are delayed from appearing in chat
Possible values are: 2, 4, 6</dd>
<dt><strong><code>slow_mode</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>A Boolean value that determines whether the broadcaster limits how often users in the chat room are allowed to send messages
Set to true, if the broadcaster applies a wait period messages; otherwise, false
Default is false</dd>
<dt><strong><code>slow_mode_wait_time</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The amount of time, in seconds, that users need to wait between sending messages
You may specify a value in the range: 3 (3 second delay) through 120 (2 minute delay)
The default is 30 seconds</dd>
<dt><strong><code>subscriber_mode</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>A Boolean value that determines whether only users that subscribe to the broadcaster’s channel can talk in the chat room
Set to true, if the broadcaster restricts the chat room to subscribers only; otherwise, false
Default is false</dd>
<dt><strong><code>unique_chat_mode</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>A Boolean value that determines whether the broadcaster requires users to post only unique messages in the chat room
Set to true, if the broadcaster requires unique messages only; otherwise, false
Default is false</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_chat_settings(
    self,
    broadcaster_id,
    moderator_id,
    emote_mode=None,
    follower_mode=None,
    follower_mode_duration=0,
    non_moderator_chat_delay=None,
    non_moderator_chat_delay_duration=0,
    slow_mode=None,
    slow_mode_wait_time=30,
    subscriber_mode=None,
    unique_chat_mode=None,
):
    &#34;&#34;&#34;
    Updates the broadcaster’s chat settings

    Args:
        broadcaster_id (str): The ID of the broadcaster whose chat settings you want to update
                              This ID must match the user ID associated with the user OAuth token
        moderator_id (str): The ID of a user that has permission to moderate the broadcaster’s chat room
                            This ID must match the user ID associated with the user OAuth token
                            If the broadcaster wants to update their own settings (instead of having the moderator do it), set this parameter to the broadcaster’s ID, too
        emote_mode (bool, optional): A Boolean value that determines whether chat messages must contain only emotes
                                     Set to true, if only messages that are 100% emotes are allowed; otherwise, false
                                     Default is false
        follower_mode (bool, optional): A Boolean value that determines whether the broadcaster restricts the chat room to followers only, based on how long they’ve followed
                                        Set to true, if the broadcaster restricts the chat room to followers only; otherwise, false
                                        Default is false
        follower_mode_duration (int, optional): The length of time, in minutes, that the followers must have followed the broadcaster to participate in the chat room
                                                You may specify a value in the range: 0 (no restriction) through 129600 (3 months)
                                                The default is 0
        non_moderator_chat_delay (bool, optional): A Boolean value that determines whether the broadcaster adds a short delay before chat messages appear in the chat room
                                                   This gives chat moderators and bots a chance to remove them before viewers can see the message
                                                   Set to true, if the broadcaster applies a delay; otherwise, false
                                                   Default is false
        non_moderator_chat_delay_duration (int, optional): The amount of time, in seconds, that messages are delayed from appearing in chat
                                                           Possible values are: 2, 4, 6
        slow_mode (bool, optional): A Boolean value that determines whether the broadcaster limits how often users in the chat room are allowed to send messages
                                    Set to true, if the broadcaster applies a wait period messages; otherwise, false
                                    Default is false
        slow_mode_wait_time (int, optional): The amount of time, in seconds, that users need to wait between sending messages
                                             You may specify a value in the range: 3 (3 second delay) through 120 (2 minute delay)
                                             The default is 30 seconds
        subscriber_mode (bool, optional): A Boolean value that determines whether only users that subscribe to the broadcaster’s channel can talk in the chat room
                                          Set to true, if the broadcaster restricts the chat room to subscribers only; otherwise, false
                                          Default is false
        unique_chat_mode (bool, optional): A Boolean value that determines whether the broadcaster requires users to post only unique messages in the chat room
                                           Set to true, if the broadcaster requires unique messages only; otherwise, false
                                           Default is false

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/chat/settings&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;moderator_id&#34;: moderator_id}

    if emote_mode is not None:
        data[&#34;emote_mode&#34;] = emote_mode

    if follower_mode is not None:
        data[&#34;follower_mode&#34;] = follower_mode

    if follower_mode_duration != 0:
        data[&#34;follower_mode_duration&#34;] = follower_mode_duration

    if non_moderator_chat_delay is not None:
        data[&#34;non_moderator_chat_delay&#34;] = non_moderator_chat_delay

    if non_moderator_chat_delay_duration != 0:
        data[
            &#34;non_moderator_chat_delay_duration&#34;
        ] = non_moderator_chat_delay_duration

    if slow_mode is not None:
        data[&#34;slow_mode&#34;] = slow_mode

    if slow_mode_wait_time != 30:
        data[&#34;slow_mode_wait_time&#34;] = slow_mode_wait_time

    if subscriber_mode is not None:
        data[&#34;subscriber_mode&#34;] = subscriber_mode

    if unique_chat_mode is not None:
        data[&#34;unique_chat_mode&#34;] = unique_chat_mode

    response = requests.patch(url, headers=headers, data=data)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_conduit_shards"><code class="name flex">
<span>def <span class="ident">update_conduit_shards</span></span>(<span>self, conduit_id: str, shards: list[dict], session_id: str = '') ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Updates shard(s) for a conduit</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conduit_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Conduit ID</dd>
<dt><strong><code>shards</code></strong> :&ensp;<code>list[dict]</code></dt>
<dd>List of shards to update</dd>
<dt><strong><code>session_id</code></strong> :&ensp;<code>str</code></dt>
<dd>An ID that identifies the WebSocket to send notifications to
Specify this field only if method is set to websocket</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_conduit_shards(self, conduit_id: str, shards: list[dict], session_id: str = &#34;&#34;) -&gt; dict:
    &#34;&#34;&#34;
    Updates shard(s) for a conduit

    Args:
        conduit_id (str): Conduit ID
        shards (list[dict]): List of shards to update
        session_id (str): An ID that identifies the WebSocket to send notifications to
            Specify this field only if method is set to websocket

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/eventsub/conduits/shards&#34;
    headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id, &#34;Content-Type&#34;: &#34;application/json&#34;}
    data = {&#34;conduit_id&#34;: conduit_id, &#34;shards&#34;: shards}

    if session_id != &#34;&#34;:
        data[&#34;session_id&#34;] = session_id

    response = requests.patch(url, headers=headers, data=data)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_conduits"><code class="name flex">
<span>def <span class="ident">update_conduits</span></span>(<span>self, id: str, shard_count: int) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Updates a conduit’s shard count
To delete shards, update the count to a lower number, and the shards above the count will be deleted</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>Conduit ID</dd>
<dt><strong><code>shard_count</code></strong> :&ensp;<code>int</code></dt>
<dd>The new number of shards for this conduit</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_conduits(self, id: str, shard_count: int) -&gt; dict:
    &#34;&#34;&#34;
    Updates a conduit’s shard count
    To delete shards, update the count to a lower number, and the shards above the count will be deleted

    Args:
        id (str): Conduit ID
        shard_count (int): The new number of shards for this conduit

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/eventsub/conduits&#34;
    headers = {&#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;, &#34;Client-Id&#34;: self.client_id, &#34;Content-Type&#34;: &#34;application/json&#34;}
    data = {&#34;id&#34;: id, &#34;shard_count&#34;: shard_count}

    response = requests.patch(url, headers=headers, data=data)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_custom_reward"><code class="name flex">
<span>def <span class="ident">update_custom_reward</span></span>(<span>self, broadcaster_id, id, title='', prompt='', cost=None, background_color='', is_enabled=None, is_user_input_required=None, is_max_per_stream_enabled=None, max_per_stream=None, is_max_per_user_per_stream_enabled=None, max_per_user_per_stream=None, is_global_cooldown_enabled=None, global_cooldown_seconds=None, is_paused=None, should_redemptions_skip_request_queue=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates a Custom Reward created on a channel
The Custom Reward specified by id must have been created by the client_id attached to the user OAuth token</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the Custom Reward to update
Must match a Custom Reward on the channel of the broadcaster_id</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The title of the reward</dd>
<dt><strong><code>prompt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The prompt for the viewer when they are redeeming the reward</dd>
<dt><strong><code>cost</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The cost of the reward</dd>
<dt><strong><code>background_color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Custom background color for the reward as a hexadecimal value</dd>
<dt><strong><code>is_enabled</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Is the reward currently enabled, if false the reward won’t show up to viewers</dd>
<dt><strong><code>is_user_input_required</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Does the user need to enter information when redeeming the reward</dd>
<dt><strong><code>is_max_per_stream_enabled</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether a maximum per stream is enabled
Required when any value of max_per_stream is included</dd>
<dt><strong><code>max_per_stream</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum number per stream if enabled
Required when any value of is_max_per_stream_enabled is included</dd>
<dt><strong><code>is_max_per_user_per_stream_enabled</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether a maximum per user per stream is enabled
Required when any value of max_per_user_per_stream is included</dd>
<dt><strong><code>max_per_user_per_stream</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum number per user per stream if enabled
Required when any value of is_max_per_user_per_stream_enabled is included</dd>
<dt><strong><code>is_global_cooldown_enabled</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether a cooldown is enabled
Required when any value of global_cooldown_seconds is included</dd>
<dt><strong><code>global_cooldown_seconds</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The cooldown in seconds if enabled
Required when any value of is_global_cooldown_enabled is included</dd>
<dt><strong><code>is_paused</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Is the reward currently paused, if true viewers cannot redeem</dd>
<dt><strong><code>should_redemptions_skip_request_queue</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should redemptions be set to FULFILLED status immediately when redeemed and skip the request queue instead of the normal UNFULFILLED status</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>Reward</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_custom_reward(
    self,
    broadcaster_id,
    id,
    title=&#34;&#34;,
    prompt=&#34;&#34;,
    cost=None,
    background_color=&#34;&#34;,
    is_enabled=None,
    is_user_input_required=None,
    is_max_per_stream_enabled=None,
    max_per_stream=None,
    is_max_per_user_per_stream_enabled=None,
    max_per_user_per_stream=None,
    is_global_cooldown_enabled=None,
    global_cooldown_seconds=None,
    is_paused=None,
    should_redemptions_skip_request_queue=None,
):
    &#34;&#34;&#34;
    Updates a Custom Reward created on a channel
    The Custom Reward specified by id must have been created by the client_id attached to the user OAuth token

    Args:
        broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
        id (str): ID of the Custom Reward to update
                  Must match a Custom Reward on the channel of the broadcaster_id
        title (str, optional): The title of the reward
        prompt (str, optional): The prompt for the viewer when they are redeeming the reward
        cost (int, optional): The cost of the reward
        background_color (str, optional): Custom background color for the reward as a hexadecimal value
        is_enabled (bool, optional): Is the reward currently enabled, if false the reward won’t show up to viewers
        is_user_input_required (bool, optional): Does the user need to enter information when redeeming the reward
        is_max_per_stream_enabled (bool, optional): Whether a maximum per stream is enabled
                                                    Required when any value of max_per_stream is included
        max_per_stream (int, optional): The maximum number per stream if enabled
                                        Required when any value of is_max_per_stream_enabled is included
        is_max_per_user_per_stream_enabled (bool, optional): Whether a maximum per user per stream is enabled
                                                             Required when any value of max_per_user_per_stream is included
        max_per_user_per_stream (int, optional): The maximum number per user per stream if enabled
                                                 Required when any value of is_max_per_user_per_stream_enabled is included
        is_global_cooldown_enabled (bool, optional): Whether a cooldown is enabled
                                                     Required when any value of global_cooldown_seconds is included
        global_cooldown_seconds (int, optional): The cooldown in seconds if enabled
                                                 Required when any value of is_global_cooldown_enabled is included
        is_paused (bool, optional): Is the reward currently paused, if true viewers cannot redeem
        should_redemptions_skip_request_queue (bool, optional): Should redemptions be set to FULFILLED status immediately when redeemed and skip the request queue instead of the normal UNFULFILLED status

    Raises:
        twitchpy.errors.ClientError

    Returns:
        Reward
    &#34;&#34;&#34;

    url = ENDPOINT_CUSTOM_REWARDS
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;broadcaster_id&#34;: broadcaster_id, &#34;id&#34;: id}

    if title != &#34;&#34;:
        data[&#34;title&#34;] = title

    if prompt != &#34;&#34;:
        data[&#34;prompt&#34;] = prompt

    if cost is not None:
        data[&#34;cost&#34;] = cost

    if background_color != &#34;&#34;:
        data[&#34;background_color&#34;] = background_color

    if is_enabled is not None:
        data[&#34;is_enabled&#34;] = is_enabled

    if is_user_input_required is not None:
        data[&#34;is_user_input_required&#34;] = is_user_input_required

    if is_max_per_stream_enabled is not None:
        data[&#34;is_max_per_stream_enabled&#34;] = is_max_per_stream_enabled

    if max_per_stream is not None:
        data[&#34;max_per_stream&#34;] = max_per_stream

    if is_max_per_user_per_stream_enabled is not None:
        data[
            &#34;is_max_per_user_per_stream_enabled&#34;
        ] = is_max_per_user_per_stream_enabled

    if max_per_user_per_stream is not None:
        data[&#34;max_per_user_per_stream&#34;] = max_per_user_per_stream

    if is_global_cooldown_enabled is not None:
        data[&#34;is_global_cooldown_enabled&#34;] = is_global_cooldown_enabled

    if global_cooldown_seconds is not None:
        data[&#34;global_cooldown_seconds&#34;] = global_cooldown_seconds

    if is_paused is not None:
        data[&#34;is_paused&#34;] = is_paused

    if should_redemptions_skip_request_queue is not None:
        data[
            &#34;should_redemptions_skip_request_queue&#34;
        ] = should_redemptions_skip_request_queue

    response = requests.patch(url, headers=headers, data=data)

    if response.ok:
        reward = response.json()[&#34;data&#34;]
        reward = Reward(
            reward[&#34;broadcaster_name&#34;],
            reward[&#34;broadcaster_id&#34;],
            reward[&#34;id&#34;],
            image=reward[&#34;image&#34;],
            background_color=reward[&#34;background_color&#34;],
            is_enabled=reward[&#34;is_enabled&#34;],
            cost=reward[&#34;cost&#34;],
            title=reward[&#34;title&#34;],
            prompt=reward[&#34;prompt&#34;],
            is_user_input_required=reward[&#34;is_user_input_required&#34;],
            max_per_stream_setting=reward[&#34;max_per_stream_setting&#34;],
            max_per_user_per_stream_setting=reward[
                &#34;max_per_user_per_stream_setting&#34;
            ],
            global_cooldown_setting=reward[&#34;global_cooldown_setting&#34;],
            is_paused=reward[&#34;is_paused&#34;],
            is_in_stock=reward[&#34;is_in_stock&#34;],
            default_image=reward[&#34;default_image&#34;],
            should_redemptions_skip_request_queue=reward[
                &#34;should_redemptions_skip_request_queue&#34;
            ],
            redemptions_redeemed_current_stream=reward[
                &#34;redemptions_redeemed_current_stream&#34;
            ],
            cooldown_expires_at=reward[&#34;cooldown_expires_at&#34;],
        )

        return reward

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_drops_entitlements"><code class="name flex">
<span>def <span class="ident">update_drops_entitlements</span></span>(<span>self, entitlement_ids=[], fulfillment_status='')</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the fulfillment status on a set of Drops entitlements, specified by their entitlement IDs</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entitlement_ids</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>An array of unique identifiers of the entitlements to update
Maximum: 100</dd>
<dt><strong><code>fulfillment_status</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A fulfillment status
Valid values are "CLAIMED" or "FULFILLED"</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_drops_entitlements(self, entitlement_ids=[], fulfillment_status=&#34;&#34;):
    &#34;&#34;&#34;
    Updates the fulfillment status on a set of Drops entitlements, specified by their entitlement IDs

    Args:
        entitlement_ids (list, optional): An array of unique identifiers of the entitlements to update
                                          Maximum: 100
        fulfillment_status (str, optional): A fulfillment status
                                            Valid values are &#34;CLAIMED&#34; or &#34;FULFILLED&#34;

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/entitlements/drops&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
        &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
    }
    data = {}

    if len(entitlement_ids) &gt; 0:
        data[&#34;entitlement_ids&#34;] = entitlement_ids

    if fulfillment_status != &#34;&#34;:
        data[&#34;fulfillment_status&#34;] = fulfillment_status

    response = requests.patch(url, headers=headers, data=data)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_extension_bits_product"><code class="name flex">
<span>def <span class="ident">update_extension_bits_product</span></span>(<span>self, extension_client_id, sku, cost, display_name, in_development=False, expiration='', is_broadcast=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add or update a Bits products that belongs to an Extension</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extension_client_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Extension client ID</dd>
<dt><strong><code>sku</code></strong> :&ensp;<code>str</code></dt>
<dd>SKU of the Bits product
This must be unique across all products that belong to an Extension
The SKU cannot be changed after saving
Maximum: 255 characters, no white spaces</dd>
<dt><strong><code>cost</code></strong> :&ensp;<code>dict</code></dt>
<dd>Object containing cost information</dd>
<dt><strong><code>display_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the product to be displayed in the Extension
Maximum: 255 characters</dd>
<dt><strong><code>in_development</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set to true if the product is in development and not yet released for public use
Default: false</dd>
<dt><strong><code>expiration</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Expiration time for the product in RFC3339 format
If not provided, the Bits product will not have an expiration date
Setting an expiration in the past will disable the product</dd>
<dt><strong><code>is_broadcast</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates if Bits product purchase events are broadcast to all instances of an Extension on a channel via the “onTransactionComplete” helper callback
Default: false</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_extension_bits_product(
    self,
    extension_client_id,
    sku,
    cost,
    display_name,
    in_development=False,
    expiration=&#34;&#34;,
    is_broadcast=False,
):
    &#34;&#34;&#34;
    Add or update a Bits products that belongs to an Extension

    Args:
        extension_client_id (str): Extension client ID
        sku (str): SKU of the Bits product
                   This must be unique across all products that belong to an Extension
                   The SKU cannot be changed after saving
                   Maximum: 255 characters, no white spaces
        cost (dict): Object containing cost information
        display_name (str): Name of the product to be displayed in the Extension
                            Maximum: 255 characters
        in_development (bool, optional): Set to true if the product is in development and not yet released for public use
                                         Default: false
        expiration (str, optional): Expiration time for the product in RFC3339 format
                                    If not provided, the Bits product will not have an expiration date
                                    Setting an expiration in the past will disable the product
        is_broadcast (bool, optional): Indicates if Bits product purchase events are broadcast to all instances of an Extension on a channel via the “onTransactionComplete” helper callback
                                       Default: false

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/bits/extensions&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__app_token}&#34;,
        &#34;Client-Id&#34;: extension_client_id,
    }
    data = {&#34;sku&#34;: sku, &#34;cost&#34;: cost, &#34;display_name&#34;: display_name}

    if in_development is not False:
        data[&#34;in_development&#34;] = in_development

    if expiration != &#34;&#34;:
        data[&#34;expiration&#34;] = expiration

    if is_broadcast is not False:
        data[&#34;is_broadcast&#34;] = is_broadcast

    response = requests.put(url, headers=headers, data=data)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_guest_star_slot"><code class="name flex">
<span>def <span class="ident">update_guest_star_slot</span></span>(<span>self, broadcaster_id: str, moderator_id: str, session_id: str, source_slot_id: str, destination_slot_id: str = '') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Allows a user to update the assigned slot for a particular user within the active Guest Star session</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster running the Guest Star session</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
This ID must match the user_id in the user access token</dd>
<dt><strong><code>session_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the Guest Star session in which to update slot settings</dd>
<dt><strong><code>source_slot_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The slot assignment previously assigned to a user</dd>
<dt><strong><code>destination_slot_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The slot to move this user assignment to
If the destination slot is occupied, the user assigned will be swapped into source_slot_id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_guest_star_slot(
    self,
    broadcaster_id: str,
    moderator_id: str,
    session_id: str,
    source_slot_id: str,
    destination_slot_id: str = &#34;&#34;,
) -&gt; None:
    &#34;&#34;&#34;
    Allows a user to update the assigned slot for a particular user within the active Guest Star session

    Args:
        broadcaster_id (str): The ID of the broadcaster running the Guest Star session
        moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
            This ID must match the user_id in the user access token
        session_id (str): The ID of the Guest Star session in which to update slot settings
        source_slot_id (str): The slot assignment previously assigned to a user
        destination_slot_id (str): The slot to move this user assignment to
            If the destination slot is occupied, the user assigned will be swapped into source_slot_id
    &#34;&#34;&#34;

    url = ENDPOINT_GUEST_STAR_SLOT
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;moderator_id&#34;: moderator_id,
        &#34;session_id&#34;: session_id,
        &#34;source_slot_id&#34;: source_slot_id,
    }

    if destination_slot_id != &#34;&#34;:
        data[&#34;destination_slot_id&#34;] = destination_slot_id

    requests.patch(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_guest_star_slot_settings"><code class="name flex">
<span>def <span class="ident">update_guest_star_slot_settings</span></span>(<span>self, broadcaster_id: str, moderator_id: str, session_id: str, slot_id: str, is_audio_enabled: bool = None, is_video_enabled: bool = None, is_live: bool = None, volume: int = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Allows a user to update slot settings for a particular guest within a Guest Star session, such as allowing the user to share audio or video within the call as a host</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster running the Guest Star session</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
This ID must match the user ID in the user access token</dd>
<dt><strong><code>session_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the Guest Star session in which to update a slot’s settings</dd>
<dt><strong><code>slot_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The slot assignment that has previously been assigned to a user</dd>
<dt><strong><code>is_audio_enabled</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag indicating whether the slot is allowed to share their audio with the rest of the session</dd>
<dt><strong><code>is_video_enabled</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag indicating whether the slot is allowed to share their video with the rest of the session</dd>
<dt><strong><code>is_live</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag indicating whether the user assigned to this slot is visible/can be heard from any public subscriptions</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>int</code></dt>
<dd>Value from 0-100 that controls the audio volume for shared views containing the slot</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_guest_star_slot_settings(
    self,
    broadcaster_id: str,
    moderator_id: str,
    session_id: str,
    slot_id: str,
    is_audio_enabled: bool = None,
    is_video_enabled: bool = None,
    is_live: bool = None,
    volume: int = None,
) -&gt; None:
    &#34;&#34;&#34;
    Allows a user to update slot settings for a particular guest within a Guest Star session, such as allowing the user to share audio or video within the call as a host

    Args:
        broadcaster_id (str): The ID of the broadcaster running the Guest Star session
        moderator_id (str): The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room
            This ID must match the user ID in the user access token
        session_id (str): The ID of the Guest Star session in which to update a slot’s settings
        slot_id (str): The slot assignment that has previously been assigned to a user
        is_audio_enabled (bool): Flag indicating whether the slot is allowed to share their audio with the rest of the session
        is_video_enabled (bool): Flag indicating whether the slot is allowed to share their video with the rest of the session
        is_live (bool): Flag indicating whether the user assigned to this slot is visible/can be heard from any public subscriptions
        volume (int): Value from 0-100 that controls the audio volume for shared views containing the slot
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/guest_star/slot_settings&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;moderator_id&#34;: moderator_id,
        &#34;session_id&#34;: session_id,
        &#34;slot_id&#34;: slot_id,
    }

    if is_audio_enabled is not None:
        data[&#34;is_audio_enabled&#34;] = is_audio_enabled

    if is_video_enabled is not None:
        data[&#34;is_video_enabled&#34;] = is_video_enabled

    if is_live is not None:
        data[&#34;is_live&#34;] = is_live

    if volume is not None:
        data[&#34;volume&#34;] = volume

    requests.patch(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_redemption_status"><code class="name flex">
<span>def <span class="ident">update_redemption_status</span></span>(<span>self, id, broadcaster_id, reward_id, status='')</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the status of Custom Reward Redemption objects on a channel that are in the UNFULFILLED status
The Custom Reward Redemption specified by id must be for a Custom Reward created by the client_id attached to the user OAuth token</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>list</code></dt>
<dd>ID of the Custom Reward Redemption to update
Must match a Custom Reward Redemption on broadcaster_id’s channel
Maximum: 50</dd>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Provided broadcaster_id must match the user_id in the user OAuth token</dd>
<dt><strong><code>reward_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the Custom Reward the redemptions to be updated are for</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The new status to set redemptions to
Can be either FULFILLED or CANCELED
Updating to CANCELED will refund the user their Channel Points</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>Redemption</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_redemption_status(self, id, broadcaster_id, reward_id, status=&#34;&#34;):
    &#34;&#34;&#34;
    Updates the status of Custom Reward Redemption objects on a channel that are in the UNFULFILLED status
    The Custom Reward Redemption specified by id must be for a Custom Reward created by the client_id attached to the user OAuth token

    Args:
        id (list): ID of the Custom Reward Redemption to update
                  Must match a Custom Reward Redemption on broadcaster_id’s channel
                  Maximum: 50
        broadcaster_id (str): Provided broadcaster_id must match the user_id in the user OAuth token
        reward_id (str): ID of the Custom Reward the redemptions to be updated are for
        status (str, optional): The new status to set redemptions to
                                Can be either FULFILLED or CANCELED
                                Updating to CANCELED will refund the user their Channel Points

    Raises:
        twitchpy.errors.ClientError

    Returns:
        Redemption
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/channel_points/custom_rewards/redemptions&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;id&#34;: id, &#34;broadcaster_id&#34;: broadcaster_id, &#34;reward_id&#34;: reward_id}

    if status != &#34;&#34;:
        data[&#34;status&#34;] = status

    response = requests.patch(url, headers=headers, data=data)

    if response.ok:
        redemption = response.json()[&#34;data&#34;][0]
        reward = Reward(
            redemption[&#34;broadcaster_name&#34;],
            redemption[&#34;broadcaster_id&#34;],
            redemption[&#34;reward&#34;][&#34;id&#34;],
            cost=redemption[&#34;reward&#34;][&#34;cost&#34;],
            title=redemption[&#34;reward&#34;][&#34;title&#34;],
            prompt=redemption[&#34;reward&#34;][&#34;prompt&#34;],
        )
        redemption = Redemption(
            redemption[&#34;broadcaster_name&#34;],
            redemption[&#34;broadcaster_id&#34;],
            redemption[&#34;id&#34;],
            redemption[&#34;user_id&#34;],
            redemption[&#34;user_name&#34;],
            redemption[&#34;user_input&#34;],
            redemption[&#34;status&#34;],
            redemption[&#34;redeemed_at&#34;],
            reward,
        )

        return redemption

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_shield_mode_status"><code class="name flex">
<span>def <span class="ident">update_shield_mode_status</span></span>(<span>self, broadcaster_id: str, moderator_id: str, is_active: bool) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Activates or deactivates the broadcaster’s Shield Mode</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>broadcaster_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster whose Shield Mode you want to activate or deactivate</dd>
<dt><strong><code>moderator_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the broadcaster or a user that is one of the broadcaster’s moderators
This ID must match the user ID in the access token</dd>
<dt><strong><code>is_active</code></strong> :&ensp;<code>bool</code></dt>
<dd>A Boolean value that determines whether to activate Shield Mode</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_shield_mode_status(
    self, broadcaster_id: str, moderator_id: str, is_active: bool
) -&gt; dict:
    &#34;&#34;&#34;
    Activates or deactivates the broadcaster’s Shield Mode

    Args:
        broadcaster_id (str): The ID of the broadcaster whose Shield Mode you want to activate or deactivate
        moderator_id (str): The ID of the broadcaster or a user that is one of the broadcaster’s moderators
            This ID must match the user ID in the access token
        is_active (bool): A Boolean value that determines whether to activate Shield Mode

    Raises:
        twitchpy.errors.ClientError

    Returns:
        dict
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/moderation/shield_mode&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
        &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
    }
    data = {
        &#34;broadcaster_id&#34;: broadcaster_id,
        &#34;moderator_id&#34;: moderator_id,
        &#34;is_active&#34;: is_active,
    }

    response = requests.put(url, headers=headers, data=data)

    if response.ok:
        return response.json()[&#34;data&#34;][0]

    else:
        twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_user"><code class="name flex">
<span>def <span class="ident">update_user</span></span>(<span>self, description='')</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the description of a user specified by the bearer token
If the description parameter is not provided, no update will occur and the current user data is returned</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>User’s account description</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>User</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_user(self, description=&#34;&#34;):
    &#34;&#34;&#34;
    Updates the description of a user specified by the bearer token
    If the description parameter is not provided, no update will occur and the current user data is returned

    Args:
        description (str, optional): User’s account description

    Raises:
        twitchpy.errors.ClientError

    Returns:
        User
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/users&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {}

    if description != &#34;&#34;:
        data = {&#34;description&#34;: description}

    response = requests.put(url, headers=headers, data=data)

    if response.ok:
        user = response.json()[&#34;data&#34;][0]
        user = User(
            user[&#34;id&#34;],
            user[&#34;login&#34;],
            user[&#34;display_name&#34;],
            user[&#34;type&#34;],
            user[&#34;broadcaster_type&#34;],
            user[&#34;description&#34;],
            user[&#34;profile_image_url&#34;],
            user[&#34;offline_image_url&#34;],
            user[&#34;view_count&#34;],
        )

        return user

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_user_chat_color"><code class="name flex">
<span>def <span class="ident">update_user_chat_color</span></span>(<span>self, user_id: str, color: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the color used for the user’s name in chat</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the user whose chat color you want to update
This ID must match the user ID in the access token</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code></dt>
<dd>The color to use for the user’s name in chat
All users may specify one of the following named color values: blue, blue_violet, cadet_blue, chocolate, coral, dodger_blue, firebrick, golden_rod, green, hot_pink, orange_red, red, sea_green, spring_green, yellow_green
Turbo and Prime users may specify a named color or a Hex color code</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_user_chat_color(self, user_id: str, color: str) -&gt; None:
    &#34;&#34;&#34;
    Updates the color used for the user’s name in chat

    Args:
        user_id (str): The ID of the user whose chat color you want to update
            This ID must match the user ID in the access token
        color (str): The color to use for the user’s name in chat
            All users may specify one of the following named color values: blue, blue_violet, cadet_blue, chocolate, coral, dodger_blue, firebrick, golden_rod, green, hot_pink, orange_red, red, sea_green, spring_green, yellow_green
            Turbo and Prime users may specify a named color or a Hex color code
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/chat/color&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
    }
    data = {&#34;user_id&#34;: user_id, &#34;color&#34;: color}

    requests.put(url, headers=headers, data=data)</code></pre>
</details>
</dd>
<dt id="twitchpy.client.Client.update_user_extensions"><code class="name flex">
<span>def <span class="ident">update_user_extensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the activation state, extension ID, and/or version number of installed extensions for a specified user, identified by a Bearer token
If you try to activate a given extension under multiple extension types, the last write wins (and there is no guarantee of write order)</p>
<h2 id="raises">Raises</h2>
<p>twitchpy.errors.ClientError</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_user_extensions(self):
    &#34;&#34;&#34;
    Updates the activation state, extension ID, and/or version number of installed extensions for a specified user, identified by a Bearer token
    If you try to activate a given extension under multiple extension types, the last write wins (and there is no guarantee of write order)

    Raises:
        twitchpy.errors.ClientError

    Returns:
        list
    &#34;&#34;&#34;

    url = &#34;https://api.twitch.tv/helix/users/extensions&#34;
    headers = {
        &#34;Authorization&#34;: f&#34;Bearer {self.__user_token}&#34;,
        &#34;Client-Id&#34;: self.client_id,
        &#34;Content-Type&#34;: CONTENT_TYPE_APPLICATION_JSON,
    }

    response = requests.put(url, headers=headers)

    if response.ok:
        return response.json()[&#34;data&#34;]

    else:
        raise twitchpy.errors.ClientError(response.json()[&#34;message&#34;])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="twitchpy" href="index.html">twitchpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="twitchpy.client.Client" href="#twitchpy.client.Client">Client</a></code></h4>
<ul class="">
<li><code><a title="twitchpy.client.Client.add_blocked_term" href="#twitchpy.client.Client.add_blocked_term">add_blocked_term</a></code></li>
<li><code><a title="twitchpy.client.Client.add_channel_moderator" href="#twitchpy.client.Client.add_channel_moderator">add_channel_moderator</a></code></li>
<li><code><a title="twitchpy.client.Client.add_channel_vip" href="#twitchpy.client.Client.add_channel_vip">add_channel_vip</a></code></li>
<li><code><a title="twitchpy.client.Client.assign_guest_star_slot" href="#twitchpy.client.Client.assign_guest_star_slot">assign_guest_star_slot</a></code></li>
<li><code><a title="twitchpy.client.Client.ban_user" href="#twitchpy.client.Client.ban_user">ban_user</a></code></li>
<li><code><a title="twitchpy.client.Client.block_user" href="#twitchpy.client.Client.block_user">block_user</a></code></li>
<li><code><a title="twitchpy.client.Client.cancel_raid" href="#twitchpy.client.Client.cancel_raid">cancel_raid</a></code></li>
<li><code><a title="twitchpy.client.Client.check_automod_status" href="#twitchpy.client.Client.check_automod_status">check_automod_status</a></code></li>
<li><code><a title="twitchpy.client.Client.check_user_subscription" href="#twitchpy.client.Client.check_user_subscription">check_user_subscription</a></code></li>
<li><code><a title="twitchpy.client.Client.create_channel_stream_schedule_segment" href="#twitchpy.client.Client.create_channel_stream_schedule_segment">create_channel_stream_schedule_segment</a></code></li>
<li><code><a title="twitchpy.client.Client.create_clip" href="#twitchpy.client.Client.create_clip">create_clip</a></code></li>
<li><code><a title="twitchpy.client.Client.create_conduits" href="#twitchpy.client.Client.create_conduits">create_conduits</a></code></li>
<li><code><a title="twitchpy.client.Client.create_custom_reward" href="#twitchpy.client.Client.create_custom_reward">create_custom_reward</a></code></li>
<li><code><a title="twitchpy.client.Client.create_eventsub_subscription" href="#twitchpy.client.Client.create_eventsub_subscription">create_eventsub_subscription</a></code></li>
<li><code><a title="twitchpy.client.Client.create_extension_secret" href="#twitchpy.client.Client.create_extension_secret">create_extension_secret</a></code></li>
<li><code><a title="twitchpy.client.Client.create_guest_star_session" href="#twitchpy.client.Client.create_guest_star_session">create_guest_star_session</a></code></li>
<li><code><a title="twitchpy.client.Client.create_poll" href="#twitchpy.client.Client.create_poll">create_poll</a></code></li>
<li><code><a title="twitchpy.client.Client.create_prediction" href="#twitchpy.client.Client.create_prediction">create_prediction</a></code></li>
<li><code><a title="twitchpy.client.Client.create_stream_marker" href="#twitchpy.client.Client.create_stream_marker">create_stream_marker</a></code></li>
<li><code><a title="twitchpy.client.Client.delete_channel_stream_schedule_segment" href="#twitchpy.client.Client.delete_channel_stream_schedule_segment">delete_channel_stream_schedule_segment</a></code></li>
<li><code><a title="twitchpy.client.Client.delete_chat_messages" href="#twitchpy.client.Client.delete_chat_messages">delete_chat_messages</a></code></li>
<li><code><a title="twitchpy.client.Client.delete_conduit" href="#twitchpy.client.Client.delete_conduit">delete_conduit</a></code></li>
<li><code><a title="twitchpy.client.Client.delete_custom_reward" href="#twitchpy.client.Client.delete_custom_reward">delete_custom_reward</a></code></li>
<li><code><a title="twitchpy.client.Client.delete_eventsub_subscription" href="#twitchpy.client.Client.delete_eventsub_subscription">delete_eventsub_subscription</a></code></li>
<li><code><a title="twitchpy.client.Client.delete_guest_star_invite" href="#twitchpy.client.Client.delete_guest_star_invite">delete_guest_star_invite</a></code></li>
<li><code><a title="twitchpy.client.Client.delete_guest_star_slot" href="#twitchpy.client.Client.delete_guest_star_slot">delete_guest_star_slot</a></code></li>
<li><code><a title="twitchpy.client.Client.delete_video" href="#twitchpy.client.Client.delete_video">delete_video</a></code></li>
<li><code><a title="twitchpy.client.Client.end_guest_star_session" href="#twitchpy.client.Client.end_guest_star_session">end_guest_star_session</a></code></li>
<li><code><a title="twitchpy.client.Client.end_poll" href="#twitchpy.client.Client.end_poll">end_poll</a></code></li>
<li><code><a title="twitchpy.client.Client.end_prediction" href="#twitchpy.client.Client.end_prediction">end_prediction</a></code></li>
<li><code><a title="twitchpy.client.Client.get_ad_schedule" href="#twitchpy.client.Client.get_ad_schedule">get_ad_schedule</a></code></li>
<li><code><a title="twitchpy.client.Client.get_all_stream_tags" href="#twitchpy.client.Client.get_all_stream_tags">get_all_stream_tags</a></code></li>
<li><code><a title="twitchpy.client.Client.get_automod_settings" href="#twitchpy.client.Client.get_automod_settings">get_automod_settings</a></code></li>
<li><code><a title="twitchpy.client.Client.get_banned_users" href="#twitchpy.client.Client.get_banned_users">get_banned_users</a></code></li>
<li><code><a title="twitchpy.client.Client.get_bits_leaderboard" href="#twitchpy.client.Client.get_bits_leaderboard">get_bits_leaderboard</a></code></li>
<li><code><a title="twitchpy.client.Client.get_blocked_terms" href="#twitchpy.client.Client.get_blocked_terms">get_blocked_terms</a></code></li>
<li><code><a title="twitchpy.client.Client.get_broadcaster_subscriptions" href="#twitchpy.client.Client.get_broadcaster_subscriptions">get_broadcaster_subscriptions</a></code></li>
<li><code><a title="twitchpy.client.Client.get_channel" href="#twitchpy.client.Client.get_channel">get_channel</a></code></li>
<li><code><a title="twitchpy.client.Client.get_channel_chat_badges" href="#twitchpy.client.Client.get_channel_chat_badges">get_channel_chat_badges</a></code></li>
<li><code><a title="twitchpy.client.Client.get_channel_editors" href="#twitchpy.client.Client.get_channel_editors">get_channel_editors</a></code></li>
<li><code><a title="twitchpy.client.Client.get_channel_emotes" href="#twitchpy.client.Client.get_channel_emotes">get_channel_emotes</a></code></li>
<li><code><a title="twitchpy.client.Client.get_channel_followers" href="#twitchpy.client.Client.get_channel_followers">get_channel_followers</a></code></li>
<li><code><a title="twitchpy.client.Client.get_channel_guest_star_settings" href="#twitchpy.client.Client.get_channel_guest_star_settings">get_channel_guest_star_settings</a></code></li>
<li><code><a title="twitchpy.client.Client.get_channel_icalendar" href="#twitchpy.client.Client.get_channel_icalendar">get_channel_icalendar</a></code></li>
<li><code><a title="twitchpy.client.Client.get_channel_stream_schedule" href="#twitchpy.client.Client.get_channel_stream_schedule">get_channel_stream_schedule</a></code></li>
<li><code><a title="twitchpy.client.Client.get_channel_teams" href="#twitchpy.client.Client.get_channel_teams">get_channel_teams</a></code></li>
<li><code><a title="twitchpy.client.Client.get_charity_campaign" href="#twitchpy.client.Client.get_charity_campaign">get_charity_campaign</a></code></li>
<li><code><a title="twitchpy.client.Client.get_charity_campaign_donations" href="#twitchpy.client.Client.get_charity_campaign_donations">get_charity_campaign_donations</a></code></li>
<li><code><a title="twitchpy.client.Client.get_chat_settings" href="#twitchpy.client.Client.get_chat_settings">get_chat_settings</a></code></li>
<li><code><a title="twitchpy.client.Client.get_chatters" href="#twitchpy.client.Client.get_chatters">get_chatters</a></code></li>
<li><code><a title="twitchpy.client.Client.get_cheermotes" href="#twitchpy.client.Client.get_cheermotes">get_cheermotes</a></code></li>
<li><code><a title="twitchpy.client.Client.get_clips" href="#twitchpy.client.Client.get_clips">get_clips</a></code></li>
<li><code><a title="twitchpy.client.Client.get_conduit_shards" href="#twitchpy.client.Client.get_conduit_shards">get_conduit_shards</a></code></li>
<li><code><a title="twitchpy.client.Client.get_conduits" href="#twitchpy.client.Client.get_conduits">get_conduits</a></code></li>
<li><code><a title="twitchpy.client.Client.get_content_classification_labels" href="#twitchpy.client.Client.get_content_classification_labels">get_content_classification_labels</a></code></li>
<li><code><a title="twitchpy.client.Client.get_creator_goals" href="#twitchpy.client.Client.get_creator_goals">get_creator_goals</a></code></li>
<li><code><a title="twitchpy.client.Client.get_custom_reward" href="#twitchpy.client.Client.get_custom_reward">get_custom_reward</a></code></li>
<li><code><a title="twitchpy.client.Client.get_custom_reward_redemption" href="#twitchpy.client.Client.get_custom_reward_redemption">get_custom_reward_redemption</a></code></li>
<li><code><a title="twitchpy.client.Client.get_drops_entitlements" href="#twitchpy.client.Client.get_drops_entitlements">get_drops_entitlements</a></code></li>
<li><code><a title="twitchpy.client.Client.get_emote_sets" href="#twitchpy.client.Client.get_emote_sets">get_emote_sets</a></code></li>
<li><code><a title="twitchpy.client.Client.get_eventsub_subscriptions" href="#twitchpy.client.Client.get_eventsub_subscriptions">get_eventsub_subscriptions</a></code></li>
<li><code><a title="twitchpy.client.Client.get_extension_analytics" href="#twitchpy.client.Client.get_extension_analytics">get_extension_analytics</a></code></li>
<li><code><a title="twitchpy.client.Client.get_extension_bits_products" href="#twitchpy.client.Client.get_extension_bits_products">get_extension_bits_products</a></code></li>
<li><code><a title="twitchpy.client.Client.get_extension_configuration_segment" href="#twitchpy.client.Client.get_extension_configuration_segment">get_extension_configuration_segment</a></code></li>
<li><code><a title="twitchpy.client.Client.get_extension_live_channels" href="#twitchpy.client.Client.get_extension_live_channels">get_extension_live_channels</a></code></li>
<li><code><a title="twitchpy.client.Client.get_extension_secrets" href="#twitchpy.client.Client.get_extension_secrets">get_extension_secrets</a></code></li>
<li><code><a title="twitchpy.client.Client.get_extension_transactions" href="#twitchpy.client.Client.get_extension_transactions">get_extension_transactions</a></code></li>
<li><code><a title="twitchpy.client.Client.get_extensions" href="#twitchpy.client.Client.get_extensions">get_extensions</a></code></li>
<li><code><a title="twitchpy.client.Client.get_followed_channels" href="#twitchpy.client.Client.get_followed_channels">get_followed_channels</a></code></li>
<li><code><a title="twitchpy.client.Client.get_followed_streams" href="#twitchpy.client.Client.get_followed_streams">get_followed_streams</a></code></li>
<li><code><a title="twitchpy.client.Client.get_game_analytics" href="#twitchpy.client.Client.get_game_analytics">get_game_analytics</a></code></li>
<li><code><a title="twitchpy.client.Client.get_games" href="#twitchpy.client.Client.get_games">get_games</a></code></li>
<li><code><a title="twitchpy.client.Client.get_global_chat_badges" href="#twitchpy.client.Client.get_global_chat_badges">get_global_chat_badges</a></code></li>
<li><code><a title="twitchpy.client.Client.get_global_emotes" href="#twitchpy.client.Client.get_global_emotes">get_global_emotes</a></code></li>
<li><code><a title="twitchpy.client.Client.get_guest_star_invites" href="#twitchpy.client.Client.get_guest_star_invites">get_guest_star_invites</a></code></li>
<li><code><a title="twitchpy.client.Client.get_guest_star_session" href="#twitchpy.client.Client.get_guest_star_session">get_guest_star_session</a></code></li>
<li><code><a title="twitchpy.client.Client.get_hype_train_events" href="#twitchpy.client.Client.get_hype_train_events">get_hype_train_events</a></code></li>
<li><code><a title="twitchpy.client.Client.get_moderators" href="#twitchpy.client.Client.get_moderators">get_moderators</a></code></li>
<li><code><a title="twitchpy.client.Client.get_polls" href="#twitchpy.client.Client.get_polls">get_polls</a></code></li>
<li><code><a title="twitchpy.client.Client.get_predictions" href="#twitchpy.client.Client.get_predictions">get_predictions</a></code></li>
<li><code><a title="twitchpy.client.Client.get_released_extensions" href="#twitchpy.client.Client.get_released_extensions">get_released_extensions</a></code></li>
<li><code><a title="twitchpy.client.Client.get_shield_mode_status" href="#twitchpy.client.Client.get_shield_mode_status">get_shield_mode_status</a></code></li>
<li><code><a title="twitchpy.client.Client.get_stream_key" href="#twitchpy.client.Client.get_stream_key">get_stream_key</a></code></li>
<li><code><a title="twitchpy.client.Client.get_stream_markers" href="#twitchpy.client.Client.get_stream_markers">get_stream_markers</a></code></li>
<li><code><a title="twitchpy.client.Client.get_stream_tags" href="#twitchpy.client.Client.get_stream_tags">get_stream_tags</a></code></li>
<li><code><a title="twitchpy.client.Client.get_streams" href="#twitchpy.client.Client.get_streams">get_streams</a></code></li>
<li><code><a title="twitchpy.client.Client.get_teams" href="#twitchpy.client.Client.get_teams">get_teams</a></code></li>
<li><code><a title="twitchpy.client.Client.get_top_games" href="#twitchpy.client.Client.get_top_games">get_top_games</a></code></li>
<li><code><a title="twitchpy.client.Client.get_user_active_extensions" href="#twitchpy.client.Client.get_user_active_extensions">get_user_active_extensions</a></code></li>
<li><code><a title="twitchpy.client.Client.get_user_block_list" href="#twitchpy.client.Client.get_user_block_list">get_user_block_list</a></code></li>
<li><code><a title="twitchpy.client.Client.get_user_chat_color" href="#twitchpy.client.Client.get_user_chat_color">get_user_chat_color</a></code></li>
<li><code><a title="twitchpy.client.Client.get_user_extensions" href="#twitchpy.client.Client.get_user_extensions">get_user_extensions</a></code></li>
<li><code><a title="twitchpy.client.Client.get_users" href="#twitchpy.client.Client.get_users">get_users</a></code></li>
<li><code><a title="twitchpy.client.Client.get_videos" href="#twitchpy.client.Client.get_videos">get_videos</a></code></li>
<li><code><a title="twitchpy.client.Client.get_vips" href="#twitchpy.client.Client.get_vips">get_vips</a></code></li>
<li><code><a title="twitchpy.client.Client.get_webhook_subscriptions" href="#twitchpy.client.Client.get_webhook_subscriptions">get_webhook_subscriptions</a></code></li>
<li><code><a title="twitchpy.client.Client.manage_held_automod_messages" href="#twitchpy.client.Client.manage_held_automod_messages">manage_held_automod_messages</a></code></li>
<li><code><a title="twitchpy.client.Client.modify_channel_information" href="#twitchpy.client.Client.modify_channel_information">modify_channel_information</a></code></li>
<li><code><a title="twitchpy.client.Client.remove_blocked_term" href="#twitchpy.client.Client.remove_blocked_term">remove_blocked_term</a></code></li>
<li><code><a title="twitchpy.client.Client.remove_channel_moderator" href="#twitchpy.client.Client.remove_channel_moderator">remove_channel_moderator</a></code></li>
<li><code><a title="twitchpy.client.Client.remove_channel_vip" href="#twitchpy.client.Client.remove_channel_vip">remove_channel_vip</a></code></li>
<li><code><a title="twitchpy.client.Client.search_categories" href="#twitchpy.client.Client.search_categories">search_categories</a></code></li>
<li><code><a title="twitchpy.client.Client.search_channels" href="#twitchpy.client.Client.search_channels">search_channels</a></code></li>
<li><code><a title="twitchpy.client.Client.send_a_shoutout" href="#twitchpy.client.Client.send_a_shoutout">send_a_shoutout</a></code></li>
<li><code><a title="twitchpy.client.Client.send_chat_announcement" href="#twitchpy.client.Client.send_chat_announcement">send_chat_announcement</a></code></li>
<li><code><a title="twitchpy.client.Client.send_extension_chat_message" href="#twitchpy.client.Client.send_extension_chat_message">send_extension_chat_message</a></code></li>
<li><code><a title="twitchpy.client.Client.send_extension_pubsub_message" href="#twitchpy.client.Client.send_extension_pubsub_message">send_extension_pubsub_message</a></code></li>
<li><code><a title="twitchpy.client.Client.send_guest_star_invite" href="#twitchpy.client.Client.send_guest_star_invite">send_guest_star_invite</a></code></li>
<li><code><a title="twitchpy.client.Client.send_whisper" href="#twitchpy.client.Client.send_whisper">send_whisper</a></code></li>
<li><code><a title="twitchpy.client.Client.set_extension_configuration_segment" href="#twitchpy.client.Client.set_extension_configuration_segment">set_extension_configuration_segment</a></code></li>
<li><code><a title="twitchpy.client.Client.set_extension_required_configuration" href="#twitchpy.client.Client.set_extension_required_configuration">set_extension_required_configuration</a></code></li>
<li><code><a title="twitchpy.client.Client.snooze_next_ad" href="#twitchpy.client.Client.snooze_next_ad">snooze_next_ad</a></code></li>
<li><code><a title="twitchpy.client.Client.start_commercial" href="#twitchpy.client.Client.start_commercial">start_commercial</a></code></li>
<li><code><a title="twitchpy.client.Client.start_raid" href="#twitchpy.client.Client.start_raid">start_raid</a></code></li>
<li><code><a title="twitchpy.client.Client.unban_user" href="#twitchpy.client.Client.unban_user">unban_user</a></code></li>
<li><code><a title="twitchpy.client.Client.unblock_user" href="#twitchpy.client.Client.unblock_user">unblock_user</a></code></li>
<li><code><a title="twitchpy.client.Client.update_automod_settings" href="#twitchpy.client.Client.update_automod_settings">update_automod_settings</a></code></li>
<li><code><a title="twitchpy.client.Client.update_channel_guest_star_settings" href="#twitchpy.client.Client.update_channel_guest_star_settings">update_channel_guest_star_settings</a></code></li>
<li><code><a title="twitchpy.client.Client.update_channel_stream_schedule" href="#twitchpy.client.Client.update_channel_stream_schedule">update_channel_stream_schedule</a></code></li>
<li><code><a title="twitchpy.client.Client.update_channel_stream_schedule_segment" href="#twitchpy.client.Client.update_channel_stream_schedule_segment">update_channel_stream_schedule_segment</a></code></li>
<li><code><a title="twitchpy.client.Client.update_chat_settings" href="#twitchpy.client.Client.update_chat_settings">update_chat_settings</a></code></li>
<li><code><a title="twitchpy.client.Client.update_conduit_shards" href="#twitchpy.client.Client.update_conduit_shards">update_conduit_shards</a></code></li>
<li><code><a title="twitchpy.client.Client.update_conduits" href="#twitchpy.client.Client.update_conduits">update_conduits</a></code></li>
<li><code><a title="twitchpy.client.Client.update_custom_reward" href="#twitchpy.client.Client.update_custom_reward">update_custom_reward</a></code></li>
<li><code><a title="twitchpy.client.Client.update_drops_entitlements" href="#twitchpy.client.Client.update_drops_entitlements">update_drops_entitlements</a></code></li>
<li><code><a title="twitchpy.client.Client.update_extension_bits_product" href="#twitchpy.client.Client.update_extension_bits_product">update_extension_bits_product</a></code></li>
<li><code><a title="twitchpy.client.Client.update_guest_star_slot" href="#twitchpy.client.Client.update_guest_star_slot">update_guest_star_slot</a></code></li>
<li><code><a title="twitchpy.client.Client.update_guest_star_slot_settings" href="#twitchpy.client.Client.update_guest_star_slot_settings">update_guest_star_slot_settings</a></code></li>
<li><code><a title="twitchpy.client.Client.update_redemption_status" href="#twitchpy.client.Client.update_redemption_status">update_redemption_status</a></code></li>
<li><code><a title="twitchpy.client.Client.update_shield_mode_status" href="#twitchpy.client.Client.update_shield_mode_status">update_shield_mode_status</a></code></li>
<li><code><a title="twitchpy.client.Client.update_user" href="#twitchpy.client.Client.update_user">update_user</a></code></li>
<li><code><a title="twitchpy.client.Client.update_user_chat_color" href="#twitchpy.client.Client.update_user_chat_color">update_user_chat_color</a></code></li>
<li><code><a title="twitchpy.client.Client.update_user_extensions" href="#twitchpy.client.Client.update_user_extensions">update_user_extensions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>